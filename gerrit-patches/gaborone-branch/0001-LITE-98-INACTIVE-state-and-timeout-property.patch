From ded32d338111fee04cfc98e9bb7c6a646b730f50 Mon Sep 17 00:00:00 2001
From: Aleksey Volkov <a.volkov@samsung.com>
Date: Mon, 11 Nov 2019 19:32:07 +0200
Subject: [PATCH] [LITE-98] INACTIVE state and timeout property

Signed-off-by: Aleksey Volkov <a.volkov@samsung.com>
Change-Id: Ib002094f4cad79398c5dccd8e5b1b539f0846d8e
---
 api/oc_main.c       |  1 +
 security/oc_acl.c   |  4 ++++
 security/oc_doxm.c  | 58 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 security/oc_doxm.h  |  2 ++
 security/oc_pstat.c | 30 +++++++++++++++++++++++++++
 security/oc_pstat.h |  5 ++++-
 6 files changed, 99 insertions(+), 1 deletion(-)

diff --git a/api/oc_main.c b/api/oc_main.c
index 5d65b095..294c2f99 100644
--- a/api/oc_main.c
+++ b/api/oc_main.c
@@ -241,6 +241,7 @@ oc_main_init(const oc_handler_t *handler)
     oc_sec_load_sp(device);
     oc_sec_load_ecdsa_keypair(device);
 #endif /* OC_PKI */
+    oc_sec_doxm_start_timeout(device);
   }
 #endif
 
diff --git a/security/oc_acl.c b/security/oc_acl.c
index 8c6786c2..458b24b1 100644
--- a/security/oc_acl.c
+++ b/security/oc_acl.c
@@ -328,6 +328,10 @@ oc_sec_check_acl(oc_method_t method, oc_resource_t *resource,
   bool is_public = ((resource->properties & OC_SECURE) == 0);
 
   oc_sec_pstat_t *pstat = oc_sec_get_pstat(endpoint->device);
+  if ( OC_DOS_RFOTMW == pstat->s && !(MULTICAST & endpoint->flags) ) {
+    return false;
+  }
+
   if (!is_DCR && pstat->s != OC_DOS_RFNOP) {
     return false;
   }
diff --git a/security/oc_doxm.c b/security/oc_doxm.c
index 9af758d5..16f6cbc2 100644
--- a/security/oc_doxm.c
+++ b/security/oc_doxm.c
@@ -59,6 +59,53 @@ oc_sec_doxm_init(void)
 #endif /* OC_DYNAMIC_ALLOCATION */
 }
 
+static oc_event_callback_retval_t
+rfotm_timeout_cb(void *data)
+{
+  oc_event_callback_retval_t res = OC_EVENT_DONE;
+  size_t *device = (size_t*)data;
+  oc_sec_pstat_t *pstat = oc_sec_get_pstat(*device);
+  if (OC_DOS_RFOTM != pstat->s || 4 == pstat->om /*|| !nil_uuid(doxm[*device].devowneruuid)*/)
+  {
+    doxm[*device].rfotm_timeout = 0;
+#ifdef OC_DYNAMIC_ALLOCATION
+    free(device);
+#endif /* OC_DYNAMIC_ALLOCATION */
+  } else if (0 < doxm[*device].rfotm_timeout) {
+    (doxm[*device].rfotm_timeout)--;
+    res = OC_EVENT_CONTINUE;
+  } else {
+      if ( !oc_inactive_device(*device) ) {
+        OC_ERR("oc_doxm: transition to RFOTMW state failed");
+      }
+#ifdef OC_DYNAMIC_ALLOCATION
+      free(device);
+#endif /* OC_DYNAMIC_ALLOCATION */
+  }
+  oc_sec_dump_doxm(*device);
+  return res;
+}
+
+void
+oc_sec_doxm_start_timeout(size_t device)
+{
+  size_t *ctx;
+#ifdef OC_DYNAMIC_ALLOCATION
+  ctx = (size_t *)calloc(oc_core_get_num_devices(), sizeof(size_t));
+  if (!ctx) {
+    oc_abort("Insufficient memory");
+  }
+  *ctx = device;
+#else
+  static size_t ctx_arr[OC_MAX_NUM_DEVICES];
+  ctx_arr[device] = device;
+  *ctx = &ctx_arr[device];
+#endif /* OC_DYNAMIC_ALLOCATION */
+  if (0 < doxm[device].rfotm_timeout) {
+    oc_set_delayed_callback(ctx, rfotm_timeout_cb, 1);
+  }
+}
+
 static void
 evaluate_supported_oxms(size_t device)
 {
@@ -92,6 +139,7 @@ oc_sec_doxm_default(size_t device)
   oc_device_info_t *d = oc_core_get_device_info(device);
   oc_gen_uuid(&doxm[device].deviceuuid);
   memcpy(d->di.id, doxm[device].deviceuuid.id, 16);
+  doxm[device].rfotm_timeout = 1800;
   oc_sec_dump_doxm(device);
 }
 
@@ -122,6 +170,8 @@ oc_sec_encode_doxm(size_t device, bool to_storage)
   /* rowneruuid */
   oc_uuid_to_str(&doxm[device].rowneruuid, uuid, OC_UUID_LEN);
   oc_rep_set_text_string(root, rowneruuid, uuid);
+  /* rfotm-timeout */
+  oc_rep_set_int(root, rfotm-timeout, doxm[device].rfotm_timeout);
   oc_rep_end_root_object();
 }
 
@@ -205,6 +255,11 @@ oc_sec_decode_doxm(oc_rep_t *rep, bool from_storage, size_t device)
         }
       } else if (from_storage && len == 3 &&
                  memcmp(oc_string(t->name), "sct", 3) == 0) {
+      } else if (len == 13 &&
+                 memcmp(oc_string(t->name), "rfotm-timeout", 13) == 0) {
+          if (!from_storage) {
+            OC_ERR("oc_doxm: Can't change read only rfotm-timeout property");
+          }
       } else {
         OC_ERR("oc_doxm: Unknown property %s", oc_string(t->name));
         return false;
@@ -273,6 +328,9 @@ oc_sec_decode_doxm(oc_rep_t *rep, bool from_storage, size_t device)
       } else if (from_storage && len == 3 &&
                  memcmp(oc_string(rep->name), "sct", 3) == 0) {
         doxm[device].sct = (int)rep->value.integer;
+      } else if (len == 13 &&
+                 memcmp(oc_string(rep->name), "rfotm-timeout", 13) == 0) {
+        doxm[device].rfotm_timeout= (int)rep->value.integer;
       }
       break;
     /* deviceuuid, devowneruuid and rowneruuid */
diff --git a/security/oc_doxm.h b/security/oc_doxm.h
index 05150ed1..8d5fb2c5 100644
--- a/security/oc_doxm.h
+++ b/security/oc_doxm.h
@@ -46,9 +46,11 @@ typedef struct
   oc_uuid_t deviceuuid;
   oc_uuid_t devowneruuid;
   oc_uuid_t rowneruuid;
+  int rfotm_timeout;
 } oc_sec_doxm_t;
 
 void oc_sec_doxm_init(void);
+void oc_sec_doxm_start_timeout(size_t device);
 void oc_sec_doxm_free(void);
 bool oc_sec_decode_doxm(oc_rep_t *rep, bool from_storage, size_t device);
 void oc_sec_encode_doxm(size_t device, bool to_storage);
diff --git a/security/oc_pstat.c b/security/oc_pstat.c
index 123a140b..e03353b7 100644
--- a/security/oc_pstat.c
+++ b/security/oc_pstat.c
@@ -98,6 +98,9 @@ dump_pstat_dos(oc_sec_pstat_t *ps)
   case OC_DOS_SRESET:
     OC_DBG("oc_pstat: dos is SRESET");
     break;
+  case OC_DOS_RFOTMW:
+    OC_DBG("oc_pstat: dos is RFOTMW");
+    break;
   }
 }
 #endif /* OC_DEBUG */
@@ -126,6 +129,8 @@ valid_transition(size_t device, oc_dostype_t state)
     if (state == OC_DOS_RFOTM || state == OC_DOS_RFNOP)
       return false;
     break;
+  case OC_DOS_RFOTMW:
+    return false;
   }
   return true;
 }
@@ -368,6 +373,21 @@ oc_pstat_handle_state(oc_sec_pstat_t *ps, size_t device, bool from_storage,
     }
     ps->p = false;
   } break;
+  case OC_DOS_RFOTMW: {
+    ps->p = false;
+    ps->s = OC_DOS_RFOTMW;
+    ps->cm = 0;
+    ps->tm = 0;
+    if (doxm->owned || !nil_uuid(&doxm->devowneruuid)) {
+#ifdef OC_DEBUG
+      if (!nil_uuid(&doxm->devowneruuid)) {
+        OC_ERR("non-Nil doxm:devowneruuid in RFOTMW");
+      }
+      OC_ERR("ERROR in RFOTMW\n");
+#endif /* OC_DEBUG */
+      goto pstat_state_error;
+    }
+  } break;
   default:
     return false;
     break;
@@ -609,4 +629,14 @@ oc_reset()
     oc_pstat_reset_device(device, true);
   }
 }
+
+bool
+oc_inactive_device(size_t device)
+{
+    oc_sec_pstat_t ps = { .s = OC_DOS_RFOTMW };
+    bool ret =oc_pstat_handle_state(&ps, device, false, false);
+    oc_sec_dump_pstat(device);
+    return ret;
+}
+
 #endif /* OC_SECURITY */
diff --git a/security/oc_pstat.h b/security/oc_pstat.h
index 97c34e12..049403cc 100644
--- a/security/oc_pstat.h
+++ b/security/oc_pstat.h
@@ -29,7 +29,8 @@ typedef enum {
   OC_DOS_RFOTM,
   OC_DOS_RFPRO,
   OC_DOS_RFNOP,
-  OC_DOS_SRESET
+  OC_DOS_SRESET,
+  OC_DOS_RFOTMW
 } oc_dostype_t;
 
 typedef enum {
@@ -65,6 +66,8 @@ bool oc_pstat_reset_device(size_t device, bool self_reset);
 
 void oc_sec_pstat_set_current_mode(size_t device, oc_dpmtype_t cm);
 
+bool oc_inactive_device(size_t device);
+
 #ifdef __cplusplus
 }
 #endif
-- 
2.16.1.windows.1

