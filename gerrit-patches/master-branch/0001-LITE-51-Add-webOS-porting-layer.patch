From e3934edb56ae6b3ee25f637b8ada15786dc6756f Mon Sep 17 00:00:00 2001
From: "sungmok.shin" <sungmok.shin@lge.com>
Date: Tue, 7 May 2019 11:04:33 +0900
Subject: [PATCH] [LITE-51] Add webOS porting layer

webOS porting layer is introduced in this commit.
Two sample applications are implemented based on the existing ones.
- simpleserver_webos (SERVER)
- client_multithread_webos (CLIENT)
User is able to perform discovery/GET/POST/OBSERVE operation using
above server and client after onboarding is properly done.
webOS specific changes has been done on sample onboarding tool to
own luna service name to communicate with webOS service API.
Most of the resources are inherited from linux porting layer except
the network monitoring feature which is overriden with webOS's own
network service API.

Change-Id: Id75b5e06ae1ffbee5b631031751bf52259a0125c
Signed-off-by: sungmok.shin <sungmok.shin@lge.com>
---
 apps/client_multithread_webos.c                    |  501 +++++++
 apps/simpleserver_webos.c                          |  273 ++++
 onboarding_tool/obtmain.c                          |   40 +
 port/webos/Makefile                                |  468 ++++++
 port/webos/abort.c                                 |   30 +
 .../client_multithread_webos.api.json              |    2 +
 .../client_multithread_webos.manifest.json         |   16 +
 .../client_multithread_webos.perm.json             |    5 +
 .../client_multithread_webos.role.json             |   11 +
 .../client_multithread_webos.service               |   24 +
 .../acg_configuration/onboarding_tool.api.json     |    2 +
 .../onboarding_tool.manifest.json                  |   16 +
 .../acg_configuration/onboarding_tool.perm.json    |    5 +
 .../acg_configuration/onboarding_tool.role.json    |   11 +
 .../acg_configuration/onboarding_tool.service      |   24 +
 .../acg_configuration/simpleserver_webos.api.json  |    2 +
 .../simpleserver_webos.manifest.json               |   16 +
 .../acg_configuration/simpleserver_webos.perm.json |    5 +
 .../acg_configuration/simpleserver_webos.role.json |   11 +
 .../acg_configuration/simpleserver_webos.service   |   24 +
 port/webos/clock.c                                 |   54 +
 .../webos/iotivity-constrained-client-server.pc.in |   25 +
 port/webos/iotivity-constrained-client.pc.in       |   25 +
 port/webos/iotivity-constrained-server.pc.in       |   25 +
 port/webos/ipadapter.c                             | 1515 ++++++++++++++++++++
 port/webos/ipcontext.h                             |  105 ++
 port/webos/luna_adapter_util.c                     |  315 ++++
 port/webos/luna_adapter_util.h                     |   33 +
 port/webos/oc_config.h                             |   95 ++
 port/webos/random.c                                |   49 +
 port/webos/storage.c                               |   86 ++
 port/webos/tcpadapter.c                            |  832 +++++++++++
 port/webos/tcpadapter.h                            |   52 +
 33 files changed, 4697 insertions(+)
 create mode 100644 apps/client_multithread_webos.c
 create mode 100644 apps/simpleserver_webos.c
 create mode 100644 port/webos/Makefile
 create mode 100644 port/webos/abort.c
 create mode 100755 port/webos/acg_configuration/client_multithread_webos.api.json
 create mode 100755 port/webos/acg_configuration/client_multithread_webos.manifest.json
 create mode 100755 port/webos/acg_configuration/client_multithread_webos.perm.json
 create mode 100755 port/webos/acg_configuration/client_multithread_webos.role.json
 create mode 100755 port/webos/acg_configuration/client_multithread_webos.service
 create mode 100755 port/webos/acg_configuration/onboarding_tool.api.json
 create mode 100755 port/webos/acg_configuration/onboarding_tool.manifest.json
 create mode 100755 port/webos/acg_configuration/onboarding_tool.perm.json
 create mode 100755 port/webos/acg_configuration/onboarding_tool.role.json
 create mode 100755 port/webos/acg_configuration/onboarding_tool.service
 create mode 100755 port/webos/acg_configuration/simpleserver_webos.api.json
 create mode 100755 port/webos/acg_configuration/simpleserver_webos.manifest.json
 create mode 100755 port/webos/acg_configuration/simpleserver_webos.perm.json
 create mode 100755 port/webos/acg_configuration/simpleserver_webos.role.json
 create mode 100755 port/webos/acg_configuration/simpleserver_webos.service
 create mode 100644 port/webos/clock.c
 create mode 100644 port/webos/iotivity-constrained-client-server.pc.in
 create mode 100644 port/webos/iotivity-constrained-client.pc.in
 create mode 100644 port/webos/iotivity-constrained-server.pc.in
 create mode 100644 port/webos/ipadapter.c
 create mode 100644 port/webos/ipcontext.h
 create mode 100644 port/webos/luna_adapter_util.c
 create mode 100644 port/webos/luna_adapter_util.h
 create mode 100644 port/webos/oc_config.h
 create mode 100644 port/webos/random.c
 create mode 100644 port/webos/storage.c
 create mode 100644 port/webos/tcpadapter.c
 create mode 100644 port/webos/tcpadapter.h

diff --git a/apps/client_multithread_webos.c b/apps/client_multithread_webos.c
new file mode 100644
index 00000000..12c91618
--- /dev/null
+++ b/apps/client_multithread_webos.c
@@ -0,0 +1,501 @@
+/****************************************************************************
+ *
+ * Copyright 2018 Samsung Electronics All Rights Reserved.
+ * Copyright (c) 2019 LG Electronics, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ ****************************************************************************/
+
+#include "oc_api.h"
+#include "port/oc_clock.h"
+#include <pthread.h>
+#include <signal.h>
+#include <stdio.h>
+
+#include <luna-service2/lunaservice.h>
+#include <glib.h>
+#include <pbnjson.h>
+#include <PmLogLib.h>
+
+static LSHandle *pLsHandle = NULL;
+static GMainLoop *mainloop = NULL;
+
+// define application specific values.
+static const char *spec_version = "ocf.2.0.0";
+static const char *data_model_version = "ocf.res.1.3.0,ocf.sh.1.3.0";
+static const char *resource_rt = "oic.r.switch.binary";
+static const char *device_rt = "oic.wk.d";
+static const char *device_name = "webOS";
+static const char *manufacturer = "LG";
+
+pthread_mutex_t mutex;
+pthread_cond_t cv;
+struct timespec ts;
+
+pthread_mutex_t app_mutex;
+int quit = 0;
+
+#define MAX_URI_LENGTH (30)
+static char a_light[MAX_URI_LENGTH];
+static oc_endpoint_t target_ep;
+static bool resource_found = false;
+
+static bool state;
+static oc_string_t name;
+
+#define OC_IPV6_ADDRSTRLEN (46)
+static char address[OC_IPV6_ADDRSTRLEN + 8];
+static oc_endpoint_t set_ep;
+
+#define PING_RETRY_COUNT (4)
+static size_t ping_count = 0;
+static uint16_t ping_timeout = 1;
+
+typedef void (*custom_func_t)(oc_endpoint_t *);
+
+typedef struct
+{
+  custom_func_t func;
+} custom_func_s;
+
+static int
+app_init(void)
+{
+  int ret = oc_init_platform(manufacturer, NULL, NULL);
+  ret |= oc_add_device("/oic/d", device_rt, device_name, spec_version,
+                       data_model_version, NULL, NULL);
+  return ret;
+}
+
+static bool
+is_resource_found(void)
+{
+  if (!resource_found) {
+    printf("Please discovery resource first!\n");
+    return false;
+  }
+
+  return true;
+}
+
+static void
+stop_observe(void)
+{
+  if (!is_resource_found())
+    return;
+
+  printf("Stopping OBSERVE\n");
+  if (!oc_stop_observe(a_light, &target_ep)) {
+    printf("Please observe start first!\n");
+  }
+}
+
+static void send_ping(uint16_t timeout_seconds);
+
+#ifdef OC_TCP
+static void
+pong_received_handler(oc_client_response_t *data)
+{
+  if (data->code == OC_PING_TIMEOUT) {
+    printf("PING timeout!\n");
+    ping_count++;
+    if (ping_count > PING_RETRY_COUNT) {
+      printf("retry over. close connection.\n");
+      oc_connectivity_end_session(data->endpoint);
+    } else {
+      ping_timeout <<= 1;
+      printf("PING send again.[retry: %d, time: %u]\n", ping_count,
+             ping_timeout);
+      send_ping(ping_timeout);
+    }
+  } else {
+    printf("PONG received:\n");
+    PRINTipaddr(*data->endpoint);
+    printf("\n");
+    ping_count = 0;
+  }
+}
+#endif /* OC_TCP */
+
+static void
+send_ping(uint16_t timeout_seconds)
+{
+  (void)timeout_seconds;
+  if (!is_resource_found())
+    return;
+
+#ifdef OC_TCP
+  if (target_ep.flags & TCP) {
+    if (!oc_send_ping(0, &target_ep, timeout_seconds, pong_received_handler, NULL)) {
+      printf("oc_send_ping failed\n");
+    }
+  } else
+#endif /* !OC_TCP */
+  {
+    printf("PING message is not supported\n");
+  }
+}
+
+static void
+parse_payload(oc_client_response_t *data)
+{
+  oc_rep_t *rep = data->payload;
+  while (rep != NULL) {
+    printf("key %s, value ", oc_string(rep->name));
+    switch (rep->type) {
+    case OC_REP_BOOL:
+      printf("%d\n", rep->value.boolean);
+      state = rep->value.boolean;
+      break;
+    case OC_REP_STRING:
+      printf("%s\n", oc_string(rep->value.string));
+      if (oc_string_len(name))
+        oc_free_string(&name);
+      oc_new_string(&name, oc_string(rep->value.string),
+                    oc_string_len(rep->value.string));
+      break;
+    default:
+      break;
+    }
+    rep = rep->next;
+  }
+}
+
+static void
+observe_response(oc_client_response_t *data)
+{
+  if (data->observe_option == 0) {
+    printf("OBSERVE register success!\n");
+  }
+
+  printf("OBSERVE_light:\n");
+  parse_payload(data);
+}
+
+static void
+observe_request(void)
+{
+  if (!is_resource_found())
+    return;
+
+  oc_do_observe(a_light, &target_ep, NULL, &observe_response, LOW_QOS, NULL);
+  printf("Sent OBSERVE request\n");
+}
+
+static void
+post_response(oc_client_response_t *data)
+{
+  printf("POST_light:\n");
+  if (data->code == OC_STATUS_CHANGED)
+    printf("POST response: CHANGED\n");
+  else if (data->code == OC_STATUS_CREATED)
+    printf("POST response: CREATED\n");
+  else
+    printf("POST response code %d\n", data->code);
+}
+
+static void
+post_request(void)
+{
+  if (!is_resource_found())
+    return;
+
+  if (oc_init_post(a_light, &target_ep, NULL, &post_response, LOW_QOS, NULL)) {
+    oc_rep_start_root_object();
+    oc_rep_set_boolean(root, value, true);
+    oc_rep_end_root_object();
+    if (oc_do_post())
+      printf("Sent POST request\n");
+    else
+      printf("Could not send POST request\n");
+  } else
+    printf("Could not init POST request\n");
+}
+
+static void
+get_response(oc_client_response_t *data)
+{
+  printf("GET_light:\n");
+  parse_payload(data);
+}
+
+static void
+get_request(void)
+{
+  if (!is_resource_found())
+    return;
+
+  oc_do_get(a_light, &target_ep, NULL, &get_response, LOW_QOS, NULL);
+}
+
+static oc_discovery_flags_t
+discovery_handler(const char *anchor, const char *uri, oc_string_array_t types,
+                  oc_interface_mask_t iface_mask, oc_endpoint_t *endpoint,
+                  oc_resource_properties_t bm, void *user_data)
+{
+  oc_discovery_flags_t ret = OC_CONTINUE_DISCOVERY;
+
+  (void)anchor;
+  (void)iface_mask;
+  (void)bm;
+  int i;
+  int uri_len = strlen(uri);
+  uri_len = (uri_len >= MAX_URI_LENGTH) ? MAX_URI_LENGTH - 1 : uri_len;
+  for (i = 0; i < (int)oc_string_array_get_allocated_size(types); i++) {
+    char *t = oc_string_array_get_item(types, i);
+    if (strlen(t) == 19 && strncmp(t, "oic.r.switch.binary", 20) == 0) {
+      strncpy(a_light, uri, uri_len);
+      a_light[uri_len] = '\0';
+
+      printf("Resource %s hosted at endpoints:\n", a_light);
+      if (user_data) {
+        custom_func_s *custom = (custom_func_s *)user_data;
+        custom->func(endpoint);
+      } else {
+        printf("custom function is not set!");
+        goto exit;
+      }
+
+      ret = OC_STOP_DISCOVERY;
+      goto exit;
+    }
+  }
+
+exit:
+  oc_free_server_endpoints(endpoint);
+  return ret;
+}
+
+static void
+find_first_endpoint(oc_endpoint_t *endpoint)
+{
+  oc_endpoint_t *ep = endpoint;
+  memcpy(&target_ep, ep, sizeof(oc_endpoint_t));
+  resource_found = true;
+  while (ep != NULL) {
+    PRINTipaddr(*ep);
+    printf("\n");
+
+    ep = ep->next;
+  }
+}
+
+static void
+find_same_endpoint(oc_endpoint_t *endpoint)
+{
+  oc_endpoint_t *ep = endpoint;
+  while (ep != NULL) {
+    PRINTipaddr(*ep);
+    printf("\n");
+
+    if (oc_endpoint_compare(&set_ep, ep) == 0) {
+      memcpy(&target_ep, ep, sizeof(oc_endpoint_t));
+      resource_found = true;
+    }
+
+    ep = ep->next;
+  }
+}
+
+static void
+signal_event_loop(void)
+{
+  pthread_mutex_lock(&mutex);
+  pthread_cond_signal(&cv);
+  pthread_mutex_unlock(&mutex);
+}
+
+void
+handle_signal(int signal)
+{
+  (void)signal;
+  signal_event_loop();
+  quit = 1;
+}
+
+static void *
+process_func(void *data)
+{
+  (void)data;
+  oc_clock_time_t next_event;
+
+  while (quit != 1) {
+    pthread_mutex_lock(&app_mutex);
+    next_event = oc_main_poll();
+    pthread_mutex_unlock(&app_mutex);
+    pthread_mutex_lock(&mutex);
+    if (next_event == 0) {
+      pthread_cond_wait(&cv, &mutex);
+    } else {
+      ts.tv_sec = (next_event / OC_CLOCK_SECOND);
+      ts.tv_nsec = (next_event % OC_CLOCK_SECOND) * 1.e09 / OC_CLOCK_SECOND;
+      pthread_cond_timedwait(&cv, &mutex, &ts);
+    }
+    pthread_mutex_unlock(&mutex);
+  }
+
+  pthread_exit(0);
+}
+
+void
+print_menu(void)
+{
+  pthread_mutex_lock(&app_mutex);
+  printf("=====================================\n");
+  printf("1. Discovery\n");
+  printf("2. Discovery with endpoint(%s)\n", address);
+  printf("3. Get request\n");
+  printf("4. Post request\n");
+  printf("5. Observe request\n");
+  printf("6. Observe cancel request\n");
+  printf("7. Send Ping\n");
+  printf("0. Quit\n");
+  printf("=====================================\n");
+  pthread_mutex_unlock(&app_mutex);
+}
+
+int
+main(void)
+{
+  struct timespec timeout;
+  LSError lserror;
+  LSErrorInit(&lserror);
+
+  mainloop = g_main_loop_new(NULL, FALSE);
+
+  // Initialize g_main_loop
+  if (!mainloop) {
+    PRINT("Failed to create main loop");
+    return 0;
+  }
+
+  PRINT("OCServer is starting...\n");
+
+  if (!LSRegister("org.ocf.webossample.client_multithread_webos", &pLsHandle, &lserror)) {
+    PRINT("Failed to register LS Handle");
+    LSErrorPrint(&lserror, stderr);
+    return 0;
+  }
+
+  if (!LSGmainAttach(pLsHandle, mainloop, &lserror)) {
+    PRINT("Failed to attach main loop: %s", &lserror);
+    LSErrorPrint(&lserror, stderr);
+    return 0;
+  }
+
+  int init = 0;
+  struct sigaction sa;
+  sigfillset(&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_handler = handle_signal;
+  sigaction(SIGINT, &sa, NULL);
+
+  static const oc_handler_t handler = {.init = app_init,
+                                       .signal_event_loop = signal_event_loop };
+
+#ifdef OC_SECURITY
+  oc_storage_config("./client_multithread_webos_creds");
+#endif /* OC_SECURITY */
+
+  oc_set_con_res_announced(false);
+
+  if (pthread_mutex_init(&mutex, NULL) < 0) {
+    printf("pthread_mutex_init failed!\n");
+    return -1;
+  }
+
+  if (pthread_mutex_init(&app_mutex, NULL) < 0) {
+    printf("pthread_mutex_init failed!\n");
+    pthread_mutex_destroy(&mutex);
+    return -1;
+  }
+
+  init = oc_main_init(&handler);
+  if (init < 0) {
+    printf("oc_main_init failed!(%d)\n", init);
+    goto exit;
+  }
+
+  pthread_t thread;
+  if (pthread_create(&thread, NULL, process_func, NULL) != 0) {
+    printf("Failed to create main thread\n");
+    init = -1;
+    goto exit;
+  }
+
+  custom_func_s first_func = {.func = find_first_endpoint };
+  custom_func_s same_func = {.func = find_same_endpoint };
+
+  int key;
+  while (quit != 1) {
+    print_menu();
+    fflush(stdin);
+    if (!scanf("%d", &key)) {
+      printf("scanf failed!!!!\n");
+      quit = 1;
+      handle_signal(0);
+      break;
+    }
+
+    pthread_mutex_lock(&app_mutex);
+    switch (key) {
+    case 1:
+      resource_found = false;
+      printf("case 1\n");
+      oc_do_ip_discovery(resource_rt, &discovery_handler, &first_func);
+      break;
+    case 2:
+      resource_found = false;
+      oc_do_ip_discovery_at_endpoint(resource_rt, &discovery_handler, &set_ep,
+                                     &same_func);
+      break;
+    case 3:
+      get_request();
+      break;
+    case 4:
+      post_request();
+      break;
+    case 5:
+      observe_request();
+      break;
+    case 6:
+      stop_observe();
+      break;
+    case 7:
+      ping_count = 0;
+      ping_timeout = 1;
+      printf("Send PING\n");
+      send_ping(ping_timeout);
+      break;
+    case 0:
+      quit = 1;
+      handle_signal(0);
+      break;
+    default:
+      printf("unsupported command.\n");
+      break;
+    }
+    pthread_mutex_unlock(&app_mutex);
+  }
+
+  pthread_join(thread, NULL);
+  printf("pthread_join finish!\n");
+
+exit:
+  oc_main_shutdown();
+
+  pthread_mutex_destroy(&mutex);
+  pthread_mutex_destroy(&app_mutex);
+  return 0;
+}
diff --git a/apps/simpleserver_webos.c b/apps/simpleserver_webos.c
new file mode 100644
index 00000000..cfe3a9e3
--- /dev/null
+++ b/apps/simpleserver_webos.c
@@ -0,0 +1,273 @@
+/*
+// Copyright (c) 2016 Intel Corporation
+// Copyright (c) 2019 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#include "oc_api.h"
+#include "port/oc_clock.h"
+#include <pthread.h>
+#include <signal.h>
+#include <stdio.h>
+
+#include <luna-service2/lunaservice.h>
+#include <glib.h>
+#include <pbnjson.h>
+#include <PmLogLib.h>
+
+static LSHandle *pLsHandle = NULL;
+static GMainLoop *mainloop = NULL;
+
+pthread_mutex_t mutex;
+pthread_cond_t cv;
+struct timespec ts;
+
+int quit = 0;
+
+static bool state = false;
+oc_string_t name;
+
+pthread_t threadId_server;
+oc_resource_t *res;
+
+oc_define_interrupt_handler(observe)
+{
+  oc_notify_observers(res);
+}
+
+static int
+app_init(void)
+{
+  oc_activate_interrupt_handler(observe);
+  int ret = oc_init_platform("webOS", NULL, NULL);
+  ret |= oc_add_device("/oic/d", "oic.d.light", "webOS Light", "ocf.2.0.0",
+                        "ocf.res.1.3.0,ocf.sh.1.3.0", NULL, NULL);
+  oc_new_string(&name, "webOS Light", 11);
+  return ret;
+}
+
+static void
+get_light(oc_request_t *request, oc_interface_mask_t iface_mask, void *user_data)
+{
+  (void)user_data;
+
+  PRINT("GET_light:\n");
+  oc_rep_start_root_object();
+  switch (iface_mask) {
+    case OC_IF_BASELINE:
+      oc_process_baseline_interface(request->resource);
+      /* fall through */
+    case OC_IF_RW:
+      oc_rep_set_boolean(root, value, state);
+      oc_rep_set_text_string(root, n, oc_string(name));
+      break;
+    case OC_IF_A:
+      oc_rep_set_boolean(root, value, state);
+      oc_rep_set_text_string(root, n, oc_string(name));
+      break;
+    default:
+      break;
+  }
+  oc_rep_end_root_object();
+  oc_send_response(request, OC_STATUS_OK);
+}
+
+static void
+post_light(oc_request_t *request, oc_interface_mask_t iface_mask, void *user_data)
+{
+  (void)iface_mask;
+  (void)user_data;
+  PRINT("POST_light:\n");
+  oc_rep_t *rep = request->request_payload;
+  while (rep != NULL) {
+    PRINT("key: %s ", oc_string(rep->name));
+    switch (rep->type) {
+      case OC_REP_BOOL:
+        state = rep->value.boolean;
+        PRINT("value: %d\n", state);
+        break;
+      case OC_REP_STRING:
+        oc_free_string(&name);
+        oc_new_string(&name, oc_string(rep->value.string),
+                      oc_string_len(rep->value.string));
+        break;
+      default:
+        oc_send_response(request, OC_STATUS_BAD_REQUEST);
+        return;
+        break;
+    }
+    rep = rep->next;
+  }
+  oc_send_response(request, OC_STATUS_CHANGED);
+}
+
+static void
+put_light(oc_request_t *request, oc_interface_mask_t iface_mask,
+           void *user_data)
+{
+  (void)iface_mask;
+  (void)user_data;
+  post_light(request, iface_mask, user_data);
+}
+
+static void
+register_resources(void)
+{
+  res = oc_new_resource("webOS Light", "/binaryswitch", 1, 0);
+  oc_resource_bind_resource_type(res, "oic.r.switch.binary");
+  oc_resource_bind_resource_interface(res, OC_IF_BASELINE);
+  oc_resource_bind_resource_interface(res, OC_IF_A);
+  oc_resource_set_default_interface(res, OC_IF_A);
+  oc_resource_set_discoverable(res, true);
+  oc_resource_set_periodic_observable(res, 1);
+  oc_resource_set_request_handler(res, OC_GET, get_light, NULL);
+  oc_resource_set_request_handler(res, OC_PUT, put_light, NULL);
+  oc_resource_set_request_handler(res, OC_POST, post_light, NULL);
+  oc_set_con_res_announced(false);
+  oc_create_introspection_resource(0);
+  oc_add_resource(res);
+}
+
+static void
+signal_event_loop(void)
+{
+  pthread_mutex_lock(&mutex);
+  pthread_cond_signal(&cv);
+  pthread_mutex_unlock(&mutex);
+}
+
+void
+handle_signal(int signal)
+{
+  (void)signal;
+  signal_event_loop();
+  quit = 1;
+}
+
+void *serverStarter(gpointer user_data)
+{
+  oc_clock_time_t next_event;
+  while (quit != 1) {
+    next_event = oc_main_poll();
+    pthread_mutex_lock(&mutex);
+    if (next_event == 0) {
+      pthread_cond_wait(&cv, &mutex);
+    } else {
+      ts.tv_sec = (next_event / OC_CLOCK_SECOND);
+      ts.tv_nsec = (next_event % OC_CLOCK_SECOND) * 1.e09 / OC_CLOCK_SECOND;
+      pthread_cond_timedwait(&cv, &mutex, &ts);
+    }
+    pthread_mutex_unlock(&mutex);
+  }
+}
+
+int
+main(void)
+{
+  struct timespec timeout;
+  LSError lserror;
+  LSErrorInit(&lserror);
+
+  mainloop = g_main_loop_new(NULL, FALSE);
+
+  // Initialize g_main_loop
+  if (!mainloop) {
+    PRINT("Failed to create main loop");
+    return 0;
+  }
+
+  PRINT("simpleserver_webos is starting...\n");
+
+  if (!LSRegister("org.ocf.webossample.simpleserver_webos", &pLsHandle, &lserror)) {
+    PRINT("Failed to register LS Handle");
+    LSErrorPrint(&lserror, stderr);
+    return 0;
+  }
+
+  if (!LSGmainAttach(pLsHandle, mainloop, &lserror)) {
+    PRINT("Failed to attach main loop: %s", &lserror);
+    LSErrorPrint(&lserror, stderr);
+    return 0;
+  }
+
+  int init;
+  struct sigaction sa;
+  sigfillset(&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_handler = handle_signal;
+  sigaction(SIGINT, &sa, NULL);
+
+  static const oc_handler_t handler = {.init = app_init,
+    .signal_event_loop = signal_event_loop,
+    .register_resources =
+      register_resources };
+
+#ifdef OC_SECURITY
+  oc_storage_config("./simpleserver_webos_creds");
+#endif /* OC_SECURITY */
+
+  init = oc_main_init(&handler);
+  if (init < 0)
+    return init;
+
+  pthread_create(&threadId_server, NULL, serverStarter, (void *)NULL);
+
+  char input[10] = {0};
+  uint8_t j = 0;
+
+  while (!quit)
+  {
+    printf("\n");
+    printf("*********************************\n");
+    printf("********** webOS Light **********\n");
+    printf("*********************************\n");
+    printf("Control the light locally:\n");
+    printf("1: turn on the switch\n");
+    printf("2: turn off the switch\n");
+    printf("3: show current status\n");
+    printf("99: quit the menu\n");
+    printf("*********************************\n");
+    printf("Select your choice: ");
+    char * ret = fgets(input, sizeof(input), stdin);
+    switch (atoi(input))
+    {
+      case 1:
+        printf("Power up...\n");
+        state = true;
+        oc_signal_interrupt_handler(observe);
+        j = 0;
+        break;
+      case 2:
+        printf("Power down...\n");
+        state = false;
+        j = 0;
+        break;
+      case 3:
+        printf("\n*****************************************************\n");
+        printf("******************* Light status is %d ****************\n", state);
+        printf("*****************************************************\n");
+        break;
+      case 99:
+        quit = true;
+        break;
+      default:
+        printf("Invalid selection...\n");
+        break;
+    }
+  }
+
+  oc_free_string(&name);
+  oc_main_shutdown();
+  return 0;
+}
diff --git a/onboarding_tool/obtmain.c b/onboarding_tool/obtmain.c
index fb544fce..8b1b4aaf 100644
--- a/onboarding_tool/obtmain.c
+++ b/onboarding_tool/obtmain.c
@@ -31,6 +31,13 @@
 #define MAX_NUM_RESOURCES (100)
 #define MAX_NUM_RT (50)
 
+#ifdef WEBOS
+#include <luna-service2/lunaservice.h>
+#include <glib.h>
+#include <pbnjson.h>
+#include <PmLogLib.h>
+#endif
+
 /* Structure in app to track currently discovered owned/unowned devices */
 typedef struct device_handle_t
 {
@@ -69,6 +76,11 @@ static struct timespec ts;
 #endif
 static int quit;
 
+#ifdef WEBOS
+static LSHandle *pLsHandle = NULL;
+static GMainLoop *mainloop = NULL;
+#endif
+
 static void
 display_menu(void)
 {
@@ -1309,6 +1321,34 @@ factory_presets_cb(size_t device, void *data)
 int
 main(void)
 {
+#ifdef WEBOS
+  struct timespec timeout;
+  LSError lserror;
+  LSErrorInit(&lserror);
+
+  mainloop = g_main_loop_new(NULL, FALSE);
+
+  // Initialize g_main_loop
+  if (!mainloop) {
+    PRINT("Failed to create main loop");
+    return 0;
+  }
+
+  PRINT("Onboarding tool is starting...\n");
+
+  if (!LSRegister("org.ocf.webossample.onboarding_tool", &pLsHandle, &lserror)) {
+    PRINT("Failed to register LS Handle");
+    LSErrorPrint(&lserror, stderr);
+    return 0;
+  }
+
+  if (!LSGmainAttach(pLsHandle, mainloop, &lserror)) {
+    PRINT("Failed to attach main loop: %s", &lserror);
+    LSErrorPrint(&lserror, stderr);
+    return 0;
+  }
+#endif
+
 #if defined(_WIN32)
   InitializeCriticalSection(&cs);
   InitializeConditionVariable(&cv);
diff --git a/port/webos/Makefile b/port/webos/Makefile
new file mode 100644
index 00000000..7300c31d
--- /dev/null
+++ b/port/webos/Makefile
@@ -0,0 +1,468 @@
+CC = gcc
+SED = sed
+INSTALL = install
+OS = webos
+ROOT_DIR = ../..
+OUT_DIR = $(ROOT_DIR)/port/$(OS)
+CHECK_SCRIPT = ../../tools/check.py
+VERSION_MAJOR = 1
+VERSION_MINOR = 0
+VERSION = $(VERSION_MAJOR).$(VERSION_MINOR)
+DYNAMIC ?= 1
+SECURE ?= 1
+PKI ?= 1
+DESTDIR ?= /usr/local
+install_bin_dir?=${DESTDIR}/opt/iotivity-constrained/bin/
+prefix = $(DESTDIR)
+exec_prefix = $(prefix)
+bindir = $(exec_prefix)/bin
+libdir = $(exec_prefix)/lib
+includedir = $(prefix)/include
+pkgconfigdir = $(libdir)/pkgconfig
+EXTRA_CFLAGS =
+# ASAN is not supported in webOS yet. Let us disable this until ASAN support is enabled.
+#ifeq ($(ASAN),1)
+#	EXTRA_CFLAGS += -fsanitize=address
+#endif
+
+MBEDTLS_DIR := $(ROOT_DIR)/deps/mbedtls
+GTEST_DIR = $(ROOT_DIR)/deps/gtest
+GTEST_HEADERS = $(GTEST_DIR)/include/gtest/*.h \
+                $(GTEST_DIR)/include/gtest/internal/*.h
+GTEST = gtest_build
+GTEST_CPPFLAGS += -isystem $(GTEST_DIR)/include
+TEST_CXXFLAGS += -g -Wall -Wextra -pthread -std=c++0x -fpermissive -DOC_SERVER -DOC_CLIENT -fprofile-arcs -ftest-coverage
+HEADER_DIR = -I$(ROOT_DIR)/include \
+             -I$(ROOT_DIR) \
+             -I$(OUT_DIR)
+SECURITY_HEADERS = -I$(ROOT_DIR)/security \
+                   -I$(MBEDTLS_DIR)/include
+MESSAGING_HEADERS = -I$(ROOT_DIR)/messaging/coap
+API_TEST_DIR = $(ROOT_DIR)/api/unittest
+API_TEST_OBJ_DIR = $(API_TEST_DIR)/obj
+API_TEST_SRC_FILES := $(wildcard $(API_TEST_DIR)/*.cpp)
+API_TEST_OBJ_FILES := $(patsubst $(API_TEST_DIR)/%.cpp,$(API_TEST_OBJ_DIR)/%.o,$(API_TEST_SRC_FILES))
+SECURITY_TEST_DIR = $(ROOT_DIR)/security/unittest
+SECURITY_TEST_OBJ_DIR = $(SECURITY_TEST_DIR)/obj
+SECURITY_TEST_SRC_FILES := $(wildcard $(SECURITY_TEST_DIR)/*.cpp)
+SECURITY_TEST_OBJ_FILES := $(patsubst $(SECURITY_TEST_DIR)/%.cpp,$(SECURITY_TEST_OBJ_DIR)/%.o,$(SECURITY_TEST_SRC_FILES))
+PLATFORM_TEST_DIR = $(ROOT_DIR)/port/unittest
+PLATFORM_TEST_OBJ_DIR = $(PLATFORM_TEST_DIR)/obj
+PLATFORM_TEST_SRC_FILES := $(wildcard $(PLATFORM_TEST_DIR)/*.cpp)
+PLATFORM_TEST_OBJ_FILES := $(patsubst $(PLATFORM_TEST_DIR)/%.cpp,$(PLATFORM_TEST_OBJ_DIR)/%.o,$(PLATFORM_TEST_SRC_FILES))
+STORAGE_TEST_DIR = storage_test
+$(shell mkdir -p $(STORAGE_TEST_DIR))
+MESSAGING_TEST_DIR = $(ROOT_DIR)/messaging/coap/unittest
+MESSAGING_TEST_OBJ_DIR = $(MESSAGING_TEST_DIR)/obj
+MESSAGING_TEST_SRC_FILES := $(wildcard $(MESSAGING_TEST_DIR)/*.cpp)
+MESSAGING_TEST_OBJ_FILES := $(patsubst $(MESSAGING_TEST_DIR)/%.cpp,$(MESSAGING_TEST_OBJ_DIR)/%.o,$(MESSAGING_TEST_SRC_FILES))
+
+CLOUD_TEST_DIR = $(ROOT_DIR)/api/cloud/unittest
+CLOUD_TEST_OBJ_DIR = $(CLOUD_TEST_DIR)/obj
+CLOUD_TEST_SRC_FILES := $(wildcard $(CLOUD_TEST_DIR)/*.cpp)
+CLOUD_TEST_OBJ_FILES := $(patsubst $(CLOUD_TEST_DIR)/%.cpp,$(CLOUD_TEST_OBJ_DIR)/%.o,$(CLOUD_TEST_SRC_FILES))
+
+UNIT_TESTS = apitest platformtest securitytest messagingtest
+
+DTLS= 	aes.c		aesni.c 	arc4.c  	asn1parse.c	asn1write.c	base64.c	\
+	bignum.c	blowfish.c	camellia.c	ccm.c		cipher.c	cipher_wrap.c	\
+	cmac.c		ctr_drbg.c	des.c		dhm.c		ecdh.c		ecdsa.c		\
+	ecjpake.c	ecp.c		ecp_curves.c	entropy.c	entropy_poll.c	error.c		\
+	gcm.c		havege.c	hmac_drbg.c	md.c		md2.c		md4.c		\
+	md5.c		md_wrap.c	oid.c		padlock.c	\
+	pem.c		pk.c		pk_wrap.c	pkcs12.c	pkcs5.c		pkparse.c	\
+	pkwrite.c	platform.c	ripemd160.c	rsa.c		sha1.c		sha256.c	\
+	sha512.c	threading.c	timing.c	version.c	version_features.c		\
+	xtea.c  	pkcs11.c 	x509.c 		x509_crt.c	debug.c		net_sockets.c	\
+	ssl_cache.c	ssl_ciphersuites.c		ssl_cli.c	ssl_cookie.c			\
+	ssl_srv.c	ssl_ticket.c	ssl_tls.c	rsa_internal.c	x509write_csr.c\
+	x509write_crt.c	x509_create.c	x509_csr.c
+DTLSFLAGS=-I../../deps/mbedtls/include -D__OC_RANDOM
+
+CBOR=../../deps/tinycbor/src/cborencoder.c ../../deps/tinycbor/src/cborencoder_close_container_checked.c ../../deps/tinycbor/src/cborparser.c# ../../deps/tinycbor/src/cbortojson.c ../../deps/tinycbor/src/cborpretty.c ../../deps/tinycbor/src/cborparser_dup_string.c
+
+ifeq ($(PKI),1)
+	CTIMESTAMP=../../api/c-timestamp/timestamp_tm.c
+endif
+
+CTIMESTAMP+=../../api/c-timestamp/timestamp_format.c ../../api/c-timestamp/timestamp_valid.c ../../api/c-timestamp/timestamp_parse.c
+
+SRC_COMMON=$(wildcard ../../util/*.c) ${CBOR} ${CTIMESTAMP}
+SRC=$(wildcard ../../messaging/coap/*.c ../../api/*.c ../../port/${OS}/*.c)
+SRC_CLOUD=$(wildcard ../../api/cloud/*.c)
+
+HEADERS = $(wildcard ../../include/*.h)
+HEADERS += ../../port/${OS}/oc_config.h
+
+HEADERS_COAP = $(wildcard ../../messaging/coap/*.h)
+HEADERS_UTIL = $(wildcard ../../util/*.h)
+HEADERS_UTIL_PT = $(wildcard ../../util/pt/*.h)
+HEADERS_PORT = $(wildcard ../../port/*.h)
+HEADERS_TINYCBOR = $(wildcard ../../deps/tinycbor/src/*.h)
+
+CFLAGS_CLOUD=-I../../api/cloud
+CFLAGS=-fPIC -fno-asynchronous-unwind-tables -fno-omit-frame-pointer -ffreestanding -Os -fno-stack-protector -ffunction-sections -fdata-sections -fno-reorder-functions -fno-defer-pop -fno-strict-overflow -I./ -I../../include/ -I../../ -std=gnu99 -Wall -Wextra -pedantic #-Wl,-Map,client.map
+OBJ_COMMON=$(addprefix obj/,$(notdir $(SRC_COMMON:.c=.o)))
+OBJ_CLIENT=$(addprefix obj/client/,$(notdir $(SRC:.c=.o)))
+OBJ_SERVER=$(addprefix obj/server/,$(filter-out oc_obt.o oc_obt_otm_justworks.o oc_obt_otm_randompin.o oc_obt_otm_cert.o oc_obt_certs.o,$(notdir $(SRC:.c=.o))))
+OBJ_CLOUD=$(addprefix obj/cloud/,$(notdir $(SRC_CLOUD:.c=.o)))
+OBJ_CLIENT_SERVER=$(addprefix obj/client_server/,$(notdir $(SRC:.c=.o)))
+VPATH=../../messaging/coap/:../../util/:../../api/:../../deps/tinycbor/src/:../../deps/mbedtls/library:../../api/c-timestamp:../../service/cloud/src/:../../service/resource-directory/client/src/:
+LIBS?= -lm -pthread -lrt -lluna-service2 -lglib-2.0 -lpbnjson_c -lPmLogLib
+
+SAMPLES = simpleserver_webos client_multithread_webos
+ifeq ($(CLOUD),1)
+#	UNIT_TESTS += cloudtest
+endif
+ifeq ($(CLOUD),1)
+	CFLAGS += -DOC_CLOUD
+	TCP=1
+	IPV4=1
+	SAMPLES += cloud_linux cloud_tests
+endif
+
+OBT = onboarding_tool
+
+ifeq ($(DEBUG),1)
+	CFLAGS += -DOC_DEBUG -g -O0
+ifeq ($(DEBUG_TLS),1)
+	CFLAGS += -DOC_DEBUG_TLS
+endif
+else
+	CFLAGS += -Wl,--gc-sections
+endif
+
+ifeq ($(PKI),1)
+	EXTRA_CFLAGS += -DOC_PKI
+endif
+
+EXTRA_CFLAGS += -DOC_IDD_API
+
+ifeq ($(DYNAMIC),1)
+	EXTRA_CFLAGS += -DOC_DYNAMIC_ALLOCATION
+endif
+
+ifneq ($(SECURE),0)
+	SRC += $(addprefix ../../security/,oc_acl.c oc_cred.c oc_doxm.c oc_pstat.c oc_tls.c oc_svr.c oc_store.c oc_pki.c oc_certs.c oc_sp.c oc_keypair.c oc_csr.c oc_roles.c)
+	SRC_COMMON += $(addprefix $(MBEDTLS_DIR)/library/,${DTLS})
+	MBEDTLS_PATCH_FILE := $(MBEDTLS_DIR)/patched.txt
+ifeq ($(DYNAMIC),1)
+	SRC += ../../security/oc_obt.c ../../security/oc_obt_otm_justworks.c ../../security/oc_obt_otm_randompin.c ../../security/oc_obt_otm_cert.c ../../security/oc_obt_certs.c
+	SAMPLES += ${OBT}
+else
+	SRC_COMMON += $(MBEDTLS_DIR)/library/memory_buffer_alloc.c
+endif
+	CFLAGS += ${DTLSFLAGS}
+	EXTRA_CFLAGS += -DOC_SECURITY
+	VPATH += ../../security/:../../deps/mbedtls/library:
+endif
+
+LUNA_HEADERS = -I$(PKG_SYS_ROOT)/usr/include -I$(PKG_SYS_ROOT)/usr/include/glib-2.0 -I$(PKG_SYS_ROOT)/usr/lib/glib-2.0/include
+CFLAGS += $(LUNA_HEADERS)
+CFLAGS += -DWEBOS
+
+ifeq ($(IPV4),1)
+	EXTRA_CFLAGS += -DOC_IPV4
+endif
+
+ifeq ($(TCP),1)
+	EXTRA_CFLAGS += -DOC_TCP
+endif
+
+CFLAGS += $(EXTRA_CFLAGS)
+
+ifeq ($(MEMTRACE),1)
+	CFLAGS += -DOC_MEMORY_TRACE
+endif
+
+SAMPLES_CREDS = $(addsuffix _creds, ${SAMPLES} ${OBT})
+
+CONSTRAINED_LIBS = libiotivity-constrained-server.a libiotivity-constrained-client.a \
+		   libiotivity-constrained-server.so libiotivity-constrained-client.so \
+		   libiotivity-constrained-client-server.so libiotivity-constrained-client-server.a
+PC = iotivity-constrained-client.pc iotivity-constrained-server.pc \
+     iotivity-constrained-client-server.pc
+
+all: $(CONSTRAINED_LIBS) $(SAMPLES) $(PC)
+
+test: $(UNIT_TESTS)
+	for test in $^ ; do ./$${test} ; done
+
+.PHONY: test clean
+
+$(GTEST):
+	$(MAKE) --directory=$(GTEST_DIR)/make
+
+$(API_TEST_OBJ_DIR)/%.o: $(API_TEST_DIR)/%.cpp
+	@mkdir -p ${@D}
+	$(CXX) $(GTEST_CPPFLAGS) $(TEST_CXXFLAGS) $(EXTRA_CFLAGS) $(HEADER_DIR) -I$(ROOT_DIR)/deps/tinycbor/src -c $< -o $@
+
+apitest: $(API_TEST_OBJ_FILES) libiotivity-constrained-client-server.a | $(GTEST)
+	$(CXX) $^ -o $@ $(GTEST_CPPFLAGS) $(TEST_CXXFLAGS) $(EXTRA_CFLAGS) $(HEADER_DIR) -L$(OUT_DIR) -L$(GTEST_DIR)/make -l:gtest_main.a -liotivity-constrained-client-server -lpthread
+
+$(SECURITY_TEST_OBJ_DIR)/%.o: $(SECURITY_TEST_DIR)/%.cpp
+	@mkdir -p ${@D}
+	$(CXX) $< -o $@ $(GTEST_CPPFLAGS) $(TEST_CXXFLAGS) $(EXTRA_CFLAGS) $(HEADER_DIR) $(SECURITY_HEADERS) -c
+
+securitytest: $(SECURITY_TEST_OBJ_FILES) libiotivity-constrained-client-server.a | $(GTEST)
+	$(CXX) $(GTEST_CPPFLAGS) $(TEST_CXXFLAGS) $(EXTRA_CFLAGS)  $(HEADER_DIR) -l:gtest_main.a -liotivity-constrained-client-server -L$(OUT_DIR) -L$(GTEST_DIR)/make -lpthread $^ -o $@
+
+$(PLATFORM_TEST_OBJ_DIR)/%.o: $(PLATFORM_TEST_DIR)/%.cpp
+	@mkdir -p ${@D}
+	$(CXX) $< -o $@ $(GTEST_CPPFLAGS) $(TEST_CXXFLAGS) $(EXTRA_CFLAGS) $(HEADER_DIR) -I$(ROOT_DIR)/deps/tinycbor/src -c
+
+platformtest: $(PLATFORM_TEST_OBJ_FILES) libiotivity-constrained-client-server.a | $(GTEST)
+	$(CXX) $(GTEST_CPPFLAGS) $(TEST_CXXFLAGS) $(EXTRA_CFLAGS) $(HEADER_DIR) -l:gtest_main.a -liotivity-constrained-client-server -L$(OUT_DIR) -L$(GTEST_DIR)/make -lpthread $^ -o $@
+
+$(CLOUD_TEST_OBJ_DIR)/%.o: $(CLOUD_TEST_DIR)/%.cpp
+	@mkdir -p ${@D}
+	$(CXX) $(GTEST_CPPFLAGS) $(TEST_CXXFLAGS) $(EXTRA_CFLAGS) $(HEADER_DIR) $(CFLAGS_CLOUD) -I$(ROOT_DIR)/service/cloud/src -I$(ROOT_DIR)/deps/tinycbor/src -c $< -o $@
+
+cloudtest: $(CLOUD_TEST_OBJ_FILES) libiotivity-constrained-client-server.a | $(GTEST)
+	$(CXX) $(GTEST_CPPFLAGS) $(TEST_CXXFLAGS) $(EXTRA_CFLAGS) $(HEADER_DIR) $(CFLAGS_CLOUD) -l:gtest_main.a -liotivity-constrained-client-server -L$(OUT_DIR) -L$(GTEST_DIR)/make -lpthread $^ -o $@
+
+$(MESSAGING_TEST_OBJ_DIR)/%.o: $(MESSAGING_TEST_DIR)/%.cpp
+	@mkdir -p ${@D}
+	$(CXX) $(GTEST_CPPFLAGS) $(TEST_CXXFLAGS) $(EXTRA_CFLAGS) $(HEADER_DIR) $(MESSAGING_HEADERS) -c $< -o $@
+
+messagingtest: $(MESSAGING_TEST_OBJ_FILES) libiotivity-constrained-client-server.a | $(GTEST)
+	$(CXX) $(GTEST_CPPFLAGS) $(TEST_CXXFLAGS) $(EXTRA_CFLAGS)  $(HEADER_DIR) -l:gtest_main.a -liotivity-constrained-client-server -L$(OUT_DIR) -L$(GTEST_DIR)/make -lpthread $^ -o $@
+
+${SRC} ${SRC_COMMON}: $(MBEDTLS_PATCH_FILE)
+
+obj/%.o: %.c
+	@mkdir -p ${@D}
+	${CC} -c -o $@ $< ${CFLAGS}
+
+obj/server/%.o: %.c
+	@mkdir -p ${@D}
+	${CC} -c -o $@ $< ${CFLAGS} -DOC_SERVER
+
+obj/client/%.o: %.c
+	@mkdir -p ${@D}
+	${CC} -c -o $@ $< ${CFLAGS} -DOC_CLIENT
+
+obj/client_server/%.o: %.c
+	@mkdir -p ${@D}
+	${CC} -c -o $@ $< ${CFLAGS} -DOC_CLIENT -DOC_SERVER
+
+obj/cloud/%.o: %.c
+	@mkdir -p ${@D}
+	${CC} -c -o $@ $< ${CFLAGS} ${CFLAGS_CLOUD}
+
+obj/server/oc_introspection.o: ../../include/server_introspection.dat.h
+obj/client/oc_introspection.o: ../../include/server_introspection.dat.h
+obj/client_server/oc_introspection.o: ../../include/server_introspection.dat.h
+
+libiotivity-constrained-server.a: $(OBJ_COMMON) $(OBJ_SERVER)
+	$(AR) -rcs $@ $(OBJ_COMMON) $(OBJ_SERVER)
+
+libiotivity-constrained-server.so: $(OBJ_COMMON) $(OBJ_SERVER)
+	$(CC) -shared -o $@ $(OBJ_COMMON) $(OBJ_SERVER) $(LIBS)
+
+libiotivity-constrained-client.a: $(OBJ_COMMON) $(OBJ_CLIENT)
+	$(AR) -rcs $@ $(OBJ_COMMON) $(OBJ_CLIENT)
+
+libiotivity-constrained-client.so: $(OBJ_COMMON) $(OBJ_CLIENT)
+	$(CC) -shared -o $@ $(OBJ_COMMON) $(OBJ_CLIENT) $(LIBS)
+
+libiotivity-constrained-client-server.a: $(OBJ_COMMON) $(OBJ_CLIENT_SERVER) $(OBJ_CLOUD)
+	$(AR) -rcs $@ $(OBJ_COMMON) $(OBJ_CLIENT_SERVER) $(OBJ_CLOUD)
+
+libiotivity-constrained-client-server.so: $(OBJ_COMMON) $(OBJ_CLIENT_SERVER) $(OBJ_CLOUD)
+	$(CC) -shared -o $@ $(OBJ_COMMON) $(OBJ_CLIENT_SERVER) $(OBJ_CLOUD) $(LIBS)
+
+server: libiotivity-constrained-server.a $(ROOT_DIR)/apps/server_linux.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/server_linux.c libiotivity-constrained-server.a -DOC_SERVER ${CFLAGS} ${LIBS}
+
+client: libiotivity-constrained-client.a $(ROOT_DIR)/apps/client_linux.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/client_linux.c libiotivity-constrained-client.a -DOC_CLIENT ${CFLAGS} ${LIBS}
+
+smart_lock: libiotivity-constrained-client.a $(ROOT_DIR)/apps/smart_lock_linux.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/smart_lock_linux.c libiotivity-constrained-client.a -DOC_CLIENT ${CFLAGS} ${LIBS}
+
+temp_sensor: libiotivity-constrained-client.a $(ROOT_DIR)/apps/temp_sensor_client_linux.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/temp_sensor_client_linux.c libiotivity-constrained-client.a -DOC_CLIENT ${CFLAGS} ${LIBS}
+
+simpleserver_webos: libiotivity-constrained-server.a $(ROOT_DIR)/apps/simpleserver_webos.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/simpleserver_webos.c libiotivity-constrained-server.a -DOC_SERVER ${CFLAGS}  ${LIBS}
+
+simpleserver_pki: libiotivity-constrained-server.a $(ROOT_DIR)/apps/simpleserver_pki.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/simpleserver_pki.c libiotivity-constrained-server.a -DOC_SERVER ${CFLAGS}  ${LIBS}
+
+simpleclient: libiotivity-constrained-client.a $(ROOT_DIR)/apps/simpleclient.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/simpleclient.c libiotivity-constrained-client.a -DOC_CLIENT ${CFLAGS}  ${LIBS}
+
+client_collections_linux: libiotivity-constrained-client.a $(ROOT_DIR)/apps/client_collections_linux.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/client_collections_linux.c libiotivity-constrained-client.a -DOC_CLIENT ${CFLAGS}  ${LIBS}
+
+server_collections_linux: libiotivity-constrained-server.a $(ROOT_DIR)/apps/server_collections_linux.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/server_collections_linux.c libiotivity-constrained-server.a -DOC_SERVER ${CFLAGS} ${LIBS}
+
+client_block_linux: libiotivity-constrained-client.a $(ROOT_DIR)/apps/client_block_linux.c
+	${CC} -o $@ ../../apps/client_block_linux.c libiotivity-constrained-client.a -DOC_CLIENT ${CFLAGS}  ${LIBS}
+
+server_block_linux: libiotivity-constrained-server.a $(ROOT_DIR)/apps/server_block_linux.c
+	${CC} -o $@ ../../apps/server_block_linux.c libiotivity-constrained-server.a -DOC_SERVER ${CFLAGS} ${LIBS}
+
+smart_home_server_linux: libiotivity-constrained-server.a $(ROOT_DIR)/apps/smart_home_server_linux.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/smart_home_server_linux.c libiotivity-constrained-server.a -DOC_SERVER ${CFLAGS} ${LIBS}
+
+multi_device_server: libiotivity-constrained-server.a $(ROOT_DIR)/apps/multi_device_server_linux.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/multi_device_server_linux.c libiotivity-constrained-server.a -DOC_SERVER ${CFLAGS} ${LIBS}
+
+multi_device_client: libiotivity-constrained-client.a $(ROOT_DIR)/apps/multi_device_client_linux.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/multi_device_client_linux.c libiotivity-constrained-client.a -DOC_CLIENT ${CFLAGS}  ${LIBS}
+
+cloud_linux: libiotivity-constrained-client-server.a $(ROOT_DIR)/apps/cloud_linux.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/cloud_linux.c libiotivity-constrained-client-server.a -DOC_CLIENT -DOC_SERVER ${CFLAGS} ${CFLAGS_CLOUD}  ${LIBS}
+
+cloud_tests: libiotivity-constrained-client-server.a $(ROOT_DIR)/apps/cloud_certification_tests.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/cloud_certification_tests.c libiotivity-constrained-client-server.a -DOC_CLIENT -DOC_SERVER ${CFLAGS} ${CFLAGS_CLOUD} ${LIBS}
+
+${OBT}: libiotivity-constrained-client.a $(ROOT_DIR)/onboarding_tool/obtmain.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../onboarding_tool/obtmain.c libiotivity-constrained-client.a -DOC_CLIENT ${CFLAGS}  ${LIBS}
+
+server_multithread_linux: libiotivity-constrained-server.a $(ROOT_DIR)/apps/server_multithread_linux.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/server_multithread_linux.c libiotivity-constrained-server.a -DOC_SERVER ${CFLAGS} ${LIBS}
+
+client_multithread_webos: libiotivity-constrained-client.a $(ROOT_DIR)/apps/client_multithread_webos.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/client_multithread_webos.c libiotivity-constrained-client.a -DOC_CLIENT ${CFLAGS}  ${LIBS}
+
+iotivity-constrained-server.pc: iotivity-constrained-server.pc.in
+	$(SED) > $@ < $< \
+		-e 's,@prefix@,$(prefix),' \
+		-e 's,@exec_prefix@,$(exec_prefix),' \
+		-e 's,@libdir@,$(libdir),' \
+		-e 's,@includedir@,$(includedir),' \
+		-e 's,@version@,$(VERSION),' \
+		-e 's,@extra_cflags@,$(EXTRA_CFLAGS),'
+
+iotivity-constrained-client.pc: iotivity-constrained-client.pc.in
+	$(SED) > $@ < $< \
+		-e 's,@prefix@,$(prefix),' \
+		-e 's,@exec_prefix@,$(exec_prefix),' \
+		-e 's,@libdir@,$(libdir),' \
+		-e 's,@includedir@,$(includedir),' \
+		-e 's,@version@,$(VERSION),' \
+		-e 's,@extra_cflags@,$(EXTRA_CFLAGS),'
+
+iotivity-constrained-client-server.pc: iotivity-constrained-client-server.pc.in
+	$(SED) > $@ < $< \
+		-e 's,@prefix@,$(prefix),' \
+		-e 's,@exec_prefix@,$(exec_prefix),' \
+		-e 's,@libdir@,$(libdir),' \
+		-e 's,@includedir@,$(includedir),' \
+		-e 's,@version@,$(VERSION),' \
+		-e 's,@extra_cflags@,$(EXTRA_CFLAGS),'
+
+iotivity-constrained-rd-client.pc: iotivity-constrained-rd-client.pc.in
+	$(SED) > $@ < $< \
+		-e 's,@prefix@,$(prefix),' \
+		-e 's,@exec_prefix@,$(exec_prefix),' \
+		-e 's,@libdir@,$(libdir),' \
+		-e 's,@includedir@,$(includedir),' \
+		-e 's,@version@,$(VERSION),' \
+		-e 's,@extra_cflags@,$(EXTRA_CFLAGS),'
+
+iotivity-constrained-cloud.pc: iotivity-constrained-cloud.pc.in
+	$(SED) > $@ < $< \
+		-e 's,@prefix@,$(prefix),' \
+		-e 's,@exec_prefix@,$(exec_prefix),' \
+		-e 's,@libdir@,$(libdir),' \
+		-e 's,@includedir@,$(includedir),' \
+		-e 's,@version@,$(VERSION),' \
+		-e 's,@extra_cflags@,$(EXTRA_CFLAGS),'
+
+ifneq ($(SECURE),0)
+MBEDTLS_PATCHES ?= $(sort $(wildcard ../../patches/*.patch))
+${MBEDTLS_DIR}/.git:
+	git submodule update --init ${@D}
+
+$(MBEDTLS_PATCH_FILE): ${MBEDTLS_DIR}/.git ${MBEDTLS_PATCHES}
+	if [ -d ${MBEDTLS_DIR} ]; then \
+	cd ${MBEDTLS_DIR} && \
+	git clean -fdx . && \
+	git reset --hard && \
+	cd -; \
+	fi && \
+	git submodule update --init && \
+	cd ${MBEDTLS_DIR} && \
+	for patch in $(MBEDTLS_PATCHES); do patch -r - -s -N -p1 < $${patch} ; done && \
+	echo "Patches applied in $^" > ${@F}
+endif
+
+clean:
+	rm -rf obj $(PC) $(CONSTRAINED_LIBS) $(API_TEST_OBJ_FILES) $(SECURITY_TEST_OBJ_FILES) $(PLATFORM_TEST_OBJ_FILES) $(MESSAGING_TEST_OBJ_FILES) $(UNIT_TESTS) $(STORAGE_TEST_DIR) $(CLOUD_TEST_OBJ_FILES) $(RD_CLIENT_TEST_OBJ_FILES)
+
+cleanall: clean
+	rm -rf ${all} $(SAMPLES) $(TESTS) ${OBT} ${SAMPLES_CREDS} $(MBEDTLS_PATCH_FILE)
+	${MAKE} -C ${GTEST_DIR}/make clean
+
+distclean: cleanall
+
+install: $(SAMPLES) $(PC) $(CONSTRAINED_LIBS)
+	$(INSTALL) -d $(bindir)
+	$(INSTALL) -d $(libdir)
+	$(INSTALL) -d $(includedir)/iotivity-constrained
+	$(INSTALL) -d $(includedir)/iotivity-constrained/port
+	$(INSTALL) -d $(includedir)/iotivity-constrained/util
+	$(INSTALL) -d $(includedir)/iotivity-constrained/util/pt
+	$(INSTALL) -d $(includedir)/iotivity-constrained/messaging/coap
+	$(INSTALL) -d $(includedir)/iotivity-constrained/deps/tinycbor/src/
+	$(INSTALL) -d $(pkgconfigdir)
+	$(INSTALL) -m 644 $(HEADERS) $(includedir)/iotivity-constrained/
+	$(INSTALL) -m 644 $(HEADERS_PORT) $(includedir)/iotivity-constrained/port
+	$(INSTALL) -m 644 $(HEADERS_UTIL) $(includedir)/iotivity-constrained/util
+	$(INSTALL) -m 644 $(HEADERS_UTIL_PT) $(includedir)/iotivity-constrained/util/pt
+	$(INSTALL) -m 644 $(HEADERS_COAP) $(includedir)/iotivity-constrained/messaging/coap
+	$(INSTALL) -m 644 $(HEADERS_TINYCBOR) $(includedir)/iotivity-constrained/deps/tinycbor/src
+	$(INSTALL) -m 644 $(PC) $(pkgconfigdir)
+	$(INSTALL) -m 644 $(CONSTRAINED_LIBS) $(libdir)
+# Installing the samples
+	$(INSTALL) -d ${install_bin_dir}
+	$(INSTALL) $(SAMPLES) ${install_bin_dir}
+
+############# TESTS ##########################
+TESTS = \
+	tests/client_init_linux_test \
+	tests/server_init_linux_test \
+	tests/client_get_linux_test
+
+tests/client_init_linux_test: libiotivity-constrained-client.a
+	@mkdir -p $(@D)
+	$(CC) -o $@ ../../tests/client_init_linux.c \
+		libiotivity-constrained-client.a \
+		-DOC_CLIENT $(CFLAGS) $(LIBS)
+
+tests/server_init_linux_test: libiotivity-constrained-server.a
+	@mkdir -p $(@D)
+	$(CC) -o $@ ../../tests/server_init_linux.c \
+		libiotivity-constrained-server.a \
+		-DOC_SERVER $(CFLAGS) $(LIBS)
+
+tests/client_get_linux_test: libiotivity-constrained-client-server.a
+	@mkdir -p $(@D)
+	$(CC) -o $@ ../../tests/client_get_linux.c \
+		libiotivity-constrained-client-server.a -DOC_SERVER \
+		-DOC_CLIENT $(CFLAGS) $(LIBS)
+
+check: $(TESTS)
+	$(Q)$(PYTHON) $(CHECK_SCRIPT) --tests="$(TESTS)"
diff --git a/port/webos/abort.c b/port/webos/abort.c
new file mode 100644
index 00000000..19be6ea7
--- /dev/null
+++ b/port/webos/abort.c
@@ -0,0 +1,30 @@
+/*
+// Copyright (c) 2017 Intel Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#include "port/oc_assert.h"
+#include <stdlib.h>
+
+void
+abort_impl(void)
+{
+  abort();
+}
+
+void
+exit_impl(int status)
+{
+  exit(status);
+}
diff --git a/port/webos/acg_configuration/client_multithread_webos.api.json b/port/webos/acg_configuration/client_multithread_webos.api.json
new file mode 100755
index 00000000..2c63c085
--- /dev/null
+++ b/port/webos/acg_configuration/client_multithread_webos.api.json
@@ -0,0 +1,2 @@
+{
+}
diff --git a/port/webos/acg_configuration/client_multithread_webos.manifest.json b/port/webos/acg_configuration/client_multithread_webos.manifest.json
new file mode 100755
index 00000000..a2fc7c61
--- /dev/null
+++ b/port/webos/acg_configuration/client_multithread_webos.manifest.json
@@ -0,0 +1,16 @@
+{
+    "serviceFiles": [
+        "/usr/share/luna-service2/services.d/client_multithread_webos.service"
+    ],
+    "roleFiles": [
+        "/usr/share/luna-service2/roles.d/client_multithread_webos.role.json"
+    ],
+    "apiPermissionFiles": [
+        "/usr/share/luna-service2/api-permissions.d/client_multithread_webos.api.json"
+    ],
+    "version": "1.0.0",
+    "id": "client_multithread_webos",
+    "clientPermissionFiles": [
+        "/usr/share/luna-service2/client-permissions.d/client_multithread_webos.perm.json"
+    ]
+}
diff --git a/port/webos/acg_configuration/client_multithread_webos.perm.json b/port/webos/acg_configuration/client_multithread_webos.perm.json
new file mode 100755
index 00000000..804d9f04
--- /dev/null
+++ b/port/webos/acg_configuration/client_multithread_webos.perm.json
@@ -0,0 +1,5 @@
+{
+    "org.ocf.webossample.client_multithread_webos*": [
+        "networking.internal"
+    ]
+}
diff --git a/port/webos/acg_configuration/client_multithread_webos.role.json b/port/webos/acg_configuration/client_multithread_webos.role.json
new file mode 100755
index 00000000..deb6d6f9
--- /dev/null
+++ b/port/webos/acg_configuration/client_multithread_webos.role.json
@@ -0,0 +1,11 @@
+{
+    "exeName":"/usr/palm/services/org.ocf.webossample.client_multithread_webos/client_multithread_webos",
+    "type":"regular",
+    "allowedNames":["org.ocf.webossample.client_multithread_webos*"],
+    "permissions": [
+        {
+            "service":"org.ocf.webossample.client_multithread_webos*",
+            "outbound":["com.webos.service.connectionmanager"]
+        }
+    ]
+}
diff --git a/port/webos/acg_configuration/client_multithread_webos.service b/port/webos/acg_configuration/client_multithread_webos.service
new file mode 100755
index 00000000..30a3c6fa
--- /dev/null
+++ b/port/webos/acg_configuration/client_multithread_webos.service
@@ -0,0 +1,24 @@
+#******************************************************************
+#
+# Copyright (c) 2018 LG Electronics, Inc.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+[D-BUS Service]
+Name=org.ocf.webossample.client_multithread_webos*
+Exec=/usr/palm/services/org.ocf.webossample.client_multithread_webos/client_multithread_webos
+Type=static
diff --git a/port/webos/acg_configuration/onboarding_tool.api.json b/port/webos/acg_configuration/onboarding_tool.api.json
new file mode 100755
index 00000000..2c63c085
--- /dev/null
+++ b/port/webos/acg_configuration/onboarding_tool.api.json
@@ -0,0 +1,2 @@
+{
+}
diff --git a/port/webos/acg_configuration/onboarding_tool.manifest.json b/port/webos/acg_configuration/onboarding_tool.manifest.json
new file mode 100755
index 00000000..26622a74
--- /dev/null
+++ b/port/webos/acg_configuration/onboarding_tool.manifest.json
@@ -0,0 +1,16 @@
+{
+    "serviceFiles": [
+        "/usr/share/luna-service2/services.d/onboarding_tool.service"
+    ],
+    "roleFiles": [
+        "/usr/share/luna-service2/roles.d/onboarding_tool.role.json"
+    ],
+    "apiPermissionFiles": [
+        "/usr/share/luna-service2/api-permissions.d/onboarding_tool.api.json"
+    ],
+    "version": "1.0.0",
+    "id": "onboarding_tool",
+    "clientPermissionFiles": [
+        "/usr/share/luna-service2/client-permissions.d/onboarding_tool.perm.json"
+    ]
+}
diff --git a/port/webos/acg_configuration/onboarding_tool.perm.json b/port/webos/acg_configuration/onboarding_tool.perm.json
new file mode 100755
index 00000000..5d77bafa
--- /dev/null
+++ b/port/webos/acg_configuration/onboarding_tool.perm.json
@@ -0,0 +1,5 @@
+{
+    "org.ocf.webossample.onboarding_tool*": [
+        "networking.internal"
+    ]
+}
diff --git a/port/webos/acg_configuration/onboarding_tool.role.json b/port/webos/acg_configuration/onboarding_tool.role.json
new file mode 100755
index 00000000..3b38497c
--- /dev/null
+++ b/port/webos/acg_configuration/onboarding_tool.role.json
@@ -0,0 +1,11 @@
+{
+    "exeName":"/usr/sbin/onboarding_tool",
+    "type":"regular",
+    "allowedNames":["org.ocf.webossample.onboarding_tool*"],
+    "permissions": [
+        {
+            "service":"org.ocf.webossample.onboarding_tool*",
+            "outbound":["com.webos.service.connectionmanager"]
+        }
+    ]
+}
diff --git a/port/webos/acg_configuration/onboarding_tool.service b/port/webos/acg_configuration/onboarding_tool.service
new file mode 100755
index 00000000..d1f3332f
--- /dev/null
+++ b/port/webos/acg_configuration/onboarding_tool.service
@@ -0,0 +1,24 @@
+#******************************************************************
+#
+# Copyright (c) 2018 LG Electronics, Inc.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+[D-BUS Service]
+Name=org.ocf.webossample.onboarding_tool*
+Exec=/usr/sbin/onboarding_tool
+Type=static
diff --git a/port/webos/acg_configuration/simpleserver_webos.api.json b/port/webos/acg_configuration/simpleserver_webos.api.json
new file mode 100755
index 00000000..2c63c085
--- /dev/null
+++ b/port/webos/acg_configuration/simpleserver_webos.api.json
@@ -0,0 +1,2 @@
+{
+}
diff --git a/port/webos/acg_configuration/simpleserver_webos.manifest.json b/port/webos/acg_configuration/simpleserver_webos.manifest.json
new file mode 100755
index 00000000..51697c38
--- /dev/null
+++ b/port/webos/acg_configuration/simpleserver_webos.manifest.json
@@ -0,0 +1,16 @@
+{
+    "serviceFiles": [
+        "/usr/share/luna-service2/services.d/simpleserver_webos.service"
+    ],
+    "roleFiles": [
+        "/usr/share/luna-service2/roles.d/simpleserver_webos.role.json"
+    ],
+    "apiPermissionFiles": [
+        "/usr/share/luna-service2/api-permissions.d/simpleserver_webos.api.json"
+    ],
+    "version": "1.0.0",
+    "id": "simpleserver_webos",
+    "clientPermissionFiles": [
+        "/usr/share/luna-service2/client-permissions.d/simpleserver_webos.perm.json"
+    ]
+}
diff --git a/port/webos/acg_configuration/simpleserver_webos.perm.json b/port/webos/acg_configuration/simpleserver_webos.perm.json
new file mode 100755
index 00000000..62cf8638
--- /dev/null
+++ b/port/webos/acg_configuration/simpleserver_webos.perm.json
@@ -0,0 +1,5 @@
+{
+    "org.ocf.webossample.simpleserver_webos*": [
+        "networking.internal"
+    ]
+}
diff --git a/port/webos/acg_configuration/simpleserver_webos.role.json b/port/webos/acg_configuration/simpleserver_webos.role.json
new file mode 100755
index 00000000..d1f7ef47
--- /dev/null
+++ b/port/webos/acg_configuration/simpleserver_webos.role.json
@@ -0,0 +1,11 @@
+{
+    "exeName":"/usr/palm/services/org.ocf.webossample.simpleserver_webos/simpleserver_webos",
+    "type":"regular",
+    "allowedNames":["org.ocf.webossample.simpleserver_webos*"],
+    "permissions": [
+        {
+            "service":"org.ocf.webossample.simpleserver_webos*",
+            "outbound":["com.webos.service.connectionmanager"]
+        }
+    ]
+}
diff --git a/port/webos/acg_configuration/simpleserver_webos.service b/port/webos/acg_configuration/simpleserver_webos.service
new file mode 100755
index 00000000..ac788b82
--- /dev/null
+++ b/port/webos/acg_configuration/simpleserver_webos.service
@@ -0,0 +1,24 @@
+#******************************************************************
+#
+# Copyright (c) 2018 LG Electronics, Inc.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+[D-BUS Service]
+Name=org.ocf.webossample.simpleserver_webos*
+Exec=/usr/palm/services/org.ocf.webossample.simpleserver_webos/simpleserver_webos
+Type=static
diff --git a/port/webos/clock.c b/port/webos/clock.c
new file mode 100644
index 00000000..3f903c78
--- /dev/null
+++ b/port/webos/clock.c
@@ -0,0 +1,54 @@
+/*
+// Copyright (c) 2016 Intel Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#include "port/oc_clock.h"
+#include "port/oc_log.h"
+#include <math.h>
+#include <time.h>
+#include <unistd.h>
+
+void
+oc_clock_init(void)
+{
+}
+
+oc_clock_time_t
+oc_clock_time(void)
+{
+  oc_clock_time_t time = 0;
+  struct timespec t;
+  if (clock_gettime(CLOCK_REALTIME, &t) != -1) {
+    time = (oc_clock_time_t)t.tv_sec * OC_CLOCK_SECOND +
+           (oc_clock_time_t)ceil(t.tv_nsec / (1.e09 / OC_CLOCK_SECOND));
+  }
+  return time;
+}
+
+unsigned long
+oc_clock_seconds(void)
+{
+  struct timespec t;
+  if (clock_gettime(CLOCK_REALTIME, &t) != -1) {
+    return t.tv_sec;
+  }
+  return 0;
+}
+
+void
+oc_clock_wait(oc_clock_time_t t)
+{
+  usleep(t * 1.e03);
+}
diff --git a/port/webos/iotivity-constrained-client-server.pc.in b/port/webos/iotivity-constrained-client-server.pc.in
new file mode 100644
index 00000000..f69f24ce
--- /dev/null
+++ b/port/webos/iotivity-constrained-client-server.pc.in
@@ -0,0 +1,25 @@
+# Copyright (c) 2017 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: iotivity-constrained-client-server
+Description: Iotivity constrained client and server library
+Version: @version@
+Libs.private: -lm -pthread
+Cflags: -I${includedir}/iotivity-constrained -DOC_CLIENT -DOC_SERVER @extra_cflags@
+Libs: -L${libdir} -liotivity-constrained-client-server
diff --git a/port/webos/iotivity-constrained-client.pc.in b/port/webos/iotivity-constrained-client.pc.in
new file mode 100644
index 00000000..17f31c9b
--- /dev/null
+++ b/port/webos/iotivity-constrained-client.pc.in
@@ -0,0 +1,25 @@
+# Copyright (c) 2017 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: iotivity-constrained-client
+Description: Iotivity constrained client library
+Version: @version@
+Libs.private: -lm -pthread
+Cflags: -I${includedir}/iotivity-constrained -DOC_CLIENT @extra_cflags@
+Libs: -L${libdir} -liotivity-constrained-client
diff --git a/port/webos/iotivity-constrained-server.pc.in b/port/webos/iotivity-constrained-server.pc.in
new file mode 100644
index 00000000..04119807
--- /dev/null
+++ b/port/webos/iotivity-constrained-server.pc.in
@@ -0,0 +1,25 @@
+# Copyright (c) 2017 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: iotivity-constrained-server
+Description: Iotivity constrained server library
+Version: @version@
+Libs.private: -lm -pthread
+Cflags: -I${includedir}/iotivity-constrained -DOC_SERVER @extra_cflags@
+Libs: -L${libdir} -liotivity-constrained-server
diff --git a/port/webos/ipadapter.c b/port/webos/ipadapter.c
new file mode 100644
index 00000000..d1bb24ce
--- /dev/null
+++ b/port/webos/ipadapter.c
@@ -0,0 +1,1515 @@
+/*
+// Copyright (c) 2018 Intel Corporation
+// Copyright (c) 2019 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#define _GNU_SOURCE
+#include "ipcontext.h"
+#ifdef OC_TCP
+#include "tcpadapter.h"
+#endif
+#include "oc_buffer.h"
+#include "oc_core_res.h"
+#include "oc_endpoint.h"
+#include "oc_network_monitor.h"
+#include "port/oc_assert.h"
+#include "port/oc_connectivity.h"
+#include <arpa/inet.h>
+#include <assert.h>
+#include <errno.h>
+#include <ifaddrs.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+#include <net/if.h>
+#include <netdb.h>
+#include <signal.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/select.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include "luna_adapter_util.h"
+
+/* Some outdated toolchains do not define IFA_FLAGS.
+   Note: Requires Linux kernel 3.14 or later. */
+#ifndef IFA_FLAGS
+#define IFA_FLAGS (IFA_MULTICAST+1)
+#endif
+
+#define OCF_PORT_UNSECURED (5683)
+static const uint8_t ALL_OCF_NODES_LL[] = {
+  0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01, 0x58
+};
+static const uint8_t ALL_OCF_NODES_RL[] = {
+  0xff, 0x03, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01, 0x58
+};
+static const uint8_t ALL_OCF_NODES_SL[] = {
+  0xff, 0x05, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01, 0x58
+};
+#define ALL_COAP_NODES_V4 0xe00001bb
+
+static pthread_mutex_t mutex;
+struct sockaddr_nl ifchange_nl;
+int ifchange_sock;
+bool ifchange_initialized;
+
+OC_LIST(ip_contexts);
+OC_MEMB(ip_context_s, ip_context_t, OC_MAX_NUM_DEVICES);
+
+OC_MEMB(device_eps, oc_endpoint_t, 8 * OC_MAX_NUM_DEVICES); // fix
+
+#ifdef OC_SESSION_EVENTS
+OC_LIST(oc_session_event_cb_list);
+OC_MEMB(oc_session_event_cb_s, oc_session_event_cb_t, OC_MAX_SESSION_EVENT_CBS);
+
+static void
+remove_all_session_event_cbs(void)
+{
+  oc_session_event_cb_t *cb_item = oc_list_head(oc_session_event_cb_list),
+                        *next;
+  while (cb_item != NULL) {
+    next = cb_item->next;
+    oc_list_remove(oc_session_event_cb_list, cb_item);
+    oc_memb_free(&oc_session_event_cb_s, cb_item);
+    cb_item = next;
+  }
+}
+
+#endif /* OC_SESSION_EVENTS */
+
+void
+oc_network_event_handler_mutex_init(void)
+{
+  if (pthread_mutex_init(&mutex, NULL) != 0) {
+    oc_abort("error initializing network event handler mutex");
+  }
+}
+
+void
+oc_network_event_handler_mutex_lock(void)
+{
+  pthread_mutex_lock(&mutex);
+}
+
+void
+oc_network_event_handler_mutex_unlock(void)
+{
+  pthread_mutex_unlock(&mutex);
+}
+
+void
+oc_network_event_handler_mutex_destroy(void)
+{
+  ifchange_initialized = false;
+  close(ifchange_sock);
+#ifdef OC_NETWORK_MONITOR
+  terminateLS();
+#endif /* OC_NETWORK_MONITOR */
+#ifdef OC_SESSION_EVENTS
+  remove_all_session_event_cbs();
+#endif /* OC_SESSION_EVENTS */
+  pthread_mutex_destroy(&mutex);
+}
+
+static ip_context_t *
+get_ip_context_for_device(size_t device)
+{
+  ip_context_t *dev = oc_list_head(ip_contexts);
+  while (dev != NULL && dev->device != device) {
+    dev = dev->next;
+  }
+  if (!dev) {
+    return NULL;
+  }
+  return dev;
+}
+
+#ifdef OC_IPV4
+static int add_mcast_sock_to_ipv4_mcast_group(int mcast_sock,
+                                              const struct in_addr *local,
+                                              int interface_index) {
+  struct ip_mreqn mreq;
+
+  memset(&mreq, 0, sizeof(mreq));
+  mreq.imr_multiaddr.s_addr = htonl(ALL_COAP_NODES_V4);
+  mreq.imr_ifindex = interface_index;
+  memcpy(&mreq.imr_address, local, sizeof(struct in_addr));
+
+  (void)setsockopt(mcast_sock, IPPROTO_IP, IP_DROP_MEMBERSHIP, &mreq,
+                   sizeof(mreq));
+
+  if (setsockopt(mcast_sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq,
+                 sizeof(mreq)) == -1) {
+    OC_ERR("joining IPv4 multicast group %d", errno);
+    return -1;
+  }
+
+  return 0;
+}
+#endif /* OC_IPV4 */
+
+static int add_mcast_sock_to_ipv6_mcast_group(int mcast_sock,
+                                              int interface_index) {
+  struct ipv6_mreq mreq;
+
+  /* Link-local scope */
+  memset(&mreq, 0, sizeof(mreq));
+  memcpy(mreq.ipv6mr_multiaddr.s6_addr, ALL_OCF_NODES_LL, 16);
+  mreq.ipv6mr_interface = interface_index;
+
+  (void)setsockopt(mcast_sock, IPPROTO_IPV6, IPV6_DROP_MEMBERSHIP, &mreq,
+                   sizeof(mreq));
+
+  if (setsockopt(mcast_sock, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, &mreq,
+                 sizeof(mreq)) == -1) {
+    OC_ERR("joining link-local IPv6 multicast group %d", errno);
+    return -1;
+  }
+
+  /* Realm-local scope */
+  memset(&mreq, 0, sizeof(mreq));
+  memcpy(mreq.ipv6mr_multiaddr.s6_addr, ALL_OCF_NODES_RL, 16);
+  mreq.ipv6mr_interface = interface_index;
+
+  (void)setsockopt(mcast_sock, IPPROTO_IPV6, IPV6_DROP_MEMBERSHIP, &mreq,
+                   sizeof(mreq));
+
+  if (setsockopt(mcast_sock, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, &mreq,
+                 sizeof(mreq)) == -1) {
+    OC_ERR("joining realm-local IPv6 multicast group %d", errno);
+    return -1;
+  }
+
+  /* Site-local scope */
+  memset(&mreq, 0, sizeof(mreq));
+  memcpy(mreq.ipv6mr_multiaddr.s6_addr, ALL_OCF_NODES_SL, 16);
+  mreq.ipv6mr_interface = interface_index;
+
+  (void)setsockopt(mcast_sock, IPPROTO_IPV6, IPV6_DROP_MEMBERSHIP, &mreq,
+                   sizeof(mreq));
+
+  if (setsockopt(mcast_sock, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, &mreq,
+                 sizeof(mreq)) == -1) {
+    OC_ERR("joining site-local IPv6 multicast group %d", errno);
+    return -1;
+  }
+
+  return 0;
+}
+
+static int configure_mcast_socket(int mcast_sock, int sa_family) {
+  int ret = 0;
+  struct ifaddrs *ifs = NULL, *interface = NULL;
+  if (getifaddrs(&ifs) < 0) {
+    OC_ERR("querying interface addrs");
+    return -1;
+  }
+  for (interface = ifs; interface != NULL; interface = interface->ifa_next) {
+    /* Ignore interfaces that are down and the loopback interface */
+    if (!(interface->ifa_flags & IFF_UP) ||
+        interface->ifa_flags & IFF_LOOPBACK) {
+      continue;
+    }
+    /* Ignore interfaces not belonging to the address family under consideration
+     */
+    if (interface->ifa_addr && interface->ifa_addr->sa_family != sa_family) {
+      continue;
+    }
+    /* Obtain interface index for this address */
+    int if_index = if_nametoindex(interface->ifa_name);
+    /* Accordingly handle IPv6/IPv4 addresses */
+    if (sa_family == AF_INET6) {
+      struct sockaddr_in6 *a = (struct sockaddr_in6 *)interface->ifa_addr;
+      if (a && IN6_IS_ADDR_LINKLOCAL(&a->sin6_addr)) {
+        ret += add_mcast_sock_to_ipv6_mcast_group(mcast_sock, if_index);
+      }
+    }
+#ifdef OC_IPV4
+    else if (sa_family == AF_INET) {
+      struct sockaddr_in *a = (struct sockaddr_in *)interface->ifa_addr;
+      if (a)
+        ret += add_mcast_sock_to_ipv4_mcast_group(mcast_sock, &a->sin_addr,
+                                                if_index);
+    }
+#endif /* OC_IPV4 */
+  }
+  freeifaddrs(ifs);
+  return ret;
+}
+
+static void
+get_interface_addresses(ip_context_t *dev, unsigned char family, uint16_t port,
+                        bool secure, bool tcp)
+{
+  struct
+  {
+    struct nlmsghdr nlhdr;
+    struct ifaddrmsg addrmsg;
+  } request;
+  struct nlmsghdr *response;
+
+  memset(&request, 0, sizeof(request));
+  request.nlhdr.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifaddrmsg));
+  request.nlhdr.nlmsg_flags = NLM_F_REQUEST | NLM_F_ROOT;
+  request.nlhdr.nlmsg_type = RTM_GETADDR;
+  request.addrmsg.ifa_family = family;
+
+  int nl_sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+  if (nl_sock < 0) {
+    return;
+  }
+
+  if (send(nl_sock, &request, request.nlhdr.nlmsg_len, 0) < 0) {
+    close(nl_sock);
+    return;
+  }
+
+  fd_set rfds;
+  FD_ZERO(&rfds);
+  FD_SET(nl_sock, &rfds);
+
+  if (select(FD_SETSIZE, &rfds, NULL, NULL, NULL) < 0) {
+    close(nl_sock);
+    return;
+  }
+
+  int prev_interface_index = -1;
+  bool done = false;
+  while (!done) {
+    int guess = 512, response_len;
+    do {
+      guess <<= 1;
+      uint8_t dummy[guess];
+      response_len = recv(nl_sock, dummy, guess, MSG_PEEK);
+      if (response_len < 0) {
+        close(nl_sock);
+        return;
+      }
+    } while (response_len == guess);
+
+    uint8_t buffer[response_len];
+    response_len = recv(nl_sock, buffer, response_len, 0);
+    if (response_len < 0) {
+      close(nl_sock);
+      return;
+    }
+
+    response = (struct nlmsghdr *)buffer;
+    if (response->nlmsg_type == NLMSG_ERROR) {
+      close(nl_sock);
+      return;
+    }
+
+    while (NLMSG_OK(response, response_len)) {
+      if (response->nlmsg_type == NLMSG_DONE) {
+        done = true;
+        break;
+      }
+      oc_endpoint_t ep;
+      memset(&ep, 0, sizeof(oc_endpoint_t));
+      bool include = false;
+      struct ifaddrmsg *addrmsg = (struct ifaddrmsg *)NLMSG_DATA(response);
+      if (addrmsg->ifa_scope < RT_SCOPE_HOST) {
+        if ((int)addrmsg->ifa_index == prev_interface_index) {
+          goto next_ifaddr;
+        }
+        ep.interface_index = addrmsg->ifa_index;
+        include = true;
+        struct rtattr *attr = (struct rtattr *)IFA_RTA(addrmsg);
+        int att_len = IFA_PAYLOAD(response);
+        while (RTA_OK(attr, att_len)) {
+          if (attr->rta_type == IFA_ADDRESS) {
+#ifdef OC_IPV4
+            if (family == AF_INET) {
+              memcpy(ep.addr.ipv4.address, RTA_DATA(attr), 4);
+              ep.flags = IPV4;
+            } else
+#endif /* OC_IPV4 */
+              if (family == AF_INET6) {
+              memcpy(ep.addr.ipv6.address, RTA_DATA(attr), 16);
+              ep.flags = IPV6;
+            }
+          } else if (attr->rta_type == IFA_FLAGS) {
+            if (*(uint32_t *)(RTA_DATA(attr)) & IFA_F_TEMPORARY) {
+              include = false;
+            }
+          }
+          attr = RTA_NEXT(attr, att_len);
+        }
+      }
+      if (include) {
+        prev_interface_index = addrmsg->ifa_index;
+        if (addrmsg->ifa_scope == RT_SCOPE_LINK && family == AF_INET6) {
+          ep.addr.ipv6.scope = addrmsg->ifa_index;
+        }
+        if (secure) {
+          ep.flags |= SECURED;
+        }
+#ifdef OC_IPV4
+        if (family == AF_INET) {
+          ep.addr.ipv4.port = port;
+        } else
+#endif /* OC_IPV4 */
+          if (family == AF_INET6) {
+          ep.addr.ipv6.port = port;
+        }
+#ifdef OC_TCP
+        if (tcp) {
+          ep.flags |= TCP;
+        }
+#else
+        (void)tcp;
+#endif /* OC_TCP */
+        oc_endpoint_t *new_ep = oc_memb_alloc(&device_eps);
+        if (!new_ep) {
+          close(nl_sock);
+          return;
+        }
+        memcpy(new_ep, &ep, sizeof(oc_endpoint_t));
+        oc_list_add(dev->eps, new_ep);
+      }
+
+    next_ifaddr:
+      response = NLMSG_NEXT(response, response_len);
+    }
+  }
+  close(nl_sock);
+}
+
+static void
+free_endpoints_list(ip_context_t *dev)
+{
+  oc_endpoint_t *ep = oc_list_pop(dev->eps);
+
+  while (ep != NULL) {
+    oc_memb_free(&device_eps, ep);
+    ep = oc_list_pop(dev->eps);
+  }
+}
+
+static void
+refresh_endpoints_list(ip_context_t *dev)
+{
+  free_endpoints_list(dev);
+
+  get_interface_addresses(dev, AF_INET6, dev->port, false, false);
+#ifdef OC_SECURITY
+  get_interface_addresses(dev, AF_INET6, dev->dtls_port, true, false);
+#endif /* OC_SECURITY */
+#ifdef OC_IPV4
+  get_interface_addresses(dev, AF_INET, dev->port4, false, false);
+#ifdef OC_SECURITY
+  get_interface_addresses(dev, AF_INET, dev->dtls4_port, true, false);
+#endif /* OC_SECURITY */
+#endif /* OC_IPV4 */
+
+#ifdef OC_TCP
+  get_interface_addresses(dev, AF_INET6, dev->tcp.port, false, true);
+#ifdef OC_SECURITY
+  get_interface_addresses(dev, AF_INET6, dev->tcp.tls_port, true, true);
+#endif /* OC_SECURITY */
+#ifdef OC_IPV4
+  get_interface_addresses(dev, AF_INET, dev->tcp.port4, false, true);
+#ifdef OC_SECURITY
+  get_interface_addresses(dev, AF_INET, dev->tcp.tls4_port, true, true);
+#endif /* OC_SECURITY */
+#endif /* OC_IPV4 */
+#endif /* OC_TCP */
+}
+
+oc_endpoint_t *
+oc_connectivity_get_endpoints(size_t device)
+{
+  ip_context_t *dev = get_ip_context_for_device(device);
+
+  if (!dev) {
+    return NULL;
+  }
+
+  if (oc_list_length(dev->eps) == 0) {
+    oc_network_event_handler_mutex_lock();
+    refresh_endpoints_list(dev);
+    oc_network_event_handler_mutex_unlock();
+  }
+
+  return oc_list_head(dev->eps);
+}
+
+/* Called after network interface up/down events.
+ * This function reconfigures IPv6/v4 multicast sockets for
+ * all logical devices.
+ */
+static int process_interface_change_event(void) {
+  int ret = 0, i, num_devices = oc_core_get_num_devices();
+  struct nlmsghdr *response = NULL;
+
+  int guess = 512, response_len;
+  do {
+    guess <<= 1;
+    uint8_t dummy[guess];
+    response_len = recv(ifchange_sock, dummy, guess, MSG_PEEK);
+    if (response_len < 0) {
+      OC_ERR("reading payload size from netlink interface");
+      return -1;
+    }
+  } while (response_len == guess);
+
+  uint8_t buffer[response_len];
+  response_len = recv(ifchange_sock, buffer, response_len, 0);
+  if (response_len < 0) {
+    OC_ERR("reading payload from netlink interface");
+    return -1;
+  }
+
+  response = (struct nlmsghdr *)buffer;
+  if (response->nlmsg_type == NLMSG_ERROR) {
+    OC_ERR("caught NLMSG_ERROR in payload from netlink interface");
+    return -1;
+  }
+
+  bool if_state_changed = false;
+
+  while (NLMSG_OK(response, response_len)) {
+    if (response->nlmsg_type == RTM_NEWADDR) {
+      struct ifaddrmsg *ifa = (struct ifaddrmsg *)NLMSG_DATA(response);
+      if (ifa) {
+        struct rtattr *attr = (struct rtattr *)IFA_RTA(ifa);
+        int att_len = IFA_PAYLOAD(response);
+        while (RTA_OK(attr, att_len)) {
+          if (attr->rta_type == IFA_ADDRESS) {
+#ifdef OC_IPV4
+            if (ifa->ifa_family == AF_INET) {
+              for (i = 0; i < num_devices; i++) {
+                ip_context_t *dev = get_ip_context_for_device(i);
+                ret += add_mcast_sock_to_ipv4_mcast_group(
+                    dev->mcast4_sock, RTA_DATA(attr), ifa->ifa_index);
+              }
+            } else
+#endif /* OC_IPV4 */
+                if (ifa->ifa_family == AF_INET6 &&
+                    ifa->ifa_scope == RT_SCOPE_LINK) {
+              for (i = 0; i < num_devices; i++) {
+                ip_context_t *dev = get_ip_context_for_device(i);
+                ret += add_mcast_sock_to_ipv6_mcast_group(dev->mcast_sock,
+                                                          ifa->ifa_index);
+              }
+            }
+          }
+          attr = RTA_NEXT(attr, att_len);
+        }
+      }
+      if_state_changed = true;
+    } else if (response->nlmsg_type == RTM_DELADDR) {
+      struct ifaddrmsg *ifa = (struct ifaddrmsg *)NLMSG_DATA(response);
+      if (ifa) {
+      }
+      if_state_changed = true;
+    }
+    response = NLMSG_NEXT(response, response_len);
+  }
+
+  if (if_state_changed) {
+    for (i = 0; i < num_devices; i++) {
+      ip_context_t *dev = get_ip_context_for_device(i);
+      oc_network_event_handler_mutex_lock();
+      refresh_endpoints_list(dev);
+      oc_network_event_handler_mutex_unlock();
+    }
+  }
+
+  return ret;
+}
+
+static int
+recv_msg(int sock, uint8_t *recv_buf, int recv_buf_size,
+         oc_endpoint_t *endpoint, bool multicast)
+{
+  struct sockaddr_storage client;
+  struct iovec iovec[1];
+  struct msghdr msg;
+  char msg_control[CMSG_LEN(sizeof(struct sockaddr_storage))];
+
+  iovec[0].iov_base = recv_buf;
+  iovec[0].iov_len = (size_t)recv_buf_size;
+
+  msg.msg_name = &client;
+  msg.msg_namelen = sizeof(client);
+
+  msg.msg_iov = iovec;
+  msg.msg_iovlen = 1;
+
+  msg.msg_control = msg_control;
+  msg.msg_controllen = sizeof(msg_control);
+
+  msg.msg_flags = 0;
+
+  int ret = recvmsg(sock, &msg, 0);
+
+  if (ret < 0 || msg.msg_flags & MSG_TRUNC || msg.msg_flags & MSG_CTRUNC) {
+    OC_ERR("recvmsg returned with an error: %d", errno);
+    return -1;
+  }
+
+  struct cmsghdr *cmsg;
+  for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != 0; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
+    if (cmsg->cmsg_level == IPPROTO_IPV6 && cmsg->cmsg_type == IPV6_PKTINFO) {
+      if (msg.msg_namelen != sizeof(struct sockaddr_in6)) {
+        OC_ERR("anciliary data contains invalid source address");
+        return -1;
+      }
+      /* Set source address of packet in endpoint structure */
+      struct sockaddr_in6 *c6 = (struct sockaddr_in6 *)&client;
+      memcpy(endpoint->addr.ipv6.address, c6->sin6_addr.s6_addr,
+             sizeof(c6->sin6_addr.s6_addr));
+      endpoint->addr.ipv6.scope = c6->sin6_scope_id;
+      endpoint->addr.ipv6.port = ntohs(c6->sin6_port);
+
+      /* Set receiving network interface index */
+      struct in6_pktinfo *pktinfo = (struct in6_pktinfo *)CMSG_DATA(cmsg);
+      endpoint->interface_index = pktinfo->ipi6_ifindex;
+
+      /* For a unicast receiving socket, extract the destination address
+       * of the UDP packet into the endpoint's addr_local attribute.
+       * This would be used to set the source address of a response that
+       * results from this message.
+       */
+      if (!multicast) {
+        memcpy(endpoint->addr_local.ipv6.address, pktinfo->ipi6_addr.s6_addr,
+               16);
+      } else {
+        /* For a multicast receiving socket, check the incoming interface
+               * index and save that interface's highest scoped address in the
+               * endpoint's addr_local attribute. This would be used as the
+         * source
+               * address of a multicast response.
+               */
+        oc_endpoint_t *dst = oc_connectivity_get_endpoints(endpoint->device);
+        while (dst != NULL &&
+               (dst->interface_index != endpoint->interface_index ||
+               !(dst->flags & IPV6))) {
+          dst = dst->next;
+        }
+        if (dst == NULL) {
+          return -1;
+        }
+        memcpy(endpoint->addr_local.ipv6.address, dst->addr.ipv6.address, 16);
+      }
+      break;
+    }
+#ifdef OC_IPV4
+    else if (cmsg->cmsg_level == SOL_IP && cmsg->cmsg_type == IP_PKTINFO) {
+      if (msg.msg_namelen != sizeof(struct sockaddr_in)) {
+        OC_ERR("anciliary data contains invalid source address");
+        return -1;
+      }
+      struct in_pktinfo *pktinfo = (struct in_pktinfo *)CMSG_DATA(cmsg);
+      struct sockaddr_in *c4 = (struct sockaddr_in *)&client;
+      memcpy(endpoint->addr.ipv4.address, &c4->sin_addr.s_addr,
+             sizeof(c4->sin_addr.s_addr));
+      endpoint->addr.ipv4.port = ntohs(c4->sin_port);
+      endpoint->interface_index = pktinfo->ipi_ifindex;
+      if (!multicast) {
+        memcpy(endpoint->addr_local.ipv4.address, &pktinfo->ipi_addr.s_addr, 4);
+      } else {
+        oc_endpoint_t *dst = oc_connectivity_get_endpoints(endpoint->device);
+        while (dst != NULL &&
+               (dst->interface_index != endpoint->interface_index ||
+               !(dst->flags & IPV4))) {
+          dst = dst->next;
+        }
+        if (dst == NULL) {
+          return -1;
+        }
+        memcpy(endpoint->addr_local.ipv4.address, dst->addr.ipv4.address, 4);
+      }
+      break;
+    }
+#endif /* OC_IPV4 */
+  }
+
+  return ret;
+}
+
+static void
+oc_udp_add_socks_to_fd_set(ip_context_t *dev)
+{
+  FD_SET(dev->server_sock, &dev->rfds);
+  FD_SET(dev->mcast_sock, &dev->rfds);
+#ifdef OC_SECURITY
+  FD_SET(dev->secure_sock, &dev->rfds);
+#endif /* OC_SECURITY */
+
+#ifdef OC_IPV4
+  FD_SET(dev->server4_sock, &dev->rfds);
+  FD_SET(dev->mcast4_sock, &dev->rfds);
+#ifdef OC_SECURITY
+  FD_SET(dev->secure4_sock, &dev->rfds);
+#endif /* OC_SECURITY */
+#endif /* OC_IPV4 */
+}
+
+static adapter_receive_state_t
+oc_udp_receive_message(ip_context_t *dev, fd_set *fds, oc_message_t *message)
+{
+  if (FD_ISSET(dev->server_sock, fds)) {
+    int count = recv_msg(dev->server_sock, message->data, OC_PDU_SIZE,
+                         &message->endpoint, false);
+    if (count < 0) {
+      return ADAPTER_STATUS_ERROR;
+    }
+    message->length = (size_t)count;
+    message->endpoint.flags = IPV6;
+    FD_CLR(dev->server_sock, fds);
+    return ADAPTER_STATUS_RECEIVE;
+  }
+
+  if (FD_ISSET(dev->mcast_sock, fds)) {
+    int count = recv_msg(dev->mcast_sock, message->data, OC_PDU_SIZE,
+                         &message->endpoint, true);
+    if (count < 0) {
+      return ADAPTER_STATUS_ERROR;
+    }
+    message->length = (size_t)count;
+    message->endpoint.flags = IPV6 | MULTICAST;
+    FD_CLR(dev->mcast_sock, fds);
+    return ADAPTER_STATUS_RECEIVE;
+  }
+
+#ifdef OC_IPV4
+  if (FD_ISSET(dev->server4_sock, fds)) {
+    int count = recv_msg(dev->server4_sock, message->data, OC_PDU_SIZE,
+                         &message->endpoint, false);
+    if (count < 0) {
+      return ADAPTER_STATUS_ERROR;
+    }
+    message->length = (size_t)count;
+    message->endpoint.flags = IPV4;
+    FD_CLR(dev->server4_sock, fds);
+    return ADAPTER_STATUS_RECEIVE;
+  }
+
+  if (FD_ISSET(dev->mcast4_sock, fds)) {
+    int count = recv_msg(dev->mcast4_sock, message->data, OC_PDU_SIZE,
+                         &message->endpoint, true);
+    if (count < 0) {
+      return ADAPTER_STATUS_ERROR;
+    }
+    message->length = (size_t)count;
+    message->endpoint.flags = IPV4 | MULTICAST;
+    FD_CLR(dev->mcast4_sock, fds);
+    return ADAPTER_STATUS_RECEIVE;
+  }
+#endif /* OC_IPV4 */
+
+#ifdef OC_SECURITY
+  if (FD_ISSET(dev->secure_sock, fds)) {
+    int count = recv_msg(dev->secure_sock, message->data, OC_PDU_SIZE,
+                         &message->endpoint, false);
+    if (count < 0) {
+      return ADAPTER_STATUS_ERROR;
+    }
+    message->length = (size_t)count;
+    message->endpoint.flags = IPV6 | SECURED;
+    message->encrypted = 1;
+    FD_CLR(dev->secure_sock, fds);
+    return ADAPTER_STATUS_RECEIVE;
+  }
+#ifdef OC_IPV4
+  if (FD_ISSET(dev->secure4_sock, fds)) {
+    int count = recv_msg(dev->secure4_sock, message->data, OC_PDU_SIZE,
+                         &message->endpoint, false);
+    if (count < 0) {
+      return ADAPTER_STATUS_ERROR;
+    }
+    message->length = (size_t)count;
+    message->endpoint.flags = IPV4 | SECURED;
+    message->encrypted = 1;
+    FD_CLR(dev->secure4_sock, fds);
+    return ADAPTER_STATUS_RECEIVE;
+  }
+#endif /* OC_IPV4 */
+#endif /* OC_SECURITY */
+
+  return ADAPTER_STATUS_NONE;
+}
+
+static void *
+network_event_thread(void *data)
+{
+  ip_context_t *dev = (ip_context_t *)data;
+
+  fd_set setfds;
+  FD_ZERO(&dev->rfds);
+  /* Monitor network interface changes on the platform from only the 0th logical
+   * device
+   */
+  if (dev->device == 0) {
+    FD_SET(ifchange_sock, &dev->rfds);
+  }
+  FD_SET(dev->shutdown_pipe[0], &dev->rfds);
+
+  oc_udp_add_socks_to_fd_set(dev);
+#ifdef OC_TCP
+  oc_tcp_add_socks_to_fd_set(dev);
+#endif /* OC_TCP */
+
+  int i, n;
+
+  while (dev->terminate != 1) {
+    setfds = dev->rfds;
+    n = select(FD_SETSIZE, &setfds, NULL, NULL, NULL);
+
+    if (FD_ISSET(dev->shutdown_pipe[0], &setfds)) {
+      char buf;
+      // write to pipe shall not block - so read the byte we wrote
+      if (read(dev->shutdown_pipe[0], &buf, 1) < 0) {
+          // intentionally left blank
+      }
+    }
+
+    if (dev->terminate) {
+      break;
+    }
+
+    for (i = 0; i < n; i++) {
+      if (dev->device == 0) {
+        if (FD_ISSET(ifchange_sock, &setfds)) {
+          if (process_interface_change_event() < 0) {
+            OC_WRN("caught errors while handling a network interface change");
+          }
+          FD_CLR(ifchange_sock, &setfds);
+          continue;
+        }
+      }
+
+      oc_message_t *message = oc_allocate_message();
+
+      if (!message) {
+        break;
+      }
+
+      message->endpoint.device = dev->device;
+
+      if (oc_udp_receive_message(dev, &setfds, message) ==
+          ADAPTER_STATUS_RECEIVE) {
+        goto common;
+      }
+#ifdef OC_TCP
+      if (oc_tcp_receive_message(dev, &setfds, message) ==
+          ADAPTER_STATUS_RECEIVE) {
+        goto common;
+      }
+#endif /* OC_TCP */
+
+      oc_message_unref(message);
+      continue;
+
+    common:
+#ifdef OC_DEBUG
+      PRINT("Incoming message of size %d bytes from ", message->length);
+      PRINTipaddr(message->endpoint);
+      PRINT("\n\n");
+#endif /* OC_DEBUG */
+
+      oc_network_event(message);
+    }
+  }
+  pthread_exit(NULL);
+}
+
+static int
+send_msg(int sock, struct sockaddr_storage *receiver, oc_message_t *message)
+{
+  char msg_control[CMSG_LEN(sizeof(struct sockaddr_storage))];
+  struct iovec iovec[1];
+  struct msghdr msg;
+
+  memset(&msg, 0, sizeof(struct msghdr));
+  msg.msg_name = (void *)receiver;
+  msg.msg_namelen = sizeof(struct sockaddr_storage);
+
+  msg.msg_iov = iovec;
+  msg.msg_iovlen = 1;
+
+  if (message->endpoint.flags & IPV6) {
+    struct cmsghdr *cmsg;
+    struct in6_pktinfo *pktinfo;
+
+    msg.msg_control = msg_control;
+    msg.msg_controllen = CMSG_SPACE(sizeof(struct in6_pktinfo));
+    memset(msg.msg_control, 0, msg.msg_controllen);
+
+    cmsg = CMSG_FIRSTHDR(&msg);
+    cmsg->cmsg_level = IPPROTO_IPV6;
+    cmsg->cmsg_type = IPV6_PKTINFO;
+    cmsg->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
+
+    pktinfo = (struct in6_pktinfo *)CMSG_DATA(cmsg);
+    memset(pktinfo, 0, sizeof(struct in6_pktinfo));
+
+    /* Get the outgoing interface index from message->endpint */
+    pktinfo->ipi6_ifindex = message->endpoint.interface_index;
+    /* Set the source address of this message using the address
+     * from the endpoint's addr_local attribute.
+     */
+    memcpy(&pktinfo->ipi6_addr, message->endpoint.addr_local.ipv6.address, 16);
+  }
+#ifdef OC_IPV4
+  else if (message->endpoint.flags & IPV4) {
+    struct cmsghdr *cmsg;
+    struct in_pktinfo *pktinfo;
+
+    msg.msg_control = msg_control;
+    msg.msg_controllen = CMSG_SPACE(sizeof(struct in_pktinfo));
+    memset(msg.msg_control, 0, msg.msg_controllen);
+
+    cmsg = CMSG_FIRSTHDR(&msg);
+    cmsg->cmsg_level = SOL_IP;
+    cmsg->cmsg_type = IP_PKTINFO;
+    cmsg->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));
+
+    pktinfo = (struct in_pktinfo *)CMSG_DATA(cmsg);
+    memset(pktinfo, 0, sizeof(struct in_pktinfo));
+
+    pktinfo->ipi_ifindex = message->endpoint.interface_index;
+    memcpy(&pktinfo->ipi_spec_dst, message->endpoint.addr_local.ipv4.address,
+           4);
+  }
+#else  /* OC_IPV4 */
+  else {
+    OC_ERR("invalid endpoint");
+    return -1;
+  }
+#endif /* !OC_IPV4 */
+
+  int bytes_sent = 0, x;
+  while (bytes_sent < (int)message->length) {
+    iovec[0].iov_base = message->data + bytes_sent;
+    iovec[0].iov_len = message->length - (size_t)bytes_sent;
+    x = sendmsg(sock, &msg, 0);
+    if (x < 0) {
+      OC_WRN("sendto() returned errno %d", errno);
+      break;
+    }
+    bytes_sent += x;
+  }
+  OC_DBG("Sent %d bytes", bytes_sent);
+
+  if (bytes_sent == 0) {
+    return -1;
+  }
+
+  return bytes_sent;
+}
+
+int
+oc_send_buffer(oc_message_t *message)
+{
+#ifdef OC_DEBUG
+  PRINT("Outgoing message of size %d bytes to ", message->length);
+  PRINTipaddr(message->endpoint);
+  PRINT("\n\n");
+#endif /* OC_DEBUG */
+
+  struct sockaddr_storage receiver;
+  memset(&receiver, 0, sizeof(struct sockaddr_storage));
+#ifdef OC_IPV4
+  if (message->endpoint.flags & IPV4) {
+    struct sockaddr_in *r = (struct sockaddr_in *)&receiver;
+    memcpy(&r->sin_addr.s_addr, message->endpoint.addr.ipv4.address,
+           sizeof(r->sin_addr.s_addr));
+    r->sin_family = AF_INET;
+    r->sin_port = htons(message->endpoint.addr.ipv4.port);
+  } else {
+#else
+  {
+#endif
+    struct sockaddr_in6 *r = (struct sockaddr_in6 *)&receiver;
+    memcpy(r->sin6_addr.s6_addr, message->endpoint.addr.ipv6.address,
+           sizeof(r->sin6_addr.s6_addr));
+    r->sin6_family = AF_INET6;
+    r->sin6_port = htons(message->endpoint.addr.ipv6.port);
+    r->sin6_scope_id = message->endpoint.addr.ipv6.scope;
+  }
+  int send_sock = -1;
+
+  ip_context_t *dev = get_ip_context_for_device(message->endpoint.device);
+
+#ifdef OC_TCP
+  if (message->endpoint.flags & TCP) {
+    return oc_tcp_send_buffer(dev, message, &receiver);
+  }
+#endif /* OC_TCP */
+
+#ifdef OC_SECURITY
+  if (message->endpoint.flags & SECURED) {
+#ifdef OC_IPV4
+    if (message->endpoint.flags & IPV4) {
+      send_sock = dev->secure4_sock;
+    } else {
+      send_sock = dev->secure_sock;
+    }
+#else  /* OC_IPV4 */
+    send_sock = dev->secure_sock;
+#endif /* !OC_IPV4 */
+  } else
+#endif /* OC_SECURITY */
+#ifdef OC_IPV4
+    if (message->endpoint.flags & IPV4) {
+    send_sock = dev->server4_sock;
+  } else {
+    send_sock = dev->server_sock;
+  }
+#else  /* OC_IPV4 */
+  {
+    send_sock = dev->server_sock;
+  }
+#endif /* !OC_IPV4 */
+
+  return send_msg(send_sock, &receiver, message);
+}
+
+#ifdef OC_CLIENT
+void
+oc_send_discovery_request(oc_message_t *message)
+{
+  struct ifaddrs *ifs = NULL, *interface = NULL;
+  if (getifaddrs(&ifs) < 0) {
+    OC_ERR("querying interfaces: %d", errno);
+    goto done;
+  }
+
+  memset(&message->endpoint.addr_local, 0,
+         sizeof(message->endpoint.addr_local));
+  message->endpoint.interface_index = 0;
+
+  ip_context_t *dev = get_ip_context_for_device(message->endpoint.device);
+
+  for (interface = ifs; interface != NULL; interface = interface->ifa_next) {
+    if (!(interface->ifa_flags & IFF_UP) || interface->ifa_flags & IFF_LOOPBACK)
+      continue;
+    if (message->endpoint.flags & IPV6 && interface->ifa_addr &&
+        interface->ifa_addr->sa_family == AF_INET6) {
+      struct sockaddr_in6 *addr = (struct sockaddr_in6 *)interface->ifa_addr;
+      if (IN6_IS_ADDR_LINKLOCAL(&addr->sin6_addr)) {
+        unsigned int mif = if_nametoindex(interface->ifa_name);
+        if (setsockopt(dev->server_sock, IPPROTO_IPV6, IPV6_MULTICAST_IF, &mif,
+                       sizeof(mif)) == -1) {
+          OC_ERR("setting socket option for default IPV6_MULTICAST_IF: %d",
+                 errno);
+          goto done;
+        }
+        message->endpoint.interface_index = mif;
+        message->endpoint.addr.ipv6.scope = mif;
+        oc_send_buffer(message);
+      }
+#ifdef OC_IPV4
+    } else if (message->endpoint.flags & IPV4 && interface->ifa_addr &&
+               interface->ifa_addr->sa_family == AF_INET) {
+      struct sockaddr_in *addr = (struct sockaddr_in *)interface->ifa_addr;
+      if (setsockopt(dev->server4_sock, IPPROTO_IP, IP_MULTICAST_IF,
+                     &addr->sin_addr, sizeof(addr->sin_addr)) == -1) {
+        OC_ERR("setting socket option for default IP_MULTICAST_IF: %d",
+               errno);
+        goto done;
+      }
+      message->endpoint.interface_index = if_nametoindex(interface->ifa_name);
+      oc_send_buffer(message);
+    }
+#else  /* OC_IPV4 */
+    }
+#endif /* !OC_IPV4 */
+  }
+done:
+  freeifaddrs(ifs);
+}
+#endif /* OC_CLIENT */
+
+#ifdef OC_NETWORK_MONITOR
+void
+handle_network_interface_event_callback(oc_interface_event_t event)
+{
+  /* TBD:
+   * Requires further investion whether this function should be implemented on webOS
+   */
+}
+#endif /* OC_NETWORK_MONITOR */
+
+#ifdef OC_SESSION_EVENTS
+int
+oc_add_session_event_callback(session_event_handler_t cb)
+{
+  if (!cb)
+    return -1;
+
+  oc_session_event_cb_t *cb_item = oc_memb_alloc(&oc_session_event_cb_s);
+  if (!cb_item) {
+    OC_ERR("session event callback item alloc failed");
+    return -1;
+  }
+
+  cb_item->handler = cb;
+  oc_list_add(oc_session_event_cb_list, cb_item);
+  return 0;
+}
+
+int
+oc_remove_session_event_callback(session_event_handler_t cb)
+{
+  if (!cb)
+    return -1;
+
+  oc_session_event_cb_t *cb_item = oc_list_head(oc_session_event_cb_list);
+  while (cb_item != NULL && cb_item->handler != cb) {
+    cb_item = cb_item->next;
+  }
+  if (!cb_item) {
+    return -1;
+  }
+  oc_list_remove(oc_session_event_cb_list, cb_item);
+
+  oc_memb_free(&oc_session_event_cb_s, cb_item);
+  return 0;
+}
+
+void
+handle_session_event_callback(const oc_endpoint_t *endpoint,
+                              oc_session_state_t state)
+{
+  if (oc_list_length(oc_session_event_cb_list) > 0) {
+    oc_session_event_cb_t *cb_item = oc_list_head(oc_session_event_cb_list);
+    while (cb_item) {
+      cb_item->handler(endpoint, state);
+      cb_item = cb_item->next;
+    }
+  }
+}
+#endif /* OC_SESSION_EVENTS */
+
+#ifdef OC_IPV4
+static int
+connectivity_ipv4_init(ip_context_t *dev)
+{
+  OC_DBG("Initializing IPv4 connectivity for device %d", dev->device);
+  memset(&dev->mcast4, 0, sizeof(struct sockaddr_storage));
+  memset(&dev->server4, 0, sizeof(struct sockaddr_storage));
+
+  struct sockaddr_in *m = (struct sockaddr_in *)&dev->mcast4;
+  m->sin_family = AF_INET;
+  m->sin_port = htons(OCF_PORT_UNSECURED);
+  m->sin_addr.s_addr = INADDR_ANY;
+
+  struct sockaddr_in *l = (struct sockaddr_in *)&dev->server4;
+  l->sin_family = AF_INET;
+  l->sin_addr.s_addr = INADDR_ANY;
+  l->sin_port = 0;
+
+#ifdef OC_SECURITY
+  memset(&dev->secure4, 0, sizeof(struct sockaddr_storage));
+  struct sockaddr_in *sm = (struct sockaddr_in *)&dev->secure4;
+  sm->sin_family = AF_INET;
+  sm->sin_port = 0;
+  sm->sin_addr.s_addr = INADDR_ANY;
+
+  dev->secure4_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+  if (dev->secure4_sock < 0) {
+    OC_ERR("creating secure IPv4 socket");
+    return -1;
+  }
+#endif /* OC_SECURITY */
+
+  dev->server4_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+  dev->mcast4_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+
+  if (dev->server4_sock < 0 || dev->mcast4_sock < 0) {
+    OC_ERR("creating IPv4 server sockets");
+    return -1;
+  }
+
+  int on = 1;
+  if (setsockopt(dev->server4_sock, IPPROTO_IP, IP_PKTINFO, &on, sizeof(on)) ==
+      -1) {
+    OC_ERR("setting pktinfo IPv4 option %d\n", errno);
+    return -1;
+  }
+  if (setsockopt(dev->server4_sock, SOL_SOCKET, SO_REUSEADDR, &on,
+                 sizeof(on)) == -1) {
+    OC_ERR("setting reuseaddr option %d", errno);
+    return -1;
+  }
+  if (bind(dev->server4_sock, (struct sockaddr *)&dev->server4,
+           sizeof(dev->server4)) == -1) {
+    OC_ERR("binding server4 socket %d", errno);
+    return -1;
+  }
+
+  socklen_t socklen = sizeof(dev->server4);
+  if (getsockname(dev->server4_sock, (struct sockaddr *)&dev->server4,
+                  &socklen) == -1) {
+    OC_ERR("obtaining server4 socket information %d", errno);
+    return -1;
+  }
+
+  dev->port4 = ntohs(l->sin_port);
+
+  if (configure_mcast_socket(dev->mcast4_sock, AF_INET) < 0) {
+    return -1;
+  }
+
+  if (setsockopt(dev->mcast4_sock, IPPROTO_IP, IP_PKTINFO, &on, sizeof(on)) ==
+      -1) {
+    OC_ERR("setting pktinfo IPv4 option %d\n", errno);
+    return -1;
+  }
+  if (setsockopt(dev->mcast4_sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) ==
+      -1) {
+    OC_ERR("setting reuseaddr IPv4 option %d", errno);
+    return -1;
+  }
+  if (bind(dev->mcast4_sock, (struct sockaddr *)&dev->mcast4,
+           sizeof(dev->mcast4)) == -1) {
+    OC_ERR("binding mcast IPv4 socket %d", errno);
+    return -1;
+  }
+
+#ifdef OC_SECURITY
+  if (setsockopt(dev->secure4_sock, IPPROTO_IP, IP_PKTINFO, &on, sizeof(on)) ==
+      -1) {
+    OC_ERR("setting pktinfo IPV4 option %d\n", errno);
+    return -1;
+  }
+  if (setsockopt(dev->secure4_sock, SOL_SOCKET, SO_REUSEADDR, &on,
+                 sizeof(on)) == -1) {
+    OC_ERR("setting reuseaddr IPv4 option %d", errno);
+    return -1;
+  }
+  if (bind(dev->secure4_sock, (struct sockaddr *)&dev->secure4,
+           sizeof(dev->secure4)) == -1) {
+    OC_ERR("binding IPv4 secure socket %d", errno);
+    return -1;
+  }
+
+  socklen = sizeof(dev->secure4);
+  if (getsockname(dev->secure4_sock, (struct sockaddr *)&dev->secure4,
+                  &socklen) == -1) {
+    OC_ERR("obtaining DTLS4 socket information %d", errno);
+    return -1;
+  }
+
+  dev->dtls4_port = ntohs(sm->sin_port);
+#endif /* OC_SECURITY */
+
+  OC_DBG("Successfully initialized IPv4 connectivity for device %d",
+         dev->device);
+
+  return 0;
+}
+#endif
+
+int oc_connectivity_init(size_t device) {
+  OC_DBG("Initializing connectivity for device %d", device);
+
+  ip_context_t *dev = (ip_context_t *)oc_memb_alloc(&ip_context_s);
+  if (!dev) {
+    oc_abort("Insufficient memory");
+  }
+  oc_list_add(ip_contexts, dev);
+  dev->device = device;
+  OC_LIST_STRUCT_INIT(dev, eps);
+
+  if (pipe(dev->shutdown_pipe) < 0) {
+    OC_ERR("shutdown pipe: %d", errno);
+    return -1;
+  }
+
+  memset(&dev->mcast, 0, sizeof(struct sockaddr_storage));
+  memset(&dev->server, 0, sizeof(struct sockaddr_storage));
+
+  struct sockaddr_in6 *m = (struct sockaddr_in6 *)&dev->mcast;
+  m->sin6_family = AF_INET6;
+  m->sin6_port = htons(OCF_PORT_UNSECURED);
+  m->sin6_addr = in6addr_any;
+
+  struct sockaddr_in6 *l = (struct sockaddr_in6 *)&dev->server;
+  l->sin6_family = AF_INET6;
+  l->sin6_addr = in6addr_any;
+  l->sin6_port = 0;
+
+#ifdef OC_SECURITY
+  memset(&dev->secure, 0, sizeof(struct sockaddr_storage));
+  struct sockaddr_in6 *sm = (struct sockaddr_in6 *)&dev->secure;
+  sm->sin6_family = AF_INET6;
+  sm->sin6_port = 0;
+  sm->sin6_addr = in6addr_any;
+#endif /* OC_SECURITY */
+
+  dev->server_sock = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
+  dev->mcast_sock = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
+
+  if (dev->server_sock < 0 || dev->mcast_sock < 0) {
+    OC_ERR("creating server sockets");
+    return -1;
+  }
+
+#ifdef OC_SECURITY
+  dev->secure_sock = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
+  if (dev->secure_sock < 0) {
+    OC_ERR("creating secure socket");
+    return -1;
+  }
+#endif /* OC_SECURITY */
+
+  int on = 1;
+  if (setsockopt(dev->server_sock, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on,
+                 sizeof(on)) == -1) {
+    OC_ERR("setting recvpktinfo option %d\n", errno);
+    return -1;
+  }
+  if (setsockopt(dev->server_sock, IPPROTO_IPV6, IPV6_V6ONLY, &on,
+                 sizeof(on)) == -1) {
+    OC_ERR("setting sock option %d", errno);
+    return -1;
+  }
+  if (setsockopt(dev->server_sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) ==
+      -1) {
+    OC_ERR("setting reuseaddr option %d", errno);
+    return -1;
+  }
+  if (bind(dev->server_sock, (struct sockaddr *)&dev->server,
+           sizeof(dev->server)) == -1) {
+    OC_ERR("binding server socket %d", errno);
+    return -1;
+  }
+
+  socklen_t socklen = sizeof(dev->server);
+  if (getsockname(dev->server_sock, (struct sockaddr *)&dev->server,
+                  &socklen) == -1) {
+    OC_ERR("obtaining server socket information %d", errno);
+    return -1;
+  }
+
+  dev->port = ntohs(l->sin6_port);
+
+  if (configure_mcast_socket(dev->mcast_sock, AF_INET6) < 0) {
+    return -1;
+  }
+
+  if (setsockopt(dev->mcast_sock, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on,
+                 sizeof(on)) == -1) {
+    OC_ERR("setting recvpktinfo option %d\n", errno);
+    return -1;
+  }
+  if (setsockopt(dev->mcast_sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) ==
+      -1) {
+    OC_ERR("setting reuseaddr option %d", errno);
+    return -1;
+  }
+  if (bind(dev->mcast_sock, (struct sockaddr *)&dev->mcast,
+           sizeof(dev->mcast)) == -1) {
+    OC_ERR("binding mcast socket %d", errno);
+    return -1;
+  }
+
+#ifdef OC_SECURITY
+  if (setsockopt(dev->secure_sock, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on,
+                 sizeof(on)) == -1) {
+    OC_ERR("setting recvpktinfo option %d\n", errno);
+    return -1;
+  }
+  if (setsockopt(dev->secure_sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) ==
+      -1) {
+    OC_ERR("setting reuseaddr option %d", errno);
+    return -1;
+  }
+  if (bind(dev->secure_sock, (struct sockaddr *)&dev->secure,
+           sizeof(dev->secure)) == -1) {
+    OC_ERR("binding IPv6 secure socket %d", errno);
+    return -1;
+  }
+
+  socklen = sizeof(dev->secure);
+  if (getsockname(dev->secure_sock, (struct sockaddr *)&dev->secure,
+                  &socklen) == -1) {
+    OC_ERR("obtaining secure socket information %d", errno);
+    return -1;
+  }
+
+  dev->dtls_port = ntohs(sm->sin6_port);
+#endif /* OC_SECURITY */
+
+#ifdef OC_IPV4
+  if (connectivity_ipv4_init(dev) != 0) {
+    OC_ERR("Could not initialize IPv4");
+  }
+#endif /* OC_IPV4 */
+
+  OC_DBG("=======ip port info.========");
+  OC_DBG("  ipv6 port   : %u", dev->port);
+#ifdef OC_SECURITY
+  OC_DBG("  ipv6 secure : %u", dev->dtls_port);
+#endif
+#ifdef OC_IPV4
+  OC_DBG("  ipv4 port   : %u", dev->port4);
+#ifdef OC_SECURITY
+  OC_DBG("  ipv4 secure : %u", dev->dtls4_port);
+#endif
+#endif
+
+#ifdef OC_TCP
+  if (oc_tcp_connectivity_init(dev) != 0) {
+    OC_ERR("Could not initialize TCP adapter");
+  }
+#endif /* OC_TCP */
+
+  /* Netlink socket to listen for network interface changes.
+   * Only initialized once, and change events are captured by only
+   * the network event thread for the 0th logical device.
+   */
+  if (!ifchange_initialized) {
+    memset(&ifchange_nl, 0, sizeof(struct sockaddr_nl));
+    ifchange_nl.nl_family = AF_NETLINK;
+    ifchange_nl.nl_groups =
+        RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV6_IFADDR;
+    ifchange_sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+    if (ifchange_sock < 0) {
+      OC_ERR(
+          "creating netlink socket to monitor network interface changes %d",
+          errno);
+      return -1;
+    }
+    if (bind(ifchange_sock, (struct sockaddr *)&ifchange_nl,
+             sizeof(ifchange_nl)) == -1) {
+      OC_ERR("binding netlink socket %d", errno);
+      return -1;
+    }
+#ifdef OC_NETWORK_MONITOR
+    initializeLS();
+    networkMonitorHandler();
+#endif /* OC_NETWORK_MONITOR */
+    ifchange_initialized = true;
+  }
+
+  if (pthread_create(&dev->event_thread, NULL, &network_event_thread, dev) !=
+      0) {
+    OC_ERR("creating network polling thread");
+    return -1;
+  }
+
+  OC_DBG("Successfully initialized connectivity for device %d", device);
+
+  return 0;
+}
+
+void
+oc_connectivity_shutdown(size_t device)
+{
+  ip_context_t *dev = get_ip_context_for_device(device);
+  dev->terminate = 1;
+  if (write(dev->shutdown_pipe[1], "\n", 1) < 0) {
+      OC_WRN("cannot wakeup network thread");
+  }
+
+  close(dev->server_sock);
+  close(dev->mcast_sock);
+
+#ifdef OC_IPV4
+  close(dev->server4_sock);
+  close(dev->mcast4_sock);
+#endif /* OC_IPV4 */
+
+#ifdef OC_SECURITY
+  close(dev->secure_sock);
+#ifdef OC_IPV4
+  close(dev->secure4_sock);
+#endif /* OC_IPV4 */
+#endif /* OC_SECURITY */
+
+#ifdef OC_TCP
+  oc_tcp_connectivity_shutdown(dev);
+#endif /* OC_TCP */
+
+  pthread_join(dev->event_thread, NULL);
+
+  close(dev->shutdown_pipe[1]);
+  close(dev->shutdown_pipe[0]);
+
+  free_endpoints_list(dev);
+
+  oc_list_remove(ip_contexts, dev);
+  oc_memb_free(&ip_context_s, dev);
+
+  OC_DBG("oc_connectivity_shutdown for device %d", device);
+}
+
+#ifdef OC_TCP
+void
+oc_connectivity_end_session(oc_endpoint_t *endpoint)
+{
+  if (endpoint->flags & TCP) {
+    ip_context_t *dev = get_ip_context_for_device(endpoint->device);
+    if (dev) {
+      oc_tcp_end_session(dev, endpoint);
+    }
+  }
+}
+#endif /* OC_TCP */
+
+#ifdef OC_DNS_LOOKUP
+int
+oc_dns_lookup(const char *domain, oc_string_t *addr, enum transport_flags flags)
+{
+  if (!domain || !addr) {
+    OC_ERR("Error of input parameters");
+    return -1;
+  }
+
+  struct addrinfo hints, *result = NULL;
+  memset(&hints, 0, sizeof(hints));
+  hints.ai_family = (flags & IPV6) ? AF_INET6 : AF_INET;
+  hints.ai_socktype = (flags & TCP) ? SOCK_STREAM : SOCK_DGRAM;
+  int ret = getaddrinfo(domain, NULL, &hints, &result);
+
+  if (ret == 0) {
+    char address[INET6_ADDRSTRLEN + 2] = { 0 };
+    const char *dest = NULL;
+    if (flags & IPV6) {
+      struct sockaddr_in6 *s_addr = (struct sockaddr_in6 *)result->ai_addr;
+      address[0] = '[';
+      dest = inet_ntop(AF_INET6, (void *)&s_addr->sin6_addr, address + 1,
+                       INET6_ADDRSTRLEN);
+      size_t addr_len = strlen(address);
+      address[addr_len] = ']';
+      address[addr_len + 1] = '\0';
+    }
+#ifdef OC_IPV4
+    else {
+      struct sockaddr_in *s_addr = (struct sockaddr_in *)result->ai_addr;
+      dest =
+        inet_ntop(AF_INET, (void *)&s_addr->sin_addr, address, INET_ADDRSTRLEN);
+    }
+#endif /* OC_IPV4 */
+    if (dest) {
+      OC_DBG("%s address is %s", domain, address);
+      oc_new_string(addr, address, strlen(address));
+    } else {
+      ret = -1;
+    }
+  }
+
+  freeaddrinfo(result);
+  return ret;
+}
+#endif /* OC_DNS_LOOKUP */
diff --git a/port/webos/ipcontext.h b/port/webos/ipcontext.h
new file mode 100644
index 00000000..6d59a5ad
--- /dev/null
+++ b/port/webos/ipcontext.h
@@ -0,0 +1,105 @@
+/****************************************************************************
+ *
+ * Copyright 2018 Samsung Electronics All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ ****************************************************************************/
+
+#ifndef IPCONTEXT_H
+#define IPCONTEXT_H
+
+#include "oc_endpoint.h"
+#include <pthread.h>
+#include <stdint.h>
+#include <sys/select.h>
+#include <sys/socket.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+typedef enum {
+  ADAPTER_STATUS_NONE = 0, /* Nothing happens */
+  ADAPTER_STATUS_ACCEPT,   /* Receiving no meaningful data */
+  ADAPTER_STATUS_RECEIVE,  /* Receiving meaningful data */
+  ADAPTER_STATUS_ERROR     /* Error */
+} adapter_receive_state_t;
+
+#ifdef OC_TCP
+typedef struct tcp_context_t
+{
+  struct sockaddr_storage server;
+  int server_sock;
+  uint16_t port;
+#ifdef OC_SECURITY
+  struct sockaddr_storage secure;
+  int secure_sock;
+  uint16_t tls_port;
+#endif /* OC_SECURITY */
+#ifdef OC_IPV4
+  struct sockaddr_storage server4;
+  int server4_sock;
+  uint16_t port4;
+#ifdef OC_SECURITY
+  struct sockaddr_storage secure4;
+  int secure4_sock;
+  uint16_t tls4_port;
+#endif /* OC_SECURITY */
+#endif /* OC_IPV4 */
+  int connect_pipe[2];
+  pthread_mutex_t mutex;
+} tcp_context_t;
+#endif
+
+typedef struct ip_context_t {
+  struct ip_context_t *next;
+  OC_LIST_STRUCT(eps);
+  struct sockaddr_storage mcast;
+  struct sockaddr_storage server;
+  int mcast_sock;
+  int server_sock;
+  uint16_t port;
+#ifdef OC_SECURITY
+  struct sockaddr_storage secure;
+  int secure_sock;
+  uint16_t dtls_port;
+#endif /* OC_SECURITY */
+#ifdef OC_IPV4
+  struct sockaddr_storage mcast4;
+  struct sockaddr_storage server4;
+  int mcast4_sock;
+  int server4_sock;
+  uint16_t port4;
+#ifdef OC_SECURITY
+  struct sockaddr_storage secure4;
+  int secure4_sock;
+  uint16_t dtls4_port;
+#endif /* OC_SECURITY */
+#endif /* OC_IPV4 */
+#ifdef OC_TCP
+  tcp_context_t tcp;
+#endif
+  pthread_t event_thread;
+  int terminate;
+  size_t device;
+  fd_set rfds;
+  int shutdown_pipe[2];
+} ip_context_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* IPCONTEXT_H */
diff --git a/port/webos/luna_adapter_util.c b/port/webos/luna_adapter_util.c
new file mode 100644
index 00000000..18154d74
--- /dev/null
+++ b/port/webos/luna_adapter_util.c
@@ -0,0 +1,315 @@
+/****************************************************************************
+ *
+ * Copyright (c) 2019 LG Electronics, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ ****************************************************************************/
+
+#include <luna-service2/lunaservice.h>
+#include <glib.h>
+#include <pbnjson.h>
+#include "luna_adapter_util.h"
+#include "port/oc_log.h"
+
+typedef struct _CONNECTION_STATUS {
+  bool isConnectWired;
+  bool isConnectWiFi;
+} CONNECTION_STATUS_T;
+
+CONNECTION_STATUS_T gConnectionStates;
+
+#define LS_CONNECTIONMANAGER_GETSTATUS_URI "luna://com.webos.service.connectionmanager/getstatus"
+#define MAX_LS_NAME_SIZE 1024
+#define MAX_GET_LS_SERVICE_NAME_COUNT 5
+static LSHandle *g_pLSHandle = NULL;
+static GMainContext *g_loopContext = NULL;
+static GMainLoop *g_mainLoop = NULL;
+static bool g_isLSRegistering = false;
+char *g_lsServiceName = NULL;
+
+pthread_t threadId_monitor;
+
+static bool checkLSRegistered()
+{
+  if (g_pLSHandle)
+  {
+    OC_DBG("Luna service is already registered");
+    return true;
+  }
+  else
+  {
+    OC_DBG("Luna service is not registered");
+    return false;
+  }
+}
+
+static bool createLSServiceName()
+{
+  FILE *fp = NULL;
+  char processNameBuff[MAX_LS_NAME_SIZE];
+  char lunaServiceBuff[MAX_LS_NAME_SIZE];
+  size_t readSize = 0;
+  char *command = NULL;
+
+  command = g_strdup_printf("ps -p %d -f | sed -n '2p' | awk '{print $8}' | cut -d '/' -f2", getpid());
+
+  fp = popen(command, "r");
+  if (NULL == fp)
+  {
+    OC_DBG("Failed to open ls-monitor");
+    exit(1);
+  }
+
+  readSize = fread((void*)processNameBuff, sizeof(char), MAX_LS_NAME_SIZE - 1, fp);
+  OC_DBG("processNameBuff : %s, readSize: %d", processNameBuff, readSize);
+
+  processNameBuff[readSize]='0';
+  command = g_strdup_printf("find /usr/share/luna-service2/services.d/ -name \"*.*\" | /usr/bin/xargs grep %s | grep 'Name' | cut -d '=' -f2 | cut -d '*' -f1", g_strndup(processNameBuff, readSize-1));
+
+  OC_DBG("PID : %d", getpid());
+
+  // Get service Name by pid
+  fp = popen(command, "r");
+  if (NULL == fp)
+  {
+    OC_DBG("Failed to open ls-monitor");
+    exit(1);
+  }
+  readSize = fread((void*)lunaServiceBuff, sizeof(char), MAX_LS_NAME_SIZE - 1, fp);
+  OC_DBG("lunaServiceBuff : %s, readSize: %d", lunaServiceBuff, readSize);
+  if (0 == readSize)
+  {
+    OC_DBG("This process does not have Luna service");
+    g_free(command);
+    pclose(fp);
+    return false;
+  }
+  lunaServiceBuff[readSize]='0';
+
+  g_lsServiceName = g_strdup_printf("%s-iotivity%d", g_strndup(lunaServiceBuff, readSize-1), getpid());
+
+  pclose( fp);
+
+  return true;
+}
+
+static void triggerCreateLSServiceName()
+{
+  for (int i = 0; i < MAX_GET_LS_SERVICE_NAME_COUNT; i++)
+  {
+    if (createLSServiceName())
+    {
+      OC_DBG("Luna service name : %s", g_lsServiceName);
+      break;
+    }
+    sleep(1);
+  }
+}
+
+static void *startLSMainLoop(gpointer user_data)
+{
+  OC_DBG("startLSMainLoop");
+
+  LSError lserror;
+  LSErrorInit(&lserror);
+
+  g_isLSRegistering = true;
+  if (g_lsServiceName == NULL)
+  {
+    OC_DBG("Failed to create Luna service name");
+    return;
+  }
+
+  g_loopContext = g_main_context_new();
+  g_mainLoop = g_main_loop_new(g_loopContext, FALSE);
+  g_main_context_push_thread_default(g_loopContext);
+
+  if (!g_mainLoop)
+  {
+    OC_DBG("Failed to create main loop");
+    return;
+  }
+
+  if (!LSRegister(g_lsServiceName, &g_pLSHandle, &lserror))
+  {
+    OC_DBG("Failed to register LS Handle");
+    return;
+  }
+  if (!LSGmainAttach(g_pLSHandle, g_mainLoop, &lserror))
+  {
+    OC_DBG("Failed to attach main loop");
+    return;
+  }
+
+  g_isLSRegistering = false;
+  g_main_loop_run(g_mainLoop);
+
+  g_main_context_unref(g_loopContext);
+  g_main_loop_unref(g_mainLoop);
+}
+
+LSHandle* getLSHandle()
+{
+  OC_DBG("getLSHandle");
+  return g_pLSHandle;
+}
+
+/**
+ * Get connection status callback.
+ */
+static bool get_connection_status_cb(LSHandle *sh, LSMessage *message, void *ctx)
+{
+  OC_DBG("Callback for com.webos.service.connectionmanager/getstatus is invoked...");
+
+  jvalue_ref parsedObj = {0};
+  jschema_ref input_schema = jschema_parse(j_cstr_to_buffer("{}"), DOMOPT_NOOPT, NULL);
+
+  if (!input_schema)
+    return false;
+
+  JSchemaInfo schemaInfo;
+  jschema_info_init(&schemaInfo, input_schema, NULL, NULL);
+  parsedObj = jdom_parse(j_cstr_to_buffer(LSMessageGetPayload(message)), DOMOPT_NOOPT, &schemaInfo);
+  jschema_release(&input_schema);
+
+  if (jis_null(parsedObj))
+    return true;
+
+  const char *payload = jvalue_tostring(parsedObj, input_schema);
+
+  OC_DBG("Paylod: %s", payload);
+  jvalue_ref wiredObj={0}, wifiObj ={0}, wiredStateObj={0}, wifiStateObj={0};
+  if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("wired"), &wiredObj))
+  {
+    if (jobject_get_exists(wiredObj, J_CSTR_TO_BUF("state"), &wiredStateObj))
+    {
+      if (jstring_equal2(wiredStateObj, J_CSTR_TO_BUF("connected")) && !gConnectionStates.isConnectWired)
+      {
+        gConnectionStates.isConnectWired = true;
+        oc_network_interface_event(NETWORK_INTERFACE_UP);
+        OC_DBG("Wired LAN is connected...");
+      }
+      else if (jstring_equal2(wiredStateObj, J_CSTR_TO_BUF("disconnected")) && gConnectionStates.isConnectWired)
+      {
+        gConnectionStates.isConnectWired = false;
+        oc_network_interface_event(NETWORK_INTERFACE_DOWN);
+        OC_DBG("Wired LAN is disconnected...");
+      }
+    }
+  }
+  if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("wifi"), &wifiObj))
+  {
+    if (jobject_get_exists(wifiObj, J_CSTR_TO_BUF("state"), &wifiStateObj))
+    {
+      if (jstring_equal2(wifiStateObj, J_CSTR_TO_BUF("connected")) && !gConnectionStates.isConnectWiFi)
+      {
+        gConnectionStates.isConnectWiFi = true;
+        oc_network_interface_event(NETWORK_INTERFACE_UP);
+        OC_DBG("Wi-Fi is connected...");
+      }
+      else if (jstring_equal2(wifiStateObj, J_CSTR_TO_BUF("disconnected")) && gConnectionStates.isConnectWiFi)
+      {
+        gConnectionStates.isConnectWiFi = false;
+        oc_network_interface_event(NETWORK_INTERFACE_DOWN);
+        OC_DBG("Wi-Fi is disconnected...");
+      }
+    }
+  }
+  return true;
+}
+
+void networkMonitorHandler()
+{
+  OC_DBG("networkMonitorHandler");
+  LSError lserror;
+  LSErrorInit(&lserror);
+
+  if (!getLSHandle())
+  {
+    OC_DBG("Luna service handle is null");
+    exit(1);
+  }
+
+  if(!LSCall(getLSHandle(), LS_CONNECTIONMANAGER_GETSTATUS_URI,
+                          "{\"subscribe\":true}",
+                          get_connection_status_cb, NULL, NULL, &lserror))
+  {
+    OC_DBG("com.webos.service.connectionmanager/getstatus failed");
+    LSErrorPrint(&lserror, stderr);
+  }
+  else
+  {
+    OC_DBG("com.webos.service.connectionmanager/getstatus succeeds");
+  }
+}
+
+bool initializeLS(void)
+{
+  OC_DBG("initializeLS");
+
+  bool result = false;
+
+  if (checkLSRegistered())
+   return true;
+
+  if (g_isLSRegistering)
+  {
+    OC_DBG("Wait for registering LS service");
+    sleep(1);
+  }
+
+  triggerCreateLSServiceName();
+
+  result = pthread_create(&threadId_monitor, NULL, startLSMainLoop, (void *)NULL);
+  if (result)
+  {
+    OC_DBG("Failed to create LS thread");
+    return result;
+  }
+  for (int i = 0; i < MAX_GET_LS_SERVICE_NAME_COUNT; i++)
+  {
+    if (checkLSRegistered())
+    {
+      result = true;
+      break;
+    }
+    else
+    {
+      sleep(1);
+      result = false;
+    }
+  }
+  return result;
+}
+
+void terminateLS()
+{
+  OC_DBG("terminateLS");
+  LSError lserror;
+  LSErrorInit(&lserror);
+
+  if (g_pLSHandle)
+  {
+    OC_DBG("g_pLSHandle is not null");
+    if (!LSUnregister(g_pLSHandle, &lserror))
+    {
+      OC_DBG("Failed to unregister Luna service");
+      LSErrorPrint(&lserror, stderr);
+      LSErrorFree(&lserror);
+    }
+    g_pLSHandle = NULL;
+  }
+
+  g_main_loop_quit(g_mainLoop);
+}
diff --git a/port/webos/luna_adapter_util.h b/port/webos/luna_adapter_util.h
new file mode 100644
index 00000000..dbc0f25a
--- /dev/null
+++ b/port/webos/luna_adapter_util.h
@@ -0,0 +1,33 @@
+/****************************************************************************
+ *
+ * Copyright (c) 2019 LG Electronics, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ ****************************************************************************/
+
+#ifndef LUNA_ADAPTER_UTIL_H
+#define LUNA_ADAPTER_UTIL_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "oc_network_events.h"
+
+bool initializeLS(void);
+void terminateLS();
+void networkMonitorHandler();
+
+#endif /* LUNA_ADAPTER_UTIL_H */
diff --git a/port/webos/oc_config.h b/port/webos/oc_config.h
new file mode 100644
index 00000000..782adfe0
--- /dev/null
+++ b/port/webos/oc_config.h
@@ -0,0 +1,95 @@
+#ifndef OC_CONFIG_H
+#define OC_CONFIG_H
+
+/* Time resolution */
+#include <stdint.h>
+#include <time.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef uint64_t oc_clock_time_t;
+#define OC_CLOCK_CONF_TICKS_PER_SECOND CLOCKS_PER_SEC
+//#define OC_SPEC_VER_OIC
+/* Security Layer */
+/* Max inactivity timeout before tearing down DTLS connection */
+#define OC_DTLS_INACTIVITY_TIMEOUT (600)
+
+/* Maximum wait time for select function */
+#define SELECT_TIMEOUT_SEC (1)
+
+/* Add support for passing network up/down events to the app */
+#define OC_NETWORK_MONITOR
+/* Add support for passing TCP/TLS/DTLS session connection events to the app */
+#define OC_SESSION_EVENTS
+
+/* Add support for dns lookup to the endpoint */
+#define OC_DNS_LOOKUP
+#define OC_DNS_LOOKUP_IPV6
+
+/* If we selected support for dynamic memory allocation */
+#ifdef OC_DYNAMIC_ALLOCATION
+#define OC_COLLECTIONS
+#define OC_BLOCK_WISE
+
+#else /* OC_DYNAMIC_ALLOCATION */
+/* List of constraints below for a build that does not employ dynamic
+   memory allocation
+*/
+/* Memory pool sizes */
+#define OC_BYTES_POOL_SIZE (1800)
+#define OC_INTS_POOL_SIZE (100)
+#define OC_DOUBLES_POOL_SIZE (4)
+
+/* Server-side parameters */
+/* Maximum number of server resources */
+#define OC_MAX_APP_RESOURCES (4)
+
+#define OC_MAX_NUM_COLLECTIONS (1)
+
+/* Common paramters */
+/* Prescriptive lower layers MTU size, enable block-wise transfers */
+#define OC_BLOCK_WISE_SET_MTU (700)
+
+/* Maximum size of request/response payloads */
+#define OC_MAX_APP_DATA_SIZE (2048)
+
+/* Maximum number of concurrent requests */
+#define OC_MAX_NUM_CONCURRENT_REQUESTS (3)
+
+/* Maximum number of nodes in a payload tree structure */
+#define OC_MAX_NUM_REP_OBJECTS (150)
+
+/* Number of devices on the OCF platform */
+#define OC_MAX_NUM_DEVICES (2)
+
+/* Maximum number of endpoints */
+#define OC_MAX_NUM_ENDPOINTS (20)
+
+/* Security layer */
+/* Maximum number of authorized clients */
+#define OC_MAX_NUM_SUBJECTS (2)
+
+/* Maximum number of concurrent (D)TLS sessions */
+#define OC_MAX_TLS_PEERS (1)
+
+/* Maximum number of peer for TCP channel */
+#define OC_MAX_TCP_PEERS (2)
+
+/* Maximum number of interfaces for IP adapter */
+#define OC_MAX_IP_INTERFACES (2)
+
+/* Maximum number of callbacks for Network interface event monitoring */
+#define OC_MAX_NETWORK_INTERFACE_CBS (2)
+
+/* Maximum number of callbacks for connection of session */
+#define OC_MAX_SESSION_EVENT_CBS (2)
+
+#endif /* !OC_DYNAMIC_ALLOCATION */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* OC_CONFIG_H */
diff --git a/port/webos/random.c b/port/webos/random.c
new file mode 100644
index 00000000..8ef80400
--- /dev/null
+++ b/port/webos/random.c
@@ -0,0 +1,49 @@
+/*
+// Copyright (c) 2016 Intel Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#include "port/oc_random.h"
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+static int urandom_fd;
+
+void
+oc_random_init(void)
+{
+  urandom_fd = open("/dev/urandom", O_RDONLY);
+}
+
+unsigned int
+oc_random_value(void)
+{
+  unsigned int rand = 0;
+  int ret = read(urandom_fd, &rand, sizeof(rand));
+  assert(ret != -1);
+#ifndef DEBUG
+  (void)ret;
+#endif
+  return rand;
+}
+
+void
+oc_random_destroy(void)
+{
+  close(urandom_fd);
+}
diff --git a/port/webos/storage.c b/port/webos/storage.c
new file mode 100644
index 00000000..ab0c0b25
--- /dev/null
+++ b/port/webos/storage.c
@@ -0,0 +1,86 @@
+/*
+// Copyright (c) 2016 Intel Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#include "port/oc_storage.h"
+
+#ifdef OC_SECURITY
+#include <errno.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+
+#define STORE_PATH_SIZE 64
+
+static char store_path[STORE_PATH_SIZE];
+static int store_path_len;
+static bool path_set = false;
+
+int
+oc_storage_config(const char *store)
+{
+  store_path_len = strlen(store);
+  if (store_path_len >= STORE_PATH_SIZE)
+    return -ENOENT;
+
+  strncpy(store_path, store, store_path_len);
+  store_path[store_path_len] = '\0';
+  path_set = true;
+
+  return 0;
+}
+
+long
+oc_storage_read(const char *store, uint8_t *buf, size_t size)
+{
+  FILE *fp = 0;
+  size_t store_len = strlen(store);
+
+  if (!path_set || (1 + store_len + store_path_len >= STORE_PATH_SIZE))
+    return -ENOENT;
+
+  store_path[store_path_len] = '/';
+  strncpy(store_path + store_path_len + 1, store, store_len);
+  store_path[1 + store_path_len + store_len] = '\0';
+  fp = fopen(store_path, "rb");
+  if (!fp)
+    return -EINVAL;
+
+  size = fread(buf, 1, size, fp);
+  fclose(fp);
+  return size;
+}
+
+long
+oc_storage_write(const char *store, uint8_t *buf, size_t size)
+{
+  FILE *fp;
+  size_t store_len = strlen(store);
+
+  if (!path_set || (store_len + store_path_len >= STORE_PATH_SIZE))
+    return -ENOENT;
+
+  store_path[store_path_len] = '/';
+  strncpy(store_path + store_path_len + 1, store, store_len);
+  store_path[1 + store_path_len + store_len] = '\0';
+  fp = fopen(store_path, "wb");
+  if (!fp)
+    return -EINVAL;
+
+  size = fwrite(buf, 1, size, fp);
+  fclose(fp);
+  return size;
+}
+#endif /* OC_SECURITY */
diff --git a/port/webos/tcpadapter.c b/port/webos/tcpadapter.c
new file mode 100644
index 00000000..4b6118c0
--- /dev/null
+++ b/port/webos/tcpadapter.c
@@ -0,0 +1,832 @@
+/****************************************************************************
+ *
+ * Copyright 2018 Samsung Electronics All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ ****************************************************************************/
+
+#define __USE_GNU
+
+#include "tcpadapter.h"
+#include "ipcontext.h"
+#include "messaging/coap/coap.h"
+#include "oc_endpoint.h"
+#include "oc_session_events.h"
+#include "port/oc_assert.h"
+#include "util/oc_memb.h"
+#include <arpa/inet.h>
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <ifaddrs.h>
+#include <net/if.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#ifdef OC_TCP
+
+#define OC_TCP_LISTEN_BACKLOG 3
+
+#define TLS_HEADER_SIZE 5
+
+#define DEFAULT_RECEIVE_SIZE                                                   \
+  (COAP_TCP_DEFAULT_HEADER_LEN + COAP_TCP_MAX_EXTENDED_LENGTH_LEN)
+
+#define LIMIT_RETRY_CONNECT 5
+
+#define TCP_CONNECT_TIMEOUT 5
+
+typedef struct tcp_session
+{
+  struct tcp_session *next;
+  ip_context_t *dev;
+  oc_endpoint_t endpoint;
+  int sock;
+  tcp_csm_state_t csm_state;
+} tcp_session_t;
+
+OC_LIST(session_list);
+OC_MEMB(tcp_session_s, tcp_session_t, OC_MAX_TCP_PEERS);
+
+static int
+configure_tcp_socket(int sock, struct sockaddr_storage *sock_info)
+{
+  int reuse = 1;
+  if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse)) == -1) {
+    OC_ERR("setting reuseaddr option %d", errno);
+    return -1;
+  }
+  if (bind(sock, (struct sockaddr *)sock_info, sizeof(*sock_info)) == -1) {
+    OC_ERR("binding socket %d", errno);
+    return -1;
+  }
+  if (listen(sock, OC_TCP_LISTEN_BACKLOG) == -1) {
+    OC_ERR("listening socket %d", errno);
+    return -1;
+  }
+
+  return 0;
+}
+
+static int
+get_assigned_tcp_port(int sock, struct sockaddr_storage *sock_info)
+{
+
+  socklen_t socklen = sizeof(*sock_info);
+  if (getsockname(sock, (struct sockaddr *)sock_info, &socklen) == -1) {
+    OC_ERR("obtaining socket information %d", errno);
+    return -1;
+  }
+
+  return 0;
+}
+
+static int
+get_interface_index(int sock)
+{
+  int interface_index = -1;
+
+  struct sockaddr_storage addr;
+  socklen_t socklen = sizeof(addr);
+  if (getsockname(sock, (struct sockaddr *)&addr, &socklen) == -1) {
+    OC_ERR("obtaining socket information %d", errno);
+    return -1;
+  }
+
+  struct ifaddrs *ifs = NULL, *interface = NULL;
+  if (getifaddrs(&ifs) < 0) {
+    OC_ERR("querying interfaces: %d", errno);
+    return -1;
+  }
+
+  for (interface = ifs; interface != NULL; interface = interface->ifa_next) {
+    if (!(interface->ifa_flags & IFF_UP) || interface->ifa_flags & IFF_LOOPBACK)
+      continue;
+    if (addr.ss_family == interface->ifa_addr->sa_family) {
+      if (addr.ss_family == AF_INET6) {
+        struct sockaddr_in6 *a = (struct sockaddr_in6 *)interface->ifa_addr;
+        struct sockaddr_in6 *b = (struct sockaddr_in6 *)&addr;
+        if (memcmp(a->sin6_addr.s6_addr, b->sin6_addr.s6_addr, 16) == 0) {
+          interface_index = if_nametoindex(interface->ifa_name);
+          break;
+        }
+      }
+#ifdef OC_IPV4
+      else if (addr.ss_family == AF_INET) {
+        struct sockaddr_in *a = (struct sockaddr_in *)interface->ifa_addr;
+        struct sockaddr_in *b = (struct sockaddr_in *)&addr;
+        if (a->sin_addr.s_addr == b->sin_addr.s_addr) {
+          interface_index = if_nametoindex(interface->ifa_name);
+          break;
+        }
+      }
+#endif /* OC_IPV4 */
+    }
+  }
+
+  freeifaddrs(ifs);
+  return interface_index;
+}
+
+void
+oc_tcp_add_socks_to_fd_set(ip_context_t *dev)
+{
+  FD_SET(dev->tcp.server_sock, &dev->rfds);
+#ifdef OC_SECURITY
+  FD_SET(dev->tcp.secure_sock, &dev->rfds);
+#endif /* OC_SECURITY */
+
+#ifdef OC_IPV4
+  FD_SET(dev->tcp.server4_sock, &dev->rfds);
+#ifdef OC_SECURITY
+  FD_SET(dev->tcp.secure4_sock, &dev->rfds);
+#endif /* OC_SECURITY */
+#endif /* OC_IPV4 */
+  FD_SET(dev->tcp.connect_pipe[0], &dev->rfds);
+}
+
+static void
+free_tcp_session(tcp_session_t *session)
+{
+  oc_session_end_event(&session->endpoint);
+
+  FD_CLR(session->sock, &session->dev->rfds);
+
+  ssize_t len = 0;
+  do {
+    uint8_t dummy_value = 0xef;
+    len = write(session->dev->tcp.connect_pipe[1], &dummy_value, 1);
+  } while (len == -1 && errno == EINTR);
+
+  close(session->sock);
+
+  oc_list_remove(session_list, session);
+  oc_memb_free(&tcp_session_s, session);
+
+  OC_DBG("freed TCP session");
+}
+
+static int
+add_new_session(int sock, ip_context_t *dev, oc_endpoint_t *endpoint,
+                tcp_csm_state_t state)
+{
+  tcp_session_t *session = oc_memb_alloc(&tcp_session_s);
+  if (!session) {
+    OC_ERR("could not allocate new TCP session object");
+    return -1;
+  }
+
+  endpoint->interface_index = get_interface_index(sock);
+
+  session->dev = dev;
+  memcpy(&session->endpoint, endpoint, sizeof(oc_endpoint_t));
+  session->endpoint.next = NULL;
+  session->sock = sock;
+  session->csm_state = state;
+
+  oc_list_add(session_list, session);
+
+  if (!(endpoint->flags & SECURED)) {
+    oc_session_start_event((oc_endpoint_t *)endpoint);
+  }
+
+  OC_DBG("recorded new TCP session");
+
+  return 0;
+}
+
+static int
+accept_new_session(ip_context_t *dev, int fd, fd_set *setfds,
+                   oc_endpoint_t *endpoint)
+{
+  struct sockaddr_storage receive_from;
+  socklen_t receive_len = sizeof(receive_from);
+
+  int new_socket = accept(fd, (struct sockaddr *)&receive_from, &receive_len);
+  if (new_socket < 0) {
+    OC_ERR("failed to accept incoming TCP connection");
+    return -1;
+  }
+  OC_DBG("accepted incomming TCP connection");
+
+  if (endpoint->flags & IPV6) {
+    struct sockaddr_in6 *r = (struct sockaddr_in6 *)&receive_from;
+    memcpy(endpoint->addr.ipv6.address, r->sin6_addr.s6_addr,
+           sizeof(r->sin6_addr.s6_addr));
+    endpoint->addr.ipv6.scope = r->sin6_scope_id;
+    endpoint->addr.ipv6.port = ntohs(r->sin6_port);
+#ifdef OC_IPV4
+  } else if (endpoint->flags & IPV4) {
+    struct sockaddr_in *r = (struct sockaddr_in *)&receive_from;
+    memcpy(endpoint->addr.ipv4.address, &r->sin_addr.s_addr,
+           sizeof(r->sin_addr.s_addr));
+    endpoint->addr.ipv4.port = ntohs(r->sin_port);
+#endif /* !OC_IPV4 */
+  }
+
+  FD_CLR(fd, setfds);
+
+  if (add_new_session(new_socket, dev, endpoint, CSM_NONE) < 0) {
+    OC_ERR("could not record new TCP session");
+    close(new_socket);
+    return -1;
+  }
+
+  FD_SET(new_socket, &dev->rfds);
+
+  return 0;
+}
+
+static tcp_session_t *
+find_session_by_endpoint(oc_endpoint_t *endpoint)
+{
+  tcp_session_t *session = oc_list_head(session_list);
+  while (session != NULL &&
+         oc_endpoint_compare(&session->endpoint, endpoint) != 0) {
+    session = session->next;
+  }
+
+  if (!session) {
+#ifdef OC_DEBUG
+    PRINT("could not find ongoing TCP session for endpoint:");
+    PRINTipaddr(*endpoint);
+    PRINT("\n");
+#endif /* OC_DEBUG */
+    return NULL;
+  }
+#ifdef OC_DEBUG
+  PRINT("found TCP session for endpoint:");
+  PRINTipaddr(*endpoint);
+  PRINT("\n");
+#endif /* OC_DEBUG */
+  return session;
+}
+
+static tcp_session_t *
+get_ready_to_read_session(fd_set *setfds)
+{
+  tcp_session_t *session = oc_list_head(session_list);
+  while (session != NULL && !FD_ISSET(session->sock, setfds)) {
+    session = session->next;
+  }
+
+  if (!session) {
+    OC_ERR("could not find any open ready-to-read session");
+    return NULL;
+  }
+  return session;
+}
+
+static size_t
+get_total_length_from_header(oc_message_t *message, oc_endpoint_t *endpoint)
+{
+  size_t total_length = 0;
+  if (endpoint->flags & SECURED) {
+    //[3][4] bytes in tls header are tls payload length
+    total_length =
+      TLS_HEADER_SIZE + (size_t)((message->data[3] << 8) | message->data[4]);
+  } else {
+    total_length = coap_tcp_get_packet_size(message->data);
+  }
+
+  return total_length;
+}
+
+adapter_receive_state_t
+oc_tcp_receive_message(ip_context_t *dev, fd_set *fds, oc_message_t *message)
+{
+  pthread_mutex_lock(&dev->tcp.mutex);
+
+#define ret_with_code(status)                                                  \
+  ret = status;                                                                \
+  goto oc_tcp_receive_message_done
+
+  adapter_receive_state_t ret = ADAPTER_STATUS_ERROR;
+  message->endpoint.device = dev->device;
+
+  if (FD_ISSET(dev->tcp.server_sock, fds)) {
+    message->endpoint.flags = IPV6 | TCP;
+    if (accept_new_session(dev, dev->tcp.server_sock, fds, &message->endpoint) <
+        0) {
+      OC_ERR("accept new session fail");
+      ret_with_code(ADAPTER_STATUS_ERROR);
+    }
+    ret_with_code(ADAPTER_STATUS_ACCEPT);
+#ifdef OC_SECURITY
+  } else if (FD_ISSET(dev->tcp.secure_sock, fds)) {
+    message->endpoint.flags = IPV6 | SECURED | TCP;
+    if (accept_new_session(dev, dev->tcp.secure_sock, fds, &message->endpoint) <
+        0) {
+      OC_ERR("accept new session fail");
+      ret_with_code(ADAPTER_STATUS_ERROR);
+    }
+    ret_with_code(ADAPTER_STATUS_ACCEPT);
+#endif /* OC_SECURITY */
+#ifdef OC_IPV4
+  } else if (FD_ISSET(dev->tcp.server4_sock, fds)) {
+    message->endpoint.flags = IPV4 | TCP;
+    if (accept_new_session(dev, dev->tcp.server4_sock, fds,
+                           &message->endpoint) < 0) {
+      OC_ERR("accept new session fail");
+      ret_with_code(ADAPTER_STATUS_ERROR);
+    }
+    ret_with_code(ADAPTER_STATUS_ACCEPT);
+#ifdef OC_SECURITY
+  } else if (FD_ISSET(dev->tcp.secure4_sock, fds)) {
+    message->endpoint.flags = IPV4 | SECURED | TCP;
+    if (accept_new_session(dev, dev->tcp.secure4_sock, fds,
+                           &message->endpoint) < 0) {
+      OC_ERR("accept new session fail");
+      ret_with_code(ADAPTER_STATUS_ERROR);
+    }
+    ret_with_code(ADAPTER_STATUS_ACCEPT);
+#endif /* OC_SECURITY */
+#endif /* OC_IPV4 */
+  } else if (FD_ISSET(dev->tcp.connect_pipe[0], fds)) {
+    ssize_t len = read(dev->tcp.connect_pipe[0], message->data, OC_PDU_SIZE);
+    if (len < 0) {
+      OC_ERR("read error! %d", errno);
+      ret_with_code(ADAPTER_STATUS_ERROR);
+    }
+    FD_CLR(dev->tcp.connect_pipe[0], fds);
+    ret_with_code(ADAPTER_STATUS_NONE);
+  }
+
+  // find session.
+  tcp_session_t *session = get_ready_to_read_session(fds);
+  if (!session) {
+    OC_DBG("could not find TCP session socket in fd set");
+    ret_with_code(ADAPTER_STATUS_NONE);
+  }
+
+  // receive message.
+  size_t total_length = 0;
+  size_t want_read = DEFAULT_RECEIVE_SIZE;
+  message->length = 0;
+  do {
+    int count =
+      recv(session->sock, message->data + message->length, want_read, 0);
+    if (count < 0) {
+      OC_ERR("recv error! %d", errno);
+
+      free_tcp_session(session);
+
+      ret_with_code(ADAPTER_STATUS_ERROR);
+    } else if (count == 0) {
+      OC_DBG("peer closed TCP session\n");
+
+      free_tcp_session(session);
+
+      ret_with_code(ADAPTER_STATUS_NONE);
+    }
+
+    OC_DBG("recv(): %d bytes.", count);
+    message->length += (size_t)count;
+    want_read -= (size_t)count;
+
+    if (total_length == 0) {
+      total_length = get_total_length_from_header(message, &session->endpoint);
+      if (total_length >
+          (unsigned)(OC_MAX_APP_DATA_SIZE + COAP_MAX_HEADER_SIZE)) {
+        OC_ERR("total receive length(%ld) is bigger than max pdu size(%ld)",
+               total_length, (OC_MAX_APP_DATA_SIZE + COAP_MAX_HEADER_SIZE));
+        OC_ERR("It may occur buffer overflow.");
+        ret_with_code(ADAPTER_STATUS_ERROR);
+      }
+      OC_DBG("tcp packet total length : %ld bytes.", total_length);
+
+      want_read = total_length - (size_t)count;
+    }
+  } while (total_length > message->length);
+
+  memcpy(&message->endpoint, &session->endpoint, sizeof(oc_endpoint_t));
+#ifdef OC_SECURITY
+  if (message->endpoint.flags & SECURED) {
+    message->encrypted = 1;
+  }
+#endif /* OC_SECURITY */
+
+  FD_CLR(session->sock, fds);
+  ret = ADAPTER_STATUS_RECEIVE;
+
+oc_tcp_receive_message_done:
+  pthread_mutex_unlock(&dev->tcp.mutex);
+#undef ret_with_code
+  return ret;
+}
+
+void
+oc_tcp_end_session(ip_context_t *dev, oc_endpoint_t *endpoint)
+{
+  pthread_mutex_lock(&dev->tcp.mutex);
+  tcp_session_t *session = find_session_by_endpoint(endpoint);
+  if (session) {
+    free_tcp_session(session);
+  }
+  pthread_mutex_unlock(&dev->tcp.mutex);
+}
+
+static int
+get_session_socket(oc_endpoint_t *endpoint)
+{
+  int sock = -1;
+  tcp_session_t *session = find_session_by_endpoint(endpoint);
+  if (!session) {
+    return -1;
+  }
+
+  sock = session->sock;
+  return sock;
+}
+
+static int
+connect_nonb(int sockfd, const struct sockaddr *r, int r_len, int nsec)
+{
+  int flags, n, error;
+  socklen_t len;
+  fd_set rset, wset;
+  struct timeval tval;
+
+  flags = fcntl(sockfd, F_GETFL, 0);
+  if (flags < 0) {
+    return -1;
+  }
+
+  error = fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
+  if (error < 0) {
+    return -1;
+  }
+
+  error = 0;
+  if ((n = connect(sockfd, (struct sockaddr *)r, r_len)) < 0) {
+    if (errno != EINPROGRESS)
+      return -1;
+  }
+
+  /* Do whatever we want while the connect is taking place. */
+  if (n == 0) {
+    goto done; /* connect completed immediately */
+  }
+
+  FD_ZERO(&rset);
+  FD_SET(sockfd, &rset);
+  wset = rset;
+  tval.tv_sec = nsec;
+  tval.tv_usec = 0;
+
+  if ((n = select(sockfd + 1, &rset, &wset, NULL, nsec ? &tval : NULL)) == 0) {
+    /* timeout */
+    errno = ETIMEDOUT;
+    return -1;
+  }
+
+  if (FD_ISSET(sockfd, &rset) || FD_ISSET(sockfd, &wset)) {
+    len = sizeof(error);
+    if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &error, &len) < 0)
+      return -1; /* Solaris pending error */
+  } else {
+    OC_DBG("select error: sockfd not set");
+    return -1;
+  }
+
+done:
+  if (error < 0) {
+    close(sockfd); /* just in case */
+    errno = error;
+    return -1;
+  } else {
+    error = fcntl(sockfd, F_SETFL, flags); /* restore file status flags */
+    if (error < 0) {
+      return -1;
+    }
+  }
+  return 0;
+}
+
+static int
+initiate_new_session(ip_context_t *dev, oc_endpoint_t *endpoint,
+                     const struct sockaddr_storage *receiver)
+{
+  int sock = -1;
+  uint8_t retry_cnt = 0;
+
+  while (retry_cnt < LIMIT_RETRY_CONNECT) {
+    if (endpoint->flags & IPV6) {
+      sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
+#ifdef OC_IPV4
+    } else if (endpoint->flags & IPV4) {
+      sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+#endif
+    }
+
+    if (sock < 0) {
+      OC_ERR("could not create socket for new TCP session");
+      return -1;
+    }
+
+    socklen_t receiver_size = sizeof(*receiver);
+    int ret = 0;
+    if ((ret = connect_nonb(sock, (struct sockaddr *)receiver, receiver_size,
+                            TCP_CONNECT_TIMEOUT)) == 0) {
+      break;
+    }
+
+    close(sock);
+    retry_cnt++;
+    OC_DBG("connect fail with %d. retry(%d)", ret, retry_cnt);
+  }
+
+  if (retry_cnt >= LIMIT_RETRY_CONNECT) {
+    OC_ERR("could not initiate TCP connection");
+    return -1;
+  }
+
+  OC_DBG("successfully initiated TCP connection");
+
+  if (add_new_session(sock, dev, endpoint, CSM_SENT) < 0) {
+    OC_ERR("could not record new TCP session");
+    close(sock);
+    return -1;
+  }
+
+  FD_SET(sock, &dev->rfds);
+
+  ssize_t len = 0;
+  do {
+    uint8_t dummy_value = 0xef;
+    len = write(dev->tcp.connect_pipe[1], &dummy_value, 1);
+  } while (len == -1 && errno == EINTR);
+
+  OC_DBG("signaled network event thread to monitor the newly added session\n");
+
+  return sock;
+}
+
+int
+oc_tcp_send_buffer(ip_context_t *dev, oc_message_t *message,
+                   const struct sockaddr_storage *receiver)
+{
+  pthread_mutex_lock(&dev->tcp.mutex);
+  int send_sock = get_session_socket(&message->endpoint);
+
+  size_t bytes_sent = 0;
+  if (send_sock < 0) {
+    if ((send_sock = initiate_new_session(dev, &message->endpoint, receiver)) <
+        0) {
+      OC_ERR("could not initiate new TCP session");
+      goto oc_tcp_send_buffer_done;
+    }
+  }
+
+  do {
+    ssize_t send_len = send(send_sock, message->data + bytes_sent,
+                            message->length - bytes_sent, 0);
+    if (send_len < 0) {
+      OC_WRN("send() returned errno %d", errno);
+      goto oc_tcp_send_buffer_done;
+    }
+    bytes_sent += send_len;
+  } while (bytes_sent < message->length);
+
+  OC_DBG("Sent %d bytes", bytes_sent);
+oc_tcp_send_buffer_done:
+  pthread_mutex_unlock(&dev->tcp.mutex);
+
+  if (bytes_sent == 0) {
+    return -1;
+  }
+
+  return bytes_sent;
+}
+
+#ifdef OC_IPV4
+static int
+tcp_connectivity_ipv4_init(ip_context_t *dev)
+{
+  OC_DBG("Initializing TCP adapter IPv4 for device %d", dev->device);
+
+  memset(&dev->tcp.server4, 0, sizeof(struct sockaddr_storage));
+  struct sockaddr_in *l = (struct sockaddr_in *)&dev->tcp.server4;
+  l->sin_family = AF_INET;
+  l->sin_addr.s_addr = INADDR_ANY;
+  l->sin_port = 0;
+
+#ifdef OC_SECURITY
+  memset(&dev->tcp.secure4, 0, sizeof(struct sockaddr_storage));
+  struct sockaddr_in *sm = (struct sockaddr_in *)&dev->tcp.secure4;
+  sm->sin_family = AF_INET;
+  sm->sin_addr.s_addr = INADDR_ANY;
+  sm->sin_port = 0;
+#endif /* OC_SECURITY */
+
+  dev->tcp.server4_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+
+  if (dev->tcp.server4_sock < 0) {
+    OC_ERR("creating TCP server socket");
+    return -1;
+  }
+
+#ifdef OC_SECURITY
+  dev->tcp.secure4_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+  if (dev->tcp.secure4_sock < 0) {
+    OC_ERR("creating TCP secure socket");
+    return -1;
+  }
+#endif /* OC_SECURITY */
+
+  if (configure_tcp_socket(dev->tcp.server4_sock, &dev->tcp.server4) < 0) {
+    OC_ERR("set socket option in server socket");
+    return -1;
+  }
+
+  if (get_assigned_tcp_port(dev->tcp.server4_sock, &dev->tcp.server4) < 0) {
+    OC_ERR("get port for server socket");
+    return -1;
+  }
+  dev->tcp.port4 = ntohs(((struct sockaddr_in *)&dev->tcp.server4)->sin_port);
+
+#ifdef OC_SECURITY
+  if (configure_tcp_socket(dev->tcp.secure4_sock, &dev->tcp.secure4) < 0) {
+    OC_ERR("set socket option in secure socket");
+    return -1;
+  }
+
+  if (get_assigned_tcp_port(dev->tcp.secure4_sock, &dev->tcp.secure4) < 0) {
+    OC_ERR("get port for secure socket");
+    return -1;
+  }
+  dev->tcp.tls4_port =
+    ntohs(((struct sockaddr_in *)&dev->tcp.secure4)->sin_port);
+#endif /* OC_SECURITY */
+
+  OC_DBG("Successfully initialized TCP adapter IPv4 for device %d",
+         dev->device);
+
+  return 0;
+}
+#endif /* OC_IPV4 */
+
+int
+oc_tcp_connectivity_init(ip_context_t *dev)
+{
+  OC_DBG("Initializing TCP adapter for device %d", dev->device);
+
+  if (pthread_mutex_init(&dev->tcp.mutex, NULL) != 0) {
+    oc_abort("error initializing TCP adapter mutex");
+  }
+
+  memset(&dev->tcp.server, 0, sizeof(struct sockaddr_storage));
+  struct sockaddr_in6 *l = (struct sockaddr_in6 *)&dev->tcp.server;
+  l->sin6_family = AF_INET6;
+  l->sin6_addr = in6addr_any;
+  l->sin6_port = 0;
+
+#ifdef OC_SECURITY
+  memset(&dev->tcp.secure, 0, sizeof(struct sockaddr_storage));
+  struct sockaddr_in6 *sm = (struct sockaddr_in6 *)&dev->tcp.secure;
+  sm->sin6_family = AF_INET6;
+  sm->sin6_addr = in6addr_any;
+  sm->sin6_port = 0;
+#endif /* OC_SECURITY */
+
+  dev->tcp.server_sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
+
+  if (dev->tcp.server_sock < 0) {
+    OC_ERR("creating TCP server socket");
+    return -1;
+  }
+
+#ifdef OC_SECURITY
+  dev->tcp.secure_sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
+  if (dev->tcp.secure_sock < 0) {
+    OC_ERR("creating TCP secure socket");
+    return -1;
+  }
+#endif /* OC_SECURITY */
+
+  if (configure_tcp_socket(dev->tcp.server_sock, &dev->tcp.server) < 0) {
+    OC_ERR("set socket option in server socket");
+    return -1;
+  }
+
+  if (get_assigned_tcp_port(dev->tcp.server_sock, &dev->tcp.server) < 0) {
+    OC_ERR("get port for server socket");
+    return -1;
+  }
+  dev->tcp.port = ntohs(((struct sockaddr_in *)&dev->tcp.server)->sin_port);
+
+#ifdef OC_SECURITY
+  if (configure_tcp_socket(dev->tcp.secure_sock, &dev->tcp.secure) < 0) {
+    OC_ERR("set socket option in secure socket");
+    return -1;
+  }
+
+  if (get_assigned_tcp_port(dev->tcp.secure_sock, &dev->tcp.secure) < 0) {
+    OC_ERR("get port for secure socket");
+    return -1;
+  }
+  dev->tcp.tls_port = ntohs(((struct sockaddr_in *)&dev->tcp.secure)->sin_port);
+#endif /* OC_SECURITY */
+
+#ifdef OC_IPV4
+  if (tcp_connectivity_ipv4_init(dev) != 0) {
+    OC_ERR("Could not initialize IPv4 for TCP");
+  }
+#endif /* OC_IPV4 */
+
+  if (pipe(dev->tcp.connect_pipe) < 0) {
+    OC_ERR("Could not initialize connection pipe");
+  }
+
+  OC_DBG("=======tcp port info.========");
+  OC_DBG("  ipv6 port   : %u", dev->tcp.port);
+#ifdef OC_SECURITY
+  OC_DBG("  ipv6 secure : %u", dev->tcp.tls_port);
+#endif
+#ifdef OC_IPV4
+  OC_DBG("  ipv4 port   : %u", dev->tcp.port4);
+#ifdef OC_SECURITY
+  OC_DBG("  ipv4 secure : %u", dev->tcp.tls4_port);
+#endif
+#endif
+
+  OC_DBG("Successfully initialized TCP adapter for device %d", dev->device);
+
+  return 0;
+}
+
+void
+oc_tcp_connectivity_shutdown(ip_context_t *dev)
+{
+  close(dev->tcp.server_sock);
+
+#ifdef OC_IPV4
+  close(dev->tcp.server4_sock);
+#endif /* OC_IPV4 */
+
+#ifdef OC_SECURITY
+  close(dev->tcp.secure_sock);
+#ifdef OC_IPV4
+  close(dev->tcp.secure4_sock);
+#endif /* OC_IPV4 */
+#endif /* OC_SECURITY */
+
+  close(dev->tcp.connect_pipe[0]);
+  close(dev->tcp.connect_pipe[1]);
+
+  tcp_session_t *session = (tcp_session_t *)oc_list_head(session_list), *next;
+  while (session != NULL) {
+    next = session->next;
+    if (session->endpoint.device == dev->device) {
+      free_tcp_session(session);
+    }
+    session = next;
+  }
+
+  pthread_mutex_destroy(&dev->tcp.mutex);
+
+  OC_DBG("oc_tcp_connectivity_shutdown for device %d", dev->device);
+}
+
+tcp_csm_state_t
+oc_tcp_get_csm_state(oc_endpoint_t *endpoint)
+{
+  if (!endpoint) {
+    return CSM_ERROR;
+  }
+
+  tcp_session_t *session = find_session_by_endpoint(endpoint);
+  if (!session) {
+    return CSM_NONE;
+  }
+
+  return session->csm_state;
+}
+
+int
+oc_tcp_update_csm_state(oc_endpoint_t *endpoint, tcp_csm_state_t csm)
+{
+  if (!endpoint) {
+    return -1;
+  }
+
+  tcp_session_t *session = find_session_by_endpoint(endpoint);
+  if (!session) {
+    return -1;
+  }
+
+  session->csm_state = csm;
+  return 0;
+}
+#endif /* OC_TCP */
diff --git a/port/webos/tcpadapter.h b/port/webos/tcpadapter.h
new file mode 100644
index 00000000..91d24ea0
--- /dev/null
+++ b/port/webos/tcpadapter.h
@@ -0,0 +1,52 @@
+/****************************************************************************
+ *
+ * Copyright 2018 Samsung Electronics All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ ****************************************************************************/
+
+
+#ifndef TCP_ADAPTER_H
+#define TCP_ADAPTER_H
+
+#include "ipcontext.h"
+#include "port/oc_connectivity.h"
+#include <sys/select.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+int oc_tcp_connectivity_init(ip_context_t *dev);
+
+void oc_tcp_connectivity_shutdown(ip_context_t *dev);
+
+int oc_tcp_send_buffer(ip_context_t *dev, oc_message_t *message,
+                       const struct sockaddr_storage *receiver);
+
+void oc_tcp_add_socks_to_fd_set(ip_context_t *dev);
+
+void oc_tcp_set_session_fds(fd_set *fds);
+
+adapter_receive_state_t oc_tcp_receive_message(ip_context_t *dev, fd_set *fds,
+                                               oc_message_t *message);
+
+void oc_tcp_end_session(ip_context_t *dev, oc_endpoint_t *endpoint);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* TCP_ADAPTER_H */
-- 
2.16.1.windows.1

