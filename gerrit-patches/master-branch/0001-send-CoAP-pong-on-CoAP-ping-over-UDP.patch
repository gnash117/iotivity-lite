From 90a8afbaf5eb0ef5cd4b0332d00d1710259491d1 Mon Sep 17 00:00:00 2001
From: Jozef Kralik <jojo.lwin@gmail.com>
Date: Mon, 19 Aug 2019 20:40:29 +0200
Subject: [PATCH] send "CoAP pong" on "CoAP ping" over UDP

RFC-7252: Reset Message
A Reset message indicates that a specific message (Confirmable or
Non-confirmable) was received, but some context is missing to
properly process it.  This condition is usually caused when the
receiving node has rebooted and has forgotten some state that
would be required to interpret the message.  Provoking a Reset
message (e.g., by sending an Empty Confirmable message) is also
useful as an inexpensive check of the liveness of an endpoint
("CoAP ping").

Change-Id: I69b8fb0ac8d051c4141ab640a933f543d3cfed93
Signed-off-by: Jozef Kralik <jojo.lwin@gmail.com>
---
 messaging/coap/constants.h |  2 +-
 messaging/coap/engine.c    | 30 +++++++++++++++++-------------
 2 files changed, 18 insertions(+), 14 deletions(-)

diff --git a/messaging/coap/constants.h b/messaging/coap/constants.h
index 512455b3..e5836e92 100644
--- a/messaging/coap/constants.h
+++ b/messaging/coap/constants.h
@@ -116,7 +116,7 @@ typedef enum {
 } coap_message_type_t;
 
 /* CoAP request method codes */
-typedef enum { COAP_GET = 1, COAP_POST, COAP_PUT, COAP_DELETE } coap_method_t;
+typedef enum { COAP_EMPTY, COAP_GET, COAP_POST, COAP_PUT, COAP_DELETE } coap_method_t;
 
 /* CoAP response codes */
 typedef enum {
diff --git a/messaging/coap/engine.c b/messaging/coap/engine.c
index f2cba06b..9077570a 100644
--- a/messaging/coap/engine.c
+++ b/messaging/coap/engine.c
@@ -98,20 +98,20 @@ check_if_duplicate(uint16_t mid, uint8_t device)
 }
 
 static void
-coap_send_empty_ack(uint16_t mid, oc_endpoint_t *endpoint)
+coap_send_empty_reponse(coap_message_type_t type, uint16_t mid, oc_endpoint_t *endpoint)
 {
-  coap_packet_t ack[1];
-  coap_udp_init_message(ack, COAP_TYPE_ACK, 0, mid);
-  oc_message_t *ack_message = oc_internal_allocate_outgoing_message();
-  if (ack_message) {
-    memcpy(&ack_message->endpoint, endpoint, sizeof(*endpoint));
-    size_t len = coap_serialize_message(ack, ack_message->data);
+  coap_packet_t resp[1];
+  coap_udp_init_message(resp, type, 0, mid);
+  oc_message_t *resp_message = oc_internal_allocate_outgoing_message();
+  if (resp_message) {
+    memcpy(&resp_message->endpoint, endpoint, sizeof(*endpoint));
+    size_t len = coap_serialize_message(resp, resp_message->data);
     if (len > 0) {
-      ack_message->length = len;
-      coap_send_message(ack_message);
+      resp_message->length = len;
+      coap_send_message(resp_message);
     }
-    if (ack_message->ref_count == 0) {
-      oc_message_unref(ack_message);
+    if (resp_message->ref_count == 0) {
+      oc_message_unref(resp_message);
     }
   }
 }
@@ -472,7 +472,7 @@ coap_receive(oc_message_t *msg)
             response_buffer->ref_count = 0;
         }
 #endif /* OC_BLOCK_WISE */
-        if (response->code != 0) {
+        if (response->code != COAP_EMPTY) {
           goto send_message;
         }
       }
@@ -496,7 +496,11 @@ coap_receive(oc_message_t *msg)
 #endif /* OC_CLIENT */
 
       if (message->type == COAP_TYPE_CON) {
-        coap_send_empty_ack(message->mid, &msg->endpoint);
+        coap_message_type_t type = COAP_TYPE_ACK;
+        if (message->code == COAP_EMPTY) {
+          type = COAP_TYPE_RST;
+        }
+        coap_send_empty_reponse(type, message->mid, &msg->endpoint);
       } else if (message->type == COAP_TYPE_ACK) {
       } else if (message->type == COAP_TYPE_RST) {
 #ifdef OC_SERVER
-- 
2.16.1.windows.1

