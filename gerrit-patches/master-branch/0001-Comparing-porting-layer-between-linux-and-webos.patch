From 9169badc68ff55a7eb8e9de043f5f40433a80ea0 Mon Sep 17 00:00:00 2001
From: "sungmok.shin" <sungmok.shin@lge.com>
Date: Tue, 14 May 2019 11:42:24 +0900
Subject: [PATCH] Comparing porting layer between linux and webos

Change-Id: I274f9e983217f7a2c5f38b3fc684cfaacc156634
Signed-off-by: sungmok.shin <sungmok.shin@lge.com>
---
 apps/simpleserver.c    |  70 +++++++++--
 port/linux/Makefile    |   9 +-
 port/linux/ipadapter.c | 331 +++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 395 insertions(+), 15 deletions(-)

diff --git a/apps/simpleserver.c b/apps/simpleserver.c
index 42d70d7d..14dcc66b 100644
--- a/apps/simpleserver.c
+++ b/apps/simpleserver.c
@@ -20,6 +20,17 @@
 #include <signal.h>
 #include <stdio.h>
 
+#include <luna-service2/lunaservice.h>
+#include <glib.h>
+#include <pbnjson.h>
+#include <PmLogLib.h>
+
+static LSHandle *pLsHandle = NULL;
+static GMainLoop *mainloop = NULL;
+
+PmLogContext gLogContext;
+PmLogContext gLogLibContext;
+
 pthread_mutex_t mutex;
 pthread_cond_t cv;
 struct timespec ts;
@@ -33,10 +44,10 @@ oc_string_t name;
 static int
 app_init(void)
 {
-  int ret = oc_init_platform("Intel", NULL, NULL);
-  ret |= oc_add_device("/oic/d", "oic.d.light", "Lamp", "ocf.1.0.0",
-                       "ocf.res.1.0.0", NULL, NULL);
-  oc_new_string(&name, "John's Light", 12);
+  int ret = oc_init_platform("webOS", NULL, NULL);
+  ret |= oc_add_device("/oic/d", "oic.d.light", "webOS Light", "ocf.2.0.0",
+                       "ocf.res.1.3.0,ocf.sh.1.3.0", NULL, NULL);
+  oc_new_string(&name, "webOS Light", 11);
   return ret;
 }
 
@@ -53,9 +64,12 @@ get_light(oc_request_t *request, oc_interface_mask_t iface_mask, void *user_data
     oc_process_baseline_interface(request->resource);
   /* fall through */
   case OC_IF_RW:
-    oc_rep_set_boolean(root, state, state);
-    oc_rep_set_int(root, power, power);
-    oc_rep_set_text_string(root, name, oc_string(name));
+    oc_rep_set_boolean(root, value, state);
+    oc_rep_set_text_string(root, n, oc_string(name));
+    break;
+  case OC_IF_A:
+    oc_rep_set_boolean(root, value, state);
+    oc_rep_set_text_string(root, n, oc_string(name));
     break;
   default:
     break;
@@ -109,16 +123,17 @@ put_light(oc_request_t *request, oc_interface_mask_t iface_mask,
 static void
 register_resources(void)
 {
-  oc_resource_t *res = oc_new_resource(NULL, "/a/light", 2, 0);
-  oc_resource_bind_resource_type(res, "core.light");
-  oc_resource_bind_resource_type(res, "core.brightlight");
-  oc_resource_bind_resource_interface(res, OC_IF_RW);
-  oc_resource_set_default_interface(res, OC_IF_RW);
+  oc_resource_t *res = oc_new_resource("webOS", "/binaryswitch", 1, 0);
+  oc_resource_bind_resource_type(res, "oic.r.switch.binary");
+  oc_resource_bind_resource_interface(res, OC_IF_BASELINE);
+  oc_resource_bind_resource_interface(res, OC_IF_A);
+  oc_resource_set_default_interface(res, OC_IF_A);
   oc_resource_set_discoverable(res, true);
   oc_resource_set_periodic_observable(res, 1);
   oc_resource_set_request_handler(res, OC_GET, get_light, NULL);
   oc_resource_set_request_handler(res, OC_PUT, put_light, NULL);
   oc_resource_set_request_handler(res, OC_POST, post_light, NULL);
+  oc_set_con_res_announced(false);
   oc_add_resource(res);
 }
 
@@ -126,6 +141,7 @@ static void
 signal_event_loop(void)
 {
   pthread_mutex_lock(&mutex);
+  PRINT("pthread_cond_signal\n");
   pthread_cond_signal(&cv);
   pthread_mutex_unlock(&mutex);
 }
@@ -135,12 +151,42 @@ handle_signal(int signal)
 {
   (void)signal;
   signal_event_loop();
+  PRINT("handle_signal\n");
   quit = 1;
 }
 
 int
 main(void)
 {
+    struct timespec timeout;
+    LSError lserror;
+    LSErrorInit(&lserror);
+    (void) PmLogGetContext("IOTIVITY-LITE", &gLogContext);
+    (void) PmLogGetContext("IOTIVITY_LITE-LIB", &gLogLibContext);
+    PmLogSetLibContext(gLogLibContext);
+
+    mainloop = g_main_loop_new(NULL, FALSE);
+
+    // Initialize g_main_loop
+    if (!mainloop) {
+        PRINT("Failed to create main loop");
+        return 0;
+    }
+
+    PRINT("simpleserver is starting...\n");
+
+    if (!LSRegister("org.ocf.webossample.simpleserver", &pLsHandle, &lserror)) {
+        PRINT("Failed to register LS Handle");
+        LSErrorLog(gLogContext, "LS_SRVC_ERROR", &lserror);
+        return 0;
+    }
+
+    if (!LSGmainAttach(pLsHandle, mainloop, &lserror)) {
+        PRINT("Failed to attach main loop: %s", &lserror);
+        LSErrorLog(gLogContext, "LS_SRVC_ATTACH_ERROR", &lserror);
+        return 0;
+    }
+
   int init;
   struct sigaction sa;
   sigfillset(&sa.sa_mask);
diff --git a/port/linux/Makefile b/port/linux/Makefile
index 6af83fd4..223b99cd 100644
--- a/port/linux/Makefile
+++ b/port/linux/Makefile
@@ -1,7 +1,7 @@
 CC = gcc
 SED = sed
 INSTALL = install
-OS = linux
+OS = webos
 ROOT_DIR = ../..
 OUT_DIR = $(ROOT_DIR)/port/$(OS)
 CHECK_SCRIPT = ../../tools/check.py
@@ -88,13 +88,13 @@ HEADERS_UTIL_PT = $(wildcard ../../util/pt/*.h)
 HEADERS_PORT = $(wildcard ../../port/*.h)
 HEADERS_TINYCBOR = $(wildcard ../../deps/tinycbor/src/*.h)
 
-CFLAGS=-fPIC -fno-asynchronous-unwind-tables -fno-omit-frame-pointer -ffreestanding -Os -fno-stack-protector -ffunction-sections -fdata-sections -fno-reorder-functions -fno-defer-pop -fno-strict-overflow -I./ -I../../include/ -I../../ -std=gnu99 -Wall -Wextra -Werror -pedantic #-Wl,-Map,client.map
+CFLAGS=-fPIC -fno-asynchronous-unwind-tables -fno-omit-frame-pointer -ffreestanding -Os -fno-stack-protector -ffunction-sections -fdata-sections -fno-reorder-functions -fno-defer-pop -fno-strict-overflow -I./ -I../../include/ -I../../ -std=gnu99 -Wall -Wextra -pedantic #-Wl,-Map,client.map
 OBJ_COMMON=$(addprefix obj/,$(notdir $(SRC_COMMON:.c=.o)))
 OBJ_CLIENT=$(addprefix obj/client/,$(notdir $(SRC:.c=.o)))
 OBJ_SERVER=$(addprefix obj/server/,$(filter-out oc_obt.o oc_obt_otm_justworks.o oc_obt_otm_randompin.o,$(notdir $(SRC:.c=.o))))
 OBJ_CLIENT_SERVER=$(addprefix obj/client_server/,$(notdir $(SRC:.c=.o)))
 VPATH=../../messaging/coap/:../../util/:../../api/:../../deps/tinycbor/src/:../../deps/mbedtls/library:../../api/c-timestamp:
-LIBS?= -lm -pthread -lrt
+LIBS?= -lm -pthread -lrt -lluna-service2 -lglib-2.0 -lpbnjson_c -lPmLogLib
 
 SAMPLES = server client temp_sensor simpleserver simpleserver_pki simpleclient client_collections_linux \
 	  server_collections_linux server_block_linux client_block_linux smart_home_server_linux multi_device_server multi_device_client smart_lock server_multithread_linux client_multithread_linux
@@ -133,6 +133,9 @@ endif
 	VPATH += ../../security/:../../deps/mbedtls/library:
 endif
 
+LUNA_HEADERS = -I$(PKG_SYS_ROOT)/usr/include -I$(PKG_SYS_ROOT)/usr/include/glib-2.0 -I$(PKG_SYS_ROOT)/usr/lib/glib-2.0/include
+CFLAGS += $(LUNA_HEADERS)
+
 ifeq ($(IPV4),1)
 	EXTRA_CFLAGS += -DOC_IPV4
 endif
diff --git a/port/linux/ipadapter.c b/port/linux/ipadapter.c
index e2e1d889..a259df61 100644
--- a/port/linux/ipadapter.c
+++ b/port/linux/ipadapter.c
@@ -41,6 +41,12 @@
 #include <sys/un.h>
 #include <unistd.h>
 
+#ifdef OC_NETWORK_MONITOR_WEBOS
+#include <luna-service2/lunaservice.h>
+#include <glib.h>
+#include <pbnjson.h>
+#endif /* OC_NETWORK_MONITOR_WEBOS */
+
 /* Some outdated toolchains do not define IFA_FLAGS.
    Note: Requires Linux kernel 3.14 or later. */
 #ifndef IFA_FLAGS
@@ -69,6 +75,321 @@ OC_MEMB(ip_context_s, ip_context_t, OC_MAX_NUM_DEVICES);
 
 OC_MEMB(device_eps, oc_endpoint_t, 8 * OC_MAX_NUM_DEVICES); // fix
 
+#ifdef OC_NETWORK_MONITOR_WEBOS
+
+typedef struct _CONNECTION_STATUS {
+    bool isConnectWired;
+    bool isConnectWiFi;
+} CONNECTION_STATUS_T;
+
+CONNECTION_STATUS_T gConnectionStates;
+
+
+#define LS_CONNECTIONMANAGER_GETSTATUS_URI "luna://com.webos.service.connectionmanager/getstatus"
+#define MAX_LS_NAME_SIZE 1024
+#define MAX_GET_LS_SERVICE_NAME_COUNT 5
+static LSHandle *g_pLSHandle = NULL;
+static GMainContext *g_loopContext = NULL;
+static GMainLoop *g_mainLoop = NULL;
+static bool g_isLSRegistering = false;
+char *g_lsServiceName = NULL;
+
+pthread_t threadId_monitor;
+
+static bool CACheckLSRegistered()
+{
+    if (g_pLSHandle)
+    {
+        OC_DBG("Luna service is already registered");
+        return true;
+    }
+    else
+    {
+        OC_DBG("Luna service is not registered");
+        return false;
+    }
+}
+
+static bool CACreateLSServiceName()
+{
+    FILE *fp = NULL;
+    char processNameBuff[MAX_LS_NAME_SIZE];
+    char lunaServiceBuff[MAX_LS_NAME_SIZE];
+    size_t readSize = 0;
+    char *command = NULL;
+
+    command = g_strdup_printf("ps -p %d -f | sed -n '2p' | awk '{print $8}' | cut -d '/' -f2", getpid());
+
+    fp = popen(command, "r");
+    if (NULL == fp)
+    {
+        OC_DBG("Failed to open ls-monitor");
+        exit(1);
+    }
+
+    readSize = fread((void*)processNameBuff, sizeof(char), MAX_LS_NAME_SIZE - 1, fp);
+    OC_DBG("processNameBuff : %s, readSize: %d", processNameBuff, readSize);
+
+    processNameBuff[readSize]='0';
+    command = g_strdup_printf("find /usr/share/luna-service2/services.d/ -name \"*.*\" | /usr/bin/xargs grep %s | grep 'Name' | cut -d '=' -f2 | cut -d '*' -f1", g_strndup(processNameBuff, readSize-1));
+
+    OC_DBG("PID : %d", getpid());
+
+    // Get service Name by pid
+    fp = popen(command, "r");
+    if (NULL == fp)
+    {
+        OC_DBG("Failed to open ls-monitor");
+        exit(1);
+    }
+
+    readSize = fread((void*)lunaServiceBuff, sizeof(char), MAX_LS_NAME_SIZE - 1, fp);
+    OC_DBG("lunaServiceBuff : %s, readSize: %d", lunaServiceBuff, readSize);
+    if (0 == readSize)
+    {
+        OC_DBG("This process does not have Luna service");
+        g_free(command);
+        pclose(fp);
+        return false;
+    }
+    lunaServiceBuff[readSize]='0';
+
+    g_lsServiceName = g_strdup_printf("%s-iotivity%d", g_strndup(lunaServiceBuff, readSize-1), getpid());
+
+    pclose( fp);
+
+    return true;
+}
+
+static void CATriggerCreateLSServiceName()
+{
+    for (int i = 0; i < MAX_GET_LS_SERVICE_NAME_COUNT; i++)
+    {
+        if (CACreateLSServiceName())
+        {
+            OC_DBG("Luna service name : %s", g_lsServiceName);
+            break;
+        }
+
+        sleep(1);
+    }
+}
+
+static void *CAStartLSMainLoop(gpointer user_data)
+{
+    //(void)data;
+
+    OC_DBG("CAStartLSMainLoop");
+
+    LSError lserror;
+    LSErrorInit(&lserror);
+
+
+    g_isLSRegistering = true;
+    OC_DBG("CAStartLSMainLoop Break 1");
+    if (g_lsServiceName == NULL)
+    {
+        OC_DBG("Failed to create Luna service name");
+        return;
+    }
+
+    g_loopContext = g_main_context_new();
+    g_mainLoop = g_main_loop_new(g_loopContext, FALSE);
+    g_main_context_push_thread_default(g_loopContext);
+
+    if (!g_mainLoop)
+    {
+        OC_DBG("Failed to create main loop");
+        return;
+    }
+
+    if (!LSRegister(g_lsServiceName, &g_pLSHandle, &lserror))
+    {
+        OC_DBG("Failed to register LS Handle");
+        return;
+    }
+
+    if (!LSGmainAttach(g_pLSHandle, g_mainLoop, &lserror))
+    {
+        OC_DBG("Failed to attach main loop");
+        return;
+    }
+
+    g_isLSRegistering = false;
+    g_main_loop_run(g_mainLoop);
+
+    g_main_context_unref(g_loopContext);
+    g_main_loop_unref(g_mainLoop);
+}
+
+LSHandle* CAGetLSHandle()
+{
+    OC_DBG("CAGetLSHandle");
+    return g_pLSHandle;
+}
+
+/**
+ * Get connection status callback.
+ */
+static bool get_connection_status_cb(LSHandle *sh, LSMessage *message, void *ctx)
+{
+    OC_DBG("Callback for com.webos.service.connectionmanager/getstatus is invoked...");
+
+    //OC_UNUSED(sh);
+    //OC_UNUSED(ctx);
+
+    jvalue_ref parsedObj = {0};
+    jschema_ref input_schema = jschema_parse(j_cstr_to_buffer("{}"), DOMOPT_NOOPT, NULL);
+
+    if (!input_schema)
+        return false;
+
+    JSchemaInfo schemaInfo;
+    jschema_info_init(&schemaInfo, input_schema, NULL, NULL);
+    parsedObj = jdom_parse(j_cstr_to_buffer(LSMessageGetPayload(message)), DOMOPT_NOOPT, &schemaInfo);
+    jschema_release(&input_schema);
+
+    if (jis_null(parsedObj))
+        return true;
+
+    const char *payload = jvalue_tostring(parsedObj, input_schema);
+
+    OC_DBG("Paylod: %s", payload);
+    jvalue_ref wiredObj={0}, wifiObj ={0}, wiredStateObj={0}, wifiStateObj={0};
+
+    if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("wired"), &wiredObj))
+    {
+        if (jobject_get_exists(wiredObj, J_CSTR_TO_BUF("state"), &wiredStateObj))
+        {
+            if (jstring_equal2(wiredStateObj, J_CSTR_TO_BUF("connected")) && !gConnectionStates.isConnectWired)
+            {
+                gConnectionStates.isConnectWired = true;
+                //CAIPPassNetworkChangesToAdapter(CA_INTERFACE_UP);
+                oc_network_interface_event(NETWORK_INTERFACE_UP);
+                OC_DBG("Wired LAN is connected...");
+            }
+            else if (jstring_equal2(wiredStateObj, J_CSTR_TO_BUF("disconnected")) && gConnectionStates.isConnectWired)
+            {
+                gConnectionStates.isConnectWired = false;
+                //CAIPPassNetworkChangesToAdapter(CA_INTERFACE_DOWN);
+                oc_network_interface_event(NETWORK_INTERFACE_DOWN);
+                OC_DBG("Wired LAN is disconnected...");
+            }
+        }
+    }
+
+    if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("wifi"), &wifiObj))
+    {
+        if (jobject_get_exists(wifiObj, J_CSTR_TO_BUF("state"), &wifiStateObj))
+        {
+            if (jstring_equal2(wifiStateObj, J_CSTR_TO_BUF("connected")) && !gConnectionStates.isConnectWiFi)
+            {
+                gConnectionStates.isConnectWiFi = true;
+                //CAIPPassNetworkChangesToAdapter(CA_INTERFACE_UP);
+                oc_network_interface_event(NETWORK_INTERFACE_UP);
+                OC_DBG("Wi-Fi is connected...");
+            }
+            else if (jstring_equal2(wifiStateObj, J_CSTR_TO_BUF("disconnected")) && gConnectionStates.isConnectWiFi)
+            {
+                gConnectionStates.isConnectWiFi = false;
+                //CAIPPassNetworkChangesToAdapter(CA_INTERFACE_DOWN);
+                oc_network_interface_event(NETWORK_INTERFACE_DOWN);
+                OC_DBG("Wi-Fi is disconnected...");
+            }
+        }
+    }
+
+    return true;
+}
+
+static void CANetworkMonitorHandler()
+{
+    OC_DBG("CANetworkMonitorHandler");
+    LSError lserror;
+    LSErrorInit(&lserror);
+
+    if (!CAGetLSHandle())
+    {
+        OC_DBG("Luna service handle is null");
+        exit(1);
+    }
+
+    if(!LSCall(CAGetLSHandle(), LS_CONNECTIONMANAGER_GETSTATUS_URI,
+                            "{\"subscribe\":true}",
+                            get_connection_status_cb, NULL, NULL, &lserror))
+    {
+        OC_DBG("com.webos.service.connectionmanager/getstatus failed");
+        LSErrorPrint(&lserror, stderr);
+    }
+    else
+    {
+        OC_DBG("com.webos.service.connectionmanager/getstatus succeeds");
+    }
+}
+
+bool CAInitializeLS(void)
+{
+    OC_DBG("CAInitializeLS");
+
+    bool result = false;
+
+    if (CACheckLSRegistered())
+       return true;
+
+    if (g_isLSRegistering)
+    {
+        OC_DBG("Wait for registering LS service");
+        sleep(1);
+    }
+
+    CATriggerCreateLSServiceName();
+
+    result = pthread_create(&threadId_monitor, NULL, CAStartLSMainLoop, (void *)NULL);
+    if (result)
+    {
+        OC_DBG("LS thread_pool_add_task failed");
+        return result;
+    }
+
+    for (int i = 0; i < MAX_GET_LS_SERVICE_NAME_COUNT; i++)
+    {
+        if (CACheckLSRegistered())
+        {
+            result = true;
+            break;
+        }
+        else
+        {
+            sleep(1);
+            result = false;
+        }
+    }
+    return result;
+}
+
+void CATerminateLS()
+{
+    OC_DBG("CATerminateLS");
+    LSError lserror;
+    LSErrorInit(&lserror);
+
+    if (g_pLSHandle)
+    {
+        OC_DBG("g_pLSHandle is not null");
+        if (!LSUnregister(g_pLSHandle, &lserror))
+        {
+            OC_DBG("Failed to unregister Luna service");
+            LSErrorPrint(&lserror, stderr);
+            LSErrorFree(&lserror);
+        }
+        g_pLSHandle = NULL;
+    }
+
+    g_main_loop_quit(g_mainLoop);
+}
+
+#endif /* OC_NETWORK_MONITOR_WEBOS */
+
 #ifdef OC_NETWORK_MONITOR
 /**
  * Structure to manage interface list.
@@ -1197,6 +1518,14 @@ oc_remove_network_interface_event_callback(interface_event_handler_t cb)
 void
 handle_network_interface_event_callback(oc_interface_event_t event)
 {
+  if (event == NETWORK_INTERFACE_DOWN)
+  {
+    OC_DBG("INTERFACE DOWN");
+  }
+  else
+  {
+    OC_DBG("INTERFACE UP");
+  }
   if (oc_list_length(oc_network_interface_cb_list) > 0) {
     oc_network_interface_cb_t *cb_item =
       oc_list_head(oc_network_interface_cb_list);
@@ -1560,6 +1889,8 @@ int oc_connectivity_init(size_t device) {
       OC_ERR("checking new IP interfaces failed.");
       return -1;
     }
+    CAInitializeLS();
+    CANetworkMonitorHandler();
 #endif /* OC_NETWORK_MONITOR */
     ifchange_initialized = true;
   }
-- 
2.16.1.windows.1

