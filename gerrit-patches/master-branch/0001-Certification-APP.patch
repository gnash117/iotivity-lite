From 89fe1ff95ccb2e85627bd9490430cb1cf4efa636 Mon Sep 17 00:00:00 2001
From: sachinsk <sachin@graniteriverlabs.in>
Date: Wed, 17 Oct 2018 12:44:09 +0530
Subject: [PATCH] Certification APP

Change-Id: I2ac187aae5f440d686376cacdf9550134d9c39ad
Signed-off-by: sachinsk <sachin@graniteriverlabs.in>
---
 apps/CertificationApp.c                       | 1963 +++++++++++++++++++++++++
 apps/CertificationApp.json                    |   32 +
 apps/CertificationApp_Example.json            |   22 +
 apps/device_builder_server.c                  |  571 +++++++
 apps/discover_device.c                        |  181 +++
 include/Certification.h                       |  348 +++++
 port/linux/Makefile                           |   31 +-
 tests/automation/ctt/Makefile                 |    2 +
 tests/automation/ctt/README.rst               |  106 ++
 tests/automation/ctt/include/DUTController.h  |   50 +
 tests/automation/ctt/include/MiniHttpServer.h |   41 +
 tests/automation/ctt/include/ResourceMap.h    |   60 +
 tests/automation/ctt/run_taf_agent.sh         |   14 +
 tests/automation/ctt/server_config.txt        |  100 ++
 tests/automation/ctt/src/DUTController.c      |  262 ++++
 tests/automation/ctt/src/MiniHttpServer.c     |  751 ++++++++++
 tests/automation/ctt/src/ResourceMap.c        |   87 ++
 tests/automation/ctt/src/TAFAgent.c           | 1194 +++++++++++++++
 18 files changed, 5810 insertions(+), 5 deletions(-)
 create mode 100644 apps/CertificationApp.c
 create mode 100644 apps/CertificationApp.json
 create mode 100644 apps/CertificationApp_Example.json
 create mode 100644 apps/device_builder_server.c
 create mode 100644 apps/discover_device.c
 create mode 100644 include/Certification.h
 create mode 100644 tests/automation/ctt/Makefile
 create mode 100644 tests/automation/ctt/README.rst
 create mode 100755 tests/automation/ctt/include/DUTController.h
 create mode 100755 tests/automation/ctt/include/MiniHttpServer.h
 create mode 100755 tests/automation/ctt/include/ResourceMap.h
 create mode 100755 tests/automation/ctt/run_taf_agent.sh
 create mode 100644 tests/automation/ctt/server_config.txt
 create mode 100755 tests/automation/ctt/src/DUTController.c
 create mode 100755 tests/automation/ctt/src/MiniHttpServer.c
 create mode 100755 tests/automation/ctt/src/ResourceMap.c
 create mode 100644 tests/automation/ctt/src/TAFAgent.c

diff --git a/apps/CertificationApp.c b/apps/CertificationApp.c
new file mode 100644
index 00000000..76ae9754
--- /dev/null
+++ b/apps/CertificationApp.c
@@ -0,0 +1,1963 @@
+/******************************************************************
+ *
+ * Copyright 2018 GRANITE RIVER LABS All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+#include <stdio.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <pthread.h>
+#include <unistd.h>
+#include "oc_api.h"
+#include <string.h>
+#include "Certification.h"
+#include "oc_collection.h"
+#include "oc_rep.h"
+#include "oc_pki.h"
+
+#ifdef OC_CLIENT
+#include "oc_client_state.h"
+#endif
+
+OC_LIST(discoverResource);
+OC_MEMB(discoverResource_m, oc_discoverResource_t, MAX_NUM_RES);
+
+static bool g_addInvisibleResource = false;
+static bool g_isTempResourceCreated = false;
+static bool g_isManyLightCreated = false;
+static bool g_isInvisibleResourceCreated = false;
+static bool g_createResourceWithURL = false;
+static bool g_isAirConDeviceCreated = false;
+static bool g_binaryswitch_valuecb = false;
+static bool resource_found = false;
+static char postRequestUri[MAX_URI_LENGTH];
+static oc_endpoint_t *postRequestEndpoint = NULL;
+static char observeUri[MAX_URI_LENGTH];
+static oc_endpoint_t *observeEndpoint = NULL;
+static char putRequestUri[MAX_URI_LENGTH];
+static oc_endpoint_t *putRequestEndpoint = NULL;
+static bool light_state = false;
+
+static char g_binaryswitch_RESOURCE_PROPERTY_NAME_value[] = "value";
+static char* UserResourceType_input = NULL;
+static char a_light[MAX_URI_LENGTH];
+static oc_endpoint_t set_ep;
+static int g_securityType;
+
+static bool discoverDev = false;
+static bool discoverDeviceInfo = false;
+static bool discoverPlatformInfo= false;
+static bool g_hasCallbackArrived = false;
+static oc_string_t name;
+static bool state;
+static int power;
+
+
+static oc_endpoint_t *resource_server = NULL;
+static oc_endpoint_t *light_server;
+static oc_collection_t* collectionPointer;
+
+static oc_qos_t g_qos;
+
+static unsigned int uri_size = 25;
+
+pthread_mutex_t mutex;
+pthread_mutex_t app_mutex;
+/*It display the available options */
+void showMenu(int argc, char* argv[])
+{
+    int choice;
+
+    printf("\n\t-----------------------------------------------------\n");
+    printf("\tPlease Select an option from the menu and press Enter\n" );
+    printf("\t-----------------------------------------------------\n");
+    printf("\t\t0   : Quit Certification App\n" );
+    printf("\n\tServer Operations:\n" );
+    printf("\t\t1   : Create Normal Resource\n" );
+    printf("\t\t2   : Create Invisible Resource\n" );
+    printf("\t\t3   : Create Resource With Complete URL\n" );
+    printf("\t\t4   : Create Secured Resource\n" );
+    printf("\t\t5   : Create %d Light Resources\n",MAX_LIGHT_RESOURCE_COUNT );
+    printf("\t\t6   : Create Group Resource\n" );
+    printf("\t\t7   : Delete All Resources\n" );
+    printf("\t\t8   : Delete Created Group\n" );
+    printf("\n\tClient Operations:\n" );
+    printf("\t\t9   : Find Introspection\n" );
+    printf("\t\t11  : Find specific type of resource\n" );
+    printf("\t\t12  : Find All Resources\n" );
+    printf("\t\t17  : Send GET Request\n" );
+    printf("\t\t20  : Send PUT Request - Complete Update\n");
+    printf("\t\t21  : Send POST Request - Partial Update - Default\n");
+    printf("\t\t22  : Send POST Request - Partial Update - User Input\n" );
+    printf("\t\t25  : Observe Resource - Retrieve Request with Observe\n" );
+    printf("\t\t26  : Cancel Observing Resource\n" );
+    printf("\t\t28  : Discover Device - Unicast\n");
+    printf("\t\t29  : Discover Device - Multicast\n");
+    printf("\t\t30  : Discover Platform - Multicast\n");
+    printf("\t\t31  : Find Group\n" );
+    printf("\t\t33  : Update Group\n" );
+    printf("\t\t34  : Update Local Resource Manually\n" );
+    printf("\t\t36  : Set Quality of Service - CON(Confirmable)\n" );
+    printf("\t\t37  : Set Quality of Service - NON(Non-Confirmable)\n" );
+    printf("\t\t107 : Create Air Conditioner Single Resource\n" );
+
+    if (argc > 4) {
+        for (int i = 5; i < argc; i++) {
+                choice = atoi(argv[i]);
+                selectMenu(choice);
+        }
+    }
+
+}
+
+void free_buffer(oc_discoverResource_t *cb1)
+{
+    oc_free_server_endpoints(cb1->endpoint);
+}
+
+/*To clear allocated endpoint during discovery*/
+void  free_all_buffer()
+{
+    oc_discoverResource_t *cb_free = (oc_discoverResource_t *) oc_list_pop (discoverResource);
+    while (cb_free != NULL) {
+        free_buffer(cb_free);
+        cb_free = (oc_discoverResource_t *) oc_list_pop (discoverResource);
+        cb_free = cb_free->next;
+    }
+}
+
+/*Perform the selected operation*/
+void selectMenu(int choice)
+{
+    bool isMulticast;
+    switch(choice) {
+        case 1:
+            createResource();
+            break;
+
+        case 2:
+            createInvisibleResource();
+            break;
+
+        case 3:
+            createResourceWithUrl();
+            break;
+
+        case 4:
+            printf("By default resource gets created in Secure mode");
+            break;
+
+        case 5:
+            createManyLightResources();
+            break;
+
+        case 6:
+            if(g_isTempResourceCreated == true)
+                collectionPointer = createGroupResource();
+            else
+                printf("\n!!!!!Please create resource first!!!!!\n");
+            break;
+
+        case 7:
+            deleteAllResources();
+            break;
+
+        case 8:
+            deleteCreatedGroup();
+            break;
+
+        case 9:
+            discoverIntrospection();
+            break;
+
+        case 11:
+            printf("Please type the Resource Type to find, then press Enter: ");
+            unsigned int count_restype = 25;
+            UserResourceType_input = malloc((size_t)count_restype);
+            int numResTypes = scanf("%s", UserResourceType_input);
+            if (numResTypes) {
+                printf("\nuserResourceType entered is %s\n",UserResourceType_input );
+                findResource_UserResType(UserResourceType_input);
+            }
+            break;
+
+        case 12:
+            findAllResources();
+            break;
+
+        case 17:
+            sendGetRequest();
+            break;
+        case 20:
+            sendPutRequestUpdate();
+            break;
+        case 21:
+            sendPostRequestUpdate();
+            break;
+
+        case 22:
+            sendPOSTRequest_partialUpdate_userInput();
+            break;
+
+        case 25:
+            observe_request();
+            break;
+
+        case 26:
+            stop_observe();
+            break;
+
+        case 28:
+            isMulticast = false;
+            discoverDevice(isMulticast);
+            break;
+
+        case 29:
+            isMulticast = true;
+            discoverDevice(isMulticast);
+            break;
+        case 30:
+            isMulticast = true;
+            discoverPlatform(isMulticast);
+            break;
+
+        case 31:
+            printf("\nPlease enter the group URI\n");
+            /* 'uri_size' specifies the number of bytes allocated to 'char* collection_uri_input'
+            using malloc */
+            char* collection_uri_input = malloc((size_t)uri_size);
+            int scanf_returnValue = scanf("%s", collection_uri_input);
+            if(scanf_returnValue == 1) {
+               findGroup(collection_uri_input);
+            }
+            else
+               printf("Failed to read URI");
+            break;
+
+        case 33:
+            printf("Update Group option chosen\n");
+            printf("\nEnter the URI of group to be updated\n");
+            /* 'uri_size' specifies the number of bytes allocated to 'char* collection_uri_input2'
+            using malloc */
+            char* collection_uri_input2 = malloc((size_t)uri_size);
+            int scanf_returnValue2 = scanf("%s", collection_uri_input2);
+            if(scanf_returnValue2 == 1){
+               collectionPointer = updateGroup(collection_uri_input2);
+            }
+            else
+               printf("Failed to read URI");
+            break;
+
+        case 34:
+            printf("'Update local resource maually' chosen\n");
+            printf("Please enter the URI of resource to be updated manually\n");
+            char* resource_uri_input = malloc((size_t)uri_size);
+            int scanf_returnValue3 = scanf("%s", resource_uri_input);
+            if(scanf_returnValue3 == 1){
+               printf("\nResource URI read is as follows: %s\n", resource_uri_input);
+               if(g_isTempResourceCreated == true)
+               updateLocalResourceManually(resource_uri_input);
+               else
+               printf("\n!!!!!Please create resource first!!!!!\n");
+            }
+            else
+               printf("Failed to read URI");
+            break;
+
+        case 36:
+            g_qos = HIGH_QOS;
+            printf("CON type message selected for client\n");
+            break;
+
+        case 37:
+            g_qos = LOW_QOS;
+            printf("NON type message selected for client\n");
+            break;
+        case 107:
+            createSingleAirConResource();
+            break;
+
+        case 0:
+            oc_free_string(&name);
+            free_all_buffer();
+            oc_main_shutdown();
+            pthread_mutex_destroy(&mutex);
+            pthread_mutex_destroy(&app_mutex);
+            exit(0);
+            break;
+
+        default:
+            printf("Invalid Input. Please input your choice again\n");
+    }
+}
+
+void  waitInSecond(int seconds)
+{
+    sleep(seconds);
+}
+
+/*To sleep for few second to get data from network*/
+void waitForCallback()
+{
+    int elapsedSecond = 0;
+    while (g_hasCallbackArrived == false)
+    {
+        waitInSecond(CALLBACK_WAIT_MIN);
+        elapsedSecond++;
+        if (elapsedSecond > CALLBACK_WAIT_MAX)
+        {
+            break;
+        }
+    }
+}
+
+/*Get call back for many light resource function*/
+static void
+get_light(oc_request_t *request, oc_interface_mask_t interface, void *user_data)
+{
+     printf("\n get_light called!!\n");
+    (void)user_data;
+    (void)request;
+    (void)interface;
+
+}
+
+/*
+calling the register_resources  function of device_builder_server.c
+*/
+static void createResource()
+{
+    printf("\ncreateResource called!!\n");
+
+    if (g_isTempResourceCreated == false) {
+        register_resources();
+        printf("Resource created successfully\n");
+        g_isTempResourceCreated = true;
+    }
+    else {
+        printf("Resource already created\n");
+    }
+}
+
+/*
+   passing the invisible resource uri
+*/
+static void createInvisibleResource()
+{
+    printf("createInvisibleResource called!!\n");
+
+    if (g_isInvisibleResourceCreated == false) {
+        oc_resource_t *res = oc_new_resource(NULL, FAN_INVISIBLE_URI, 1, 0);
+        oc_resource_set_default_interface(res, OC_IF_RW);
+        oc_resource_set_discoverable(res, false);
+        oc_resource_set_periodic_observable(res, 0);
+        oc_resource_set_request_handler(res, OC_GET, get_light, NULL);
+        g_addInvisibleResource = oc_add_resource(res);
+
+        if (g_addInvisibleResource == true) {
+            printf("Invisible Light Resource created successfully\n");
+            g_isInvisibleResourceCreated = true;
+        }
+        else {
+            printf("Unable to create Invisible Light Resource \n");
+        }
+    }
+    else {
+          printf("Resource already created!!\n");
+    }
+}
+
+/*creating the the resource by using url*/
+static void createResourceWithUrl()
+{
+    printf("Creating Resource with complete URL called!!\n");
+    if (g_createResourceWithURL == false) {
+        oc_resource_t *res = oc_ri_get_app_resource_by_uri(g_binaryswitch_RESOURCE_URI, strlen(g_binaryswitch_RESOURCE_URI), 0);
+        if (res->uri.ptr == g_binaryswitch_RESOURCE_URI) {
+            printf("Creating Resource with complete URL already created\n");
+            g_createResourceWithURL = true;
+        }
+    }
+    else {
+        printf("Resource with complete URL already created!!\n");
+    }
+}
+
+void postRequestClientCb(oc_client_response_t *data) {
+    PRINT("postRequestClientCb:\n");
+    if (data->code == OC_STATUS_CHANGED)
+        PRINT("POST response OK\n");
+    else
+        PRINT("POST response code %d\n", data->code);
+}
+
+/*Sending post command for selected Resource*/
+static void sendPostRequestUpdate()
+{
+    PRINT("postRequestResource:\n");
+    int selection = selectResource();
+
+    oc_discoverResource_t *cb = (oc_discoverResource_t *) oc_list_head(discoverResource);
+    int i = 1;
+    while (cb != NULL) {
+        if (selection == i) {
+            strncpy(postRequestUri, cb->uri, strlen(cb->uri));
+            postRequestUri[strlen(cb->uri)] = '\0';
+            postRequestEndpoint = cb->endpoint;
+            if (oc_init_post(postRequestUri, postRequestEndpoint, NULL, &postRequestClientCb,
+                     LOW_QOS, NULL)) {
+                oc_rep_start_root_object();
+                oc_rep_set_boolean(root, state, true);
+                oc_rep_end_root_object();
+                if (oc_do_post())
+                    PRINT("Sent POST request\n");
+                else
+                    PRINT("Could not send POST\n");
+            }
+            else
+                PRINT("Could not init POST\n");
+        }
+        else if (selection == CANCEL_SELECTION) {
+            break;
+        }
+        i++;
+        cb = cb->next;
+    }
+
+}
+
+/*Discovrering the resource*/
+oc_discovery_flags_t discovery(const char *di, const char *uri,
+        oc_string_array_t types, oc_interface_mask_t interfaces,
+        oc_endpoint_t *endpoint, oc_resource_properties_t bm, void *user_data) {
+    (void) di;
+    (void) interfaces;
+    (void) user_data;
+    (void) bm;
+    int i;
+
+    oc_discoverResource_t *l = (oc_discoverResource_t *) oc_memb_alloc (&discoverResource_m);
+    int uri_len = strlen(uri);
+    uri_len = (uri_len >= MAX_URI_LENGTH) ? MAX_URI_LENGTH - 1 : uri_len;
+    PRINT("\n discovery: %s", uri);
+    for (i = 0; i < (int) oc_string_array_get_allocated_size(types); i++) {
+       char *t = oc_string_array_get_item(types, i);
+        if (strlen(t) > 0) {
+
+            light_server = endpoint;
+            strncpy(a_light, uri, uri_len);
+            a_light[uri_len] = '\0';
+            oc_endpoint_t *ep = endpoint;
+            strncpy(l->uri, uri, strlen(uri));
+            l->uri[strlen(uri)] = '\0';
+            l->endpoint = endpoint;
+            oc_list_add(discoverResource, l);
+              while (ep != NULL) {
+                  PRINT("\nIP address: \n");
+                  PRINTIPaddr(*ep);
+                  PRINT("\nPort:\n");
+                  PRINTport(*ep);
+                  PRINT("\n");
+                  ep = ep->next;
+              }
+              resource_found =true;
+              PRINT("Resource %s hosted at endpoints:\n", uri);
+
+             return OC_CONTINUE_DISCOVERY;
+
+        }
+    }
+
+    return OC_STOP_DISCOVERY;
+}
+
+/*calling the discovery function*/
+static void findAllResources()
+{
+    printf("Find All Resources called\n");
+    discoverDev = oc_do_ip_discovery(NULL, &discovery, NULL);
+    waitForCallback();
+}
+
+/*discovering only particular Resource type*/
+static oc_discovery_flags_t
+discovery_ResourceType(const char *anchor, const char *uri, oc_string_array_t types,
+          oc_interface_mask_t interfaces, oc_endpoint_t *endpoint,
+          oc_resource_properties_t bm, void *user_data)
+{
+
+  (void)anchor;
+  (void)user_data;
+  (void)interfaces;
+  (void)bm;
+  int i;
+  int uri_len = strlen(uri);
+  uri_len = (uri_len >= MAX_URI_LENGTH) ? MAX_URI_LENGTH - 1 : uri_len;
+  for (i = 0; i < (int)oc_string_array_get_allocated_size(types); i++) {
+      char *t = oc_string_array_get_item(types, i);
+      if (strcmp(UserResourceType_input, t) == 1) {
+        printf("Inside the userResourceType ");
+        resource_server = endpoint;
+        strncpy(a_light, uri, uri_len);
+        a_light[uri_len] = '\0';
+
+        PRINT("Resource %s hosted at endpoints:\n", a_light);
+
+        oc_endpoint_t *ep = endpoint;
+        while (ep != NULL) {
+          PRINTipaddr(*ep);
+          PRINT("\n");
+          ep = ep->next;
+        }
+
+        printf("OC_STOP_DISCOVERY retuened");
+
+        return OC_STOP_DISCOVERY;
+      }
+    }
+  //oc_free_server_endpoints(endpoint);
+  return OC_CONTINUE_DISCOVERY;
+}
+
+/*calling  discovery function for particular res type*/
+static void findResource_UserResType(char *userResourceType)
+{
+    printf("\nfindResource_UserResType called, user input is %s\n", userResourceType);
+     bool discoverResourcetype = false;
+    if (userResourceType!=NULL) {
+
+        printf("call discovery!!\n");
+        fflush(stdout);
+        discoverResourcetype = oc_do_ip_discovery (userResourceType, &discovery_ResourceType, NULL );
+
+    }
+
+    if (discoverResourcetype == true) {
+        printf("userResourceType Discovered\n");
+    }
+    else {
+        printf("userResourceType is not Discovered");
+    }
+}
+
+static bool
+is_resource_found(void)
+{
+    if (!resource_found) {
+        printf("Please discovery resource first!\n");
+        return false;
+    }
+    return true;
+}
+
+static void
+get_response(oc_client_response_t *data)
+{
+    printf("GET_light:\n");
+    if (data->code == OC_STATUS_CHANGED)
+       PRINT("GET response: CHANGED\n");
+    else if (data->code == OC_STATUS_CREATED)
+        PRINT("GET response: CREATED\n");
+    else
+        PRINT("GET response code %d\n", data->code);
+}
+
+/*select particular resource which discoverd using discovery function*/
+int  selectResource()
+{
+    int selection = -1;
+    oc_discoverResource_t *cb = (oc_discoverResource_t *) oc_list_head(discoverResource);
+    int len = oc_list_length(discoverResource);
+    printf("\n Discovery.... Please select resource no. and press Enter: \n");
+    printf("\t\t option : 0\t Cancel\n");
+    for (int i = 1; i <= len+1; i++) {
+        if (cb != NULL) {
+            printf("\t\t option : %d\t", i);
+            printf("resource URI:%s \t", cb->uri);
+            printf("endpoint:");
+            oc_endpoint_t *endpoint = cb->endpoint;
+            PRINTipaddr(*endpoint);
+            printf("\n");
+            cb = cb->next;
+        }
+    }
+    if (scanf("%d", &selection)) {
+        printf("Selcted input for choice %d\n", selection);
+        if (selection < 0 || selection > len+1) {
+            printf("Invalid choice and Please choice the option from the menu \n");
+            if (scanf("%d", &selection)) {
+                printf("Select input from choice %d\n", selection);
+            }
+        }
+    }
+    return selection;
+}
+
+/*sending get request for selected resource*/
+static void sendGetRequest()
+{
+    printf("SEND GET request is called\n ");
+    int selection = selectResource();
+    char discoverUri[MAX_URI_LENGTH];
+    oc_endpoint_t *endpoint = NULL;
+    oc_discoverResource_t *cb = (oc_discoverResource_t *) oc_list_head(discoverResource);
+    int i = 1;
+    while (cb != NULL) {
+        if (selection == i) {
+            strncpy(discoverUri, cb->uri, strlen(cb->uri));
+            discoverUri[strlen(cb->uri)] = '\0';
+            endpoint = cb->endpoint;
+            oc_do_get(discoverUri, endpoint, NULL, &get_response, LOW_QOS, NULL);
+            waitForCallback();
+        }
+        else if (selection == CANCEL_SELECTION) {
+            break;
+        }
+        i++;
+        cb = cb->next;
+    }
+}
+
+static void
+post_observe(oc_client_response_t *data)
+{
+  PRINT("post_observe:\n");
+  if (data->code == OC_STATUS_CHANGED)
+    PRINT("POST response OK\n");
+  else
+    PRINT("POST response code %d\n", data->code);
+}
+
+static void
+observe_response(oc_client_response_t *data)
+{
+
+  PRINT("OBSERVE_light:\n");
+  oc_rep_t *rep = data->payload;
+  while (rep != NULL) {
+    PRINT("key %s, value ", oc_string(rep->name));
+    switch (rep->type) {
+    case OC_REP_BOOL:
+      PRINT("%d\n", rep->value.boolean);
+      light_state = rep->value.boolean;
+      break;
+    default:
+      break;
+    }
+    rep = rep->next;
+  }
+
+  if (oc_init_post(observeUri, observeEndpoint, NULL, &post_observe, LOW_QOS, NULL)) {
+    oc_rep_start_root_object();
+    oc_rep_set_boolean(root, state, !light_state);
+    oc_rep_end_root_object();
+    if (oc_do_post())
+      PRINT("Sent POST request\n");
+    else
+      PRINT("Could not send POST\n");
+  } else
+    PRINT("Could not init POST\n");
+}
+
+/*sending the observe request  for selected resource*/
+static void
+observe_request(void)
+{
+
+    int selection = selectResource();
+
+    oc_discoverResource_t *cb = (oc_discoverResource_t *) oc_list_head(discoverResource);
+    int i = 1;
+    while (cb != NULL) {
+        if (selection == i) {
+            strncpy(observeUri, cb->uri, strlen(cb->uri));
+            observeUri[strlen(cb->uri)] = '\0';
+            observeEndpoint = cb->endpoint;
+            oc_do_observe(observeUri, observeEndpoint, NULL, &observe_response, LOW_QOS, NULL);
+            waitForCallback();
+        }
+        else if (selection == CANCEL_SELECTION) {
+            break;
+        }
+        i++;
+        cb = cb->next;
+    }
+}
+
+/*sending stop observe request for selected resource*/
+static void
+stop_observe(void)
+{
+    int selection = selectResource();
+    char stopObserveUri[MAX_URI_LENGTH];
+    oc_endpoint_t *stopObserveUriEndpoint = NULL;
+
+    oc_discoverResource_t *cb = (oc_discoverResource_t *) oc_list_head(discoverResource);
+    int i = 1;
+    while (cb != NULL) {
+        if (selection == i) {
+            strncpy(stopObserveUri, cb->uri, strlen(cb->uri));
+            stopObserveUri[strlen(cb->uri)] = '\0';
+            stopObserveUriEndpoint = cb->endpoint;
+            oc_stop_observe(stopObserveUri, stopObserveUriEndpoint);
+            waitForCallback();
+        }
+        else if (selection == CANCEL_SELECTION) {
+            break;
+        }
+        i++;
+        cb = cb->next;
+    }
+}
+
+static oc_event_callback_retval_t
+putStopObserverequest(void *data)
+{
+    (void)data;
+    PRINT("Stopping OBSERVE\n");
+    oc_stop_observe(putRequestUri, putRequestEndpoint);
+    return OC_EVENT_DONE;
+}
+
+static void
+putObserveRequestClientCb(oc_client_response_t *data)
+{
+
+    PRINT("OBSERVE_light:\n");
+    oc_rep_t *rep = data->payload;
+    while (rep != NULL) {
+        PRINT("key %s, value ", oc_string(rep->name));
+        switch (rep->type) {
+            case OC_REP_BOOL:
+                PRINT("%d\n", rep->value.boolean);
+                state = rep->value.boolean;
+                break;
+            case OC_REP_INT:
+                PRINT("%d\n", rep->value.integer);
+                power = rep->value.integer;
+                break;
+            case OC_REP_STRING:
+                PRINT("%s\n", oc_string(rep->value.string));
+                if (oc_string_len(name))
+                    oc_free_string(&name);
+                    oc_new_string(&name, oc_string(rep->value.string),
+                    oc_string_len(rep->value.string));
+                break;
+            default:
+                break;
+        }
+        rep = rep->next;
+    }
+}
+
+static void
+putPostRequestClientCb (oc_client_response_t *data)
+{
+
+    PRINT("POST_light:\n");
+    if (data->code == OC_STATUS_CHANGED)
+        PRINT("POST response: CHANGED\n");
+    else if (data->code == OC_STATUS_CREATED)
+        PRINT("POST response: CREATED \n");
+    else
+        PRINT("POST response code %d\n", data->code);
+
+    oc_do_observe(putRequestUri, putRequestEndpoint, NULL, &putObserveRequestClientCb, LOW_QOS, NULL);
+    oc_set_delayed_callback(NULL, &putStopObserverequest, 30);
+    PRINT("Sent OBSERVE request\n");
+}
+
+static void
+putRequestClientCb (oc_client_response_t *data)
+{
+
+    PRINT("PUT_light:\n");
+
+    if (data->code == OC_STATUS_CHANGED)
+        PRINT("PUT response: CHANGED\n");
+    else
+        PRINT("PUT response code %d\n", data->code);
+
+    if (oc_init_post(putRequestUri, putRequestEndpoint, NULL, &putPostRequestClientCb, LOW_QOS, NULL)) {
+        oc_rep_start_root_object();
+        oc_rep_set_boolean(root, state, false);
+        oc_rep_end_root_object();
+        if (oc_do_post())
+            PRINT("Sent POST request\n");
+        else
+            PRINT("Could not send POST request\n");
+    } else
+          PRINT("Could not init POST request\n");
+}
+
+static void
+getPutRequestClientCb (oc_client_response_t *data)
+{
+    PRINT("getPutRequestClientCb:\n");
+    oc_rep_t *rep = data->payload;
+    while (rep != NULL) {
+        PRINT("key %s, value ", oc_string(rep->name));
+        switch (rep->type) {
+            case OC_REP_BOOL:
+                PRINT("%d\n", rep->value.boolean);
+                state = rep->value.boolean;
+                break;
+            case OC_REP_INT:
+                PRINT("%d\n", rep->value.integer);
+                power = rep->value.integer;
+                break;
+            case OC_REP_STRING:
+                PRINT("%s\n", oc_string(rep->value.string));
+                if (oc_string_len(name))
+                    oc_free_string(&name);
+                    oc_new_string(&name, oc_string(rep->value.string),
+                    oc_string_len(rep->value.string));
+                break;
+            default:
+                break;
+        }
+        rep = rep->next;
+    }
+
+    PRINT("get_put:\n");
+    if (oc_init_put(putRequestUri, putRequestEndpoint, NULL, &putRequestClientCb, LOW_QOS, NULL)) {
+        oc_rep_start_root_object();
+        oc_rep_set_boolean(root, state, true);
+        oc_rep_end_root_object();
+
+    if (oc_do_put())
+        PRINT("Sent PUT request\n");
+    else
+        PRINT("Could not send PUT request\n");
+    } else
+        PRINT("Could not init PUT request\n");
+}
+
+/*sending put request to create resource*/
+static void sendPutRequestUpdate()
+{
+    printf("sendPutRequestUpdate\n");
+    int selection = selectResource();
+    oc_discoverResource_t *cb = (oc_discoverResource_t *) oc_list_head(discoverResource);
+    int i = 1;
+    while (cb != NULL) {
+        if (selection == i) {
+            strncpy(putRequestUri, cb->uri, strlen(cb->uri));
+            putRequestUri[strlen(cb->uri)] = '\0';
+            putRequestEndpoint = cb->endpoint;
+            oc_do_get(putRequestUri, putRequestEndpoint, NULL, &getPutRequestClientCb, LOW_QOS, NULL);
+            waitForCallback();
+        }
+        else if (selection == CANCEL_SELECTION) {
+            break;
+        }
+        i++;
+        cb = cb->next;
+    }
+}
+
+/*getting the device information wich registered in network*/
+static void
+get_device (oc_client_response_t *data)
+{
+    PRINT("GET_device:\n");
+    oc_rep_t *rep = data->payload;
+    while (rep != NULL) {
+        switch (rep->type) {
+        case OC_REP_STRING:
+        if ((oc_string_len(rep->name) == 3 &&
+            memcmp(oc_string(rep->name), "pid", 3) == 0) ||
+            (oc_string_len(rep->name) == 3 &&
+            memcmp(oc_string(rep->name), "dmv", 3) == 0) ||
+            (oc_string_len(rep->name) == 3 &&
+            memcmp(oc_string(rep->name), "icv", 3) == 0) ||
+            (oc_string_len(rep->name) == 2 &&
+            memcmp(oc_string(rep->name), "di", 2) == 0)) {
+            PRINT("key: %s, value: %s\n", oc_string(rep->name),
+                oc_string(rep->value.string));
+        }
+        break;
+    case OC_REP_STRING_ARRAY:
+        if (oc_string_len(rep->name) == 2 &&
+          (memcmp(oc_string(rep->name), "rt", 2) == 0 ||
+           memcmp(oc_string(rep->name), "if", 2) == 0)) {
+        int i;
+        PRINT("key: %s, value: ", oc_string(rep->name));
+        for (i = 0;
+             i < (int)oc_string_array_get_allocated_size(rep->value.array);
+             i++) {
+          PRINT(" %s ", oc_string_array_get_item(rep->value.array, i));
+        }
+        PRINT("\n");
+      }
+      break;
+    default:
+      break;
+    }
+    rep = rep->next;
+  }
+}
+
+/*getting the platform information register in network*/
+static void
+get_platform (oc_client_response_t *data)
+{
+  PRINT("GET_platform:\n");
+  oc_rep_t *rep = data->payload;
+  while (rep != NULL) {
+    switch (rep->type) {
+    case OC_REP_STRING:
+      if ((oc_string_len(rep->name) == 2 &&
+           memcmp(oc_string(rep->name), "pi", 2) == 0) ||
+          (oc_string_len(rep->name) == 4 &&
+           memcmp(oc_string(rep->name), "mnmn", 4) == 0)) {
+        PRINT("key: %s, value: %s\n", oc_string(rep->name),
+              oc_string(rep->value.string));
+      }
+      break;
+    default:
+      break;
+    }
+    rep = rep->next;
+  }
+}
+
+/*sending multicast/unicast request to discover  registered Resource for discover device */
+
+static void discoverDevice (bool isMulticast)
+{
+    if (!discoverDev) {
+        if (isMulticast) {
+        oc_make_ipv6_endpoint(mcast, IPV6 | DISCOVERY, 5683, 0xff, 0x02, 0, 0, 0, 0,
+                        0, 0, 0, 0, 0, 0, 0, 0, 0x01, 0x58);
+        mcast.addr.ipv6.scope = 2;
+        oc_endpoint_t set_up;
+        set_up = mcast;
+
+        discoverDev = oc_do_ip_discovery_at_endpoint(NULL, &discovery, &set_up,
+                                     NULL);
+        waitForCallback();
+
+        }
+        else {
+            discoverDev = oc_do_ip_discovery(NULL, &discovery, NULL);
+            waitForCallback();
+        }
+    }
+    else {
+        printf("Device is already Discovered\n");
+    }
+
+    printf("\n Taking the endPoint from discoverDevMul ----------->\n");
+    oc_discoverResource_t *cb = (oc_discoverResource_t *) oc_list_head(discoverResource);
+    while (cb != NULL) {
+        if (strncmp(cb->uri ,"/oic/p", strlen(cb->uri)) == 1) {
+            break;
+        }
+        cb = cb->next;
+    }
+    discoverDeviceInfo = oc_do_get("/oic/d", cb->endpoint, "if=oic.if.baseline", &get_device, LOW_QOS,
+                                  NULL);
+    waitForCallback();
+
+    if (discoverDeviceInfo == true){
+
+        printf("\nDevice discovery done successfully\n");
+    }
+    else {
+        printf("Device discovery failed\n");
+    }
+
+}
+
+/*Sending unicast or multicast request to get platform information*/
+static void discoverPlatform(bool isMulticast)
+{
+
+    if (!discoverDev){
+        if (isMulticast) {
+            oc_make_ipv6_endpoint(mcast, IPV6 | DISCOVERY, 5683, 0xff, 0x02, 0, 0, 0, 0,
+                        0, 0, 0, 0, 0, 0, 0, 0, 0x01, 0x58);
+            mcast.addr.ipv6.scope = 2;
+            set_ep = mcast;
+            discoverDev = oc_do_ip_discovery_at_endpoint(NULL, &discovery, &set_ep,
+                                                             NULL);
+            waitForCallback();
+        }
+        else {
+
+            discoverDev = oc_do_ip_discovery(NULL, &discovery, NULL);
+            waitForCallback();
+
+        }
+    }
+    else {
+
+        printf("Device is already Discovered\n");
+    }
+
+    printf("\n Taking the endPoint from discoverDevMul ----------->\n");
+    oc_discoverResource_t *cb = (oc_discoverResource_t *) oc_list_head(discoverResource);
+        while (cb != NULL) {
+        if ( strncmp(cb->uri ,"/oic/p", strlen(cb->uri)) == 1) {
+            break;
+        }
+        cb = cb->next;
+    }
+
+    discoverPlatformInfo = oc_do_get("/oic/p", cb->endpoint, NULL, &get_platform, LOW_QOS,
+                                     NULL);
+    waitForCallback();
+
+    if (discoverPlatformInfo == true){
+
+        printf("Platform discovery done successfully\n");
+    }
+    else {
+        printf("Platform discovery failed\n");
+    }
+}
+
+/*call back of discoverintrospection*/
+static oc_discovery_flags_t
+discovery_Introspection(const char *anchor, const char *uri, oc_string_array_t types,
+          oc_interface_mask_t interfaces, oc_endpoint_t *endpoint,
+          oc_resource_properties_t bm, void *user_data)
+{
+    (void)anchor;
+    (void)user_data;
+    (void)interfaces;
+    (void)bm;
+    int i;
+    PRINT("test:\n");
+    int uri_len = strlen(uri);
+    uri_len = (uri_len >= MAX_URI_LENGTH) ? MAX_URI_LENGTH - 1 : uri_len;
+    for (i = 0; i < (int)oc_string_array_get_allocated_size(types); i++) {
+        char *t = oc_string_array_get_item(types, i);
+        printf("discoverIntrospection option Called %s ", t);
+        if (strcmp("oic.wk.introspection", t) == 0) {
+            resource_server = endpoint;
+            strncpy(a_light, uri, uri_len);
+            a_light[uri_len] = '\0';
+            PRINT("Resource %s hosted at endpoints:\n", a_light);
+            oc_endpoint_t *ep = endpoint;
+            while (ep != NULL) {
+                PRINTipaddr(*ep);
+                PRINT("\n");
+                ep = ep->next;
+            }
+            return OC_STOP_DISCOVERY;
+        }
+    }
+    //oc_free_server_endpoints(endpoint);
+    return OC_CONTINUE_DISCOVERY;
+}
+
+/*sending discover introspection request */
+void discoverIntrospection()
+{
+    printf("Discovering Introspection using Multicast... ");
+    oc_do_ip_discovery("oic.wk.introspection", &discovery_Introspection, NULL);
+    waitForCallback();
+}
+
+/*
+input is baseUri,lightCount added in the baseUri
+*/
+static void createManyLightResources()
+{
+    printf("createManyLightResources called!!\n");
+
+    bool add_LightResource;
+    char baseUri[20] = "/device/light-";
+    int  lightCount = LIGHT_COUNT;
+    char uri[20] = "";
+
+    if (g_isManyLightCreated == false) {
+
+        for (int i = 0; i < MAX_LIGHT_RESOURCE_COUNT; i++, lightCount++) {
+            sprintf(uri,"/device/light-%d", lightCount);
+            printf("%s\n",baseUri);
+            printf("%s\n",uri);
+
+            oc_resource_t *res = oc_new_resource(RESOURCE_NAME, uri, NUM_RESOURCES_TYPES, NUM_DEVICE);
+            oc_resource_bind_resource_type(res, RESOURCE_LIGHT_TYPE);
+            oc_resource_bind_resource_interface(res, OC_IF_BASELINE);
+            oc_resource_set_default_interface(res, OC_IF_RW);
+            oc_resource_set_discoverable(res, true);
+            oc_resource_set_periodic_observable(res, 1);
+            oc_resource_set_request_handler(res, OC_GET, get_light, NULL);
+            add_LightResource = oc_add_resource(res);
+
+            if (add_LightResource == true) {
+
+                printf("Light Resource created successfully with uri:\n");
+                g_isManyLightCreated = true;
+            }
+            else {
+                printf("Unable to create Light resource with uri\n");
+            }
+        }
+    }
+    else {
+      printf("Many Light Resources already created!!\n");
+    }
+}
+
+/* createGroupResource() function creates a collection; also creates links to resources that are to be added
+   to the collection and adds them to the collection; resource pointers are obtained from resource URIs */
+static oc_collection_t* createGroupResource()
+{
+
+    oc_resource_t *resource_one = oc_ri_get_app_resource_by_uri(RESOURCE_1_URI, strlen(RESOURCE_1_URI),0);
+    oc_resource_t *resource_two = oc_ri_get_app_resource_by_uri(RESOURCE_2_URI, strlen(RESOURCE_2_URI),0);
+
+    const char* collection_name = "example_collection";
+    const char* collection_uri = "/example_collection_path";
+
+    oc_resource_t *new_collection = oc_new_collection(collection_name, collection_uri, 2, 2, 2, 0);
+
+    #if defined(OC_COLLECTIONS)
+
+        if(new_collection != NULL)
+            printf("New collection created with the following name: %s\n",new_collection->name.ptr);
+
+        oc_collection_add_supported_rt(new_collection, "oic.r.switch.binary");
+        oc_collection_add_supported_rt(new_collection, "oic.r.humidity");
+        oc_collection_add_mandatory_rt(new_collection, "oic.r.switch.binary");
+        oc_collection_add_mandatory_rt(new_collection, "oic.r.humidity");
+
+        oc_resource_bind_resource_type(new_collection, "oic.wk.col");
+        oc_resource_set_discoverable(new_collection, true);
+
+        oc_link_t *link_one = oc_new_link(resource_one);
+        oc_collection_add_link(new_collection, link_one);
+
+        oc_link_t *link_two = oc_new_link(resource_two);
+        oc_collection_add_link(new_collection, link_two);
+
+        oc_add_collection(new_collection);
+
+    #endif /* OC_COLLECTIONS */
+
+    return (oc_collection_t*)new_collection;
+
+}
+
+/*delete All  created resource*/
+static void deleteAllResources()
+{
+    printf("deteAllResources called!!\n");
+
+    oc_resource_t *res = oc_ri_get_app_resources();
+
+    while(res)
+    {
+        oc_ri_delete_resource(res);
+        res = oc_ri_get_app_resources();
+    }
+
+    if (res == NULL) {
+        printf("All Resources Deleted\n");
+    }
+
+    g_isManyLightCreated = false;
+    g_addInvisibleResource = false;
+    g_isTempResourceCreated = false;
+    g_createResourceWithURL = false;
+    g_isAirConDeviceCreated = false;
+}
+
+static void deleteCreatedGroup()
+{
+
+    oc_collection_free(collectionPointer);
+    printf("\nCollection deleted\n");
+}
+
+static void
+post_response(oc_client_response_t *data)
+{
+  printf("POST_light:\n");
+  if (data->code == OC_STATUS_CHANGED)
+    printf("POST response: CHANGED\n");
+  else if (data->code == OC_STATUS_CREATED)
+    printf("POST response: CREATED\n");
+  else
+    printf("POST response code %d\n", data->code);
+}
+
+/*Following function takes input of 'attribute key' and 'attribute value' from user
+and sends a POST request */
+static void sendPOSTRequest_partialUpdate_userInput()
+{
+  if (!is_resource_found())
+    return;
+
+  printf("\nPlease Input attribute key(string)\n");
+  unsigned int count = 15;
+  char* attribute_key = malloc((size_t)count);
+  int scanf_return_value1 = scanf("%s", attribute_key);
+  if(scanf_return_value1)
+      printf("Attribute key entered is '%s'\n", attribute_key);
+
+  printf("\nPlease Input attribute value(integer)\n");
+  int attribute_value;
+  int scanf_return_value2 = scanf("%d",&attribute_value);
+  if(scanf_return_value2)
+      printf("Attribute value entered is '%d'\n", attribute_value);
+
+  if (oc_init_post(a_light, light_server, NULL, &post_response, LOW_QOS, NULL)) {
+    oc_rep_start_root_object();
+    oc_rep_set_boolean(root, state, false);
+    oc_rep_set_int(root, attribute_key, attribute_value);
+    oc_rep_end_root_object();
+    if (oc_do_post())
+      printf("\nSent POST request\n");
+    else
+      printf("\nCould not send POST request\n");
+  } else
+    printf("\nCould not init POST request\n");
+}
+
+/* Following function takes URI of the collection to be updated, as input. It allows 1. updation of collection
+properties(namely collection type, collection interface and collection path), 2. adding of a resource to the
+collection, 3. removal of a resource from a collection and 4. updation of the properties(namely type, interface
+and path) of a resource in the collection. */
+
+static oc_collection_t* updateGroup(char* uri_input)
+{
+    oc_collection_t* tempCollection = oc_get_collection_by_uri(uri_input, strlen(uri_input), 0);
+    int optionNumber;
+
+    if(tempCollection == NULL){
+        printf("!!Collection not found!! Collection URI entered may be incorrect OR collection is not created OR both\n");
+    }
+    else{
+
+    printf("\nResources part of '%s' are as follows:\n", tempCollection->name.ptr);
+
+    oc_link_t* resource_links = oc_collection_get_links((oc_resource_t*)tempCollection);
+    int count_resource=1;
+
+    while(resource_links != NULL){
+        printf("Resource %d - URI: '%s'\n", count_resource, resource_links->resource->uri.ptr);
+        count_resource++;
+        resource_links = resource_links->next;
+    }
+
+    printf("..................\n");
+    printf("Update Group Menu:\n");
+    printf("..................\n");
+    printf("Choose from below options by entering the option number\n1. Update collection properties\n"
+        "2. Add a resource to group\n3. Remove a resource from group\n4. Update a resource's properties\n");
+
+    int scanf_return_value = scanf("%d",&optionNumber);
+    if(scanf_return_value)
+        printf("Option chosen:%d\n",optionNumber);
+
+    switch(optionNumber) {
+
+        case 1:   ;
+            int collectionPropertyOptionNumber = -1;
+
+            unsigned int count_case1 = 25;
+            char* resource_property_case1 = malloc((size_t)count_case1);
+
+            int collectionInterfaceIntegerValue = 1;
+
+            while(collectionPropertyOptionNumber != 0)
+            {
+            case1_label:
+                printf("\t\t..................\n");
+                printf("\t\tUpdate collection properties:\n");
+                printf("\t\t..................\n");
+                printf("\t\tChoose from below options by entering the option number\n\t\t1. Update collection type\n"
+                "\t\t2. Update collection interface\n\t\t3. Update collection path\n\t\t0. Exit Update collection Properties\n");
+
+                int scanf_returnValue_case1 = scanf("%d",&collectionPropertyOptionNumber);
+                if(scanf_returnValue_case1)
+                {
+                    if(collectionPropertyOptionNumber == 0)
+                    {
+                        printf("'Exit Update Collection Properties' chosen\n");
+                        break;
+                    }
+                    else if(collectionPropertyOptionNumber == 1)
+                    {
+                        printf("Option 1 chosen.\n");
+                        printf("Presently, collection type is '%s'\n",tempCollection->types.ptr);
+                        printf("Please enter new 'collection type'\n");
+                        int scanf_returnValue_case1_2 = scanf("%s", resource_property_case1);
+                        if(scanf_returnValue_case1_2)
+                        printf("\nCollection property read is as follows: %s\n", resource_property_case1);
+                    }
+                    else if(collectionPropertyOptionNumber == 2)
+                    {
+                        printf("\nOption 2 chosen.\n");
+                        printf("Presently, interface value is %d\n\n",tempCollection->interfaces);
+                        printf("Please enter a suitable integer number using the guide below\nto have"
+                            "the required interfaces for the collection\n\n");
+                        printf("2: corresponds to Baseline(OC_IF_BASELINE) interface\n"
+                            "4: corresponds to Link Lists(OC_IF_LL) interface\n"
+                            "8: corresponds to Batch(OC_IF_B) interface\n"
+                            "16: corresponds to Read-only(OC_IF_R) interface\n"
+                            "32: corresponds to Read-Write(OC_IF_RW) interface\n"
+                            "64: corresponds to Actuator(OC_IF_A) interface\n"
+                            "128: corresponds to Sensor(OC_IF_S) interface\n");
+                        printf("66(2+64): corresponds to interfaces of Baseline(2) and Actuator(64)\n");
+                        printf("18(2+16): corresponds to interfaces of Baseline(2) and Read-only(16)\netc.,\n");
+                        int scanf_returnValue_case1_3 = scanf("%d",&collectionInterfaceIntegerValue);
+                        if (scanf_returnValue_case1_3)
+                            printf("Collection Interface Integer Value entered: %d\n", collectionInterfaceIntegerValue);
+
+                    }
+                    else if (collectionPropertyOptionNumber == 3)
+                    {
+                        printf("Option 3 chosen.\n");
+                        printf("Presently, collection URI is '%s'\n",tempCollection->uri.ptr);
+                        printf("Please enter 'new collection URI'\n");
+                        int scanf_returnValue_case1_4 = scanf("%s", resource_property_case1);
+                        if(scanf_returnValue_case1_4)
+                        printf("\nNew URI read is as follows: %s\n", resource_property_case1);
+                    }
+                    else
+                    {
+                        printf("!!!!!!!!Invalid option chosen!!!!!!!!\n");
+                        goto case1_label;
+                    }
+                }
+                else
+                    printf("Read from scanf was unsuccessful\n");
+
+                switch(collectionPropertyOptionNumber)
+                {
+                    case 1:
+                        printf("\nResource type of collection '%s' before updation: %s\n", tempCollection->name.ptr,
+                        tempCollection->types.ptr);
+                        tempCollection->types.ptr = resource_property_case1;
+                        printf("Resource type of collection '%s' after updation: %s\n", tempCollection->name.ptr,
+                        tempCollection->types.ptr);
+                    break;
+
+                    case 2:
+                        printf("\nInterface of collection '%s' before updation: %d\n", tempCollection->name.ptr,
+                             tempCollection->interfaces);
+
+                        tempCollection->interfaces = collectionInterfaceIntegerValue;
+
+                        printf("Interface of collection '%s' after updation: %d\n", tempCollection->name.ptr,
+                        tempCollection->interfaces);
+                    break;
+
+                    case 3:
+                        /* Still working on updating collection path */
+                        printf("\nURI of collection '%s' before updation: %s\n", tempCollection->name.ptr,
+                        tempCollection->uri.ptr);
+                        tempCollection->uri.ptr = resource_property_case1;
+                        printf("URI of collection '%s' after updation: %s\n", tempCollection->name.ptr,
+                        tempCollection->uri.ptr);
+                    break;
+
+                    default: printf("Entered 'default case' of switch statement in 'case 4' of outer switch statement\n");
+                    break;
+                }
+            }
+        break;
+
+        case 2: printf("\nEnter the URI of the resource to be added to the group '%s'\n", tempCollection->name.ptr);
+            unsigned int count_case2 = 25;
+            char* resource_uri_case2 = malloc((size_t)count_case2);
+            int scanf_returnValue_case2 = scanf("%s", resource_uri_case2);
+
+            if(scanf_returnValue_case2)
+                printf("");
+
+            oc_resource_t *resource_case2 = oc_ri_get_app_resource_by_uri(resource_uri_case2, strlen(resource_uri_case2),0);
+
+            if(resource_case2 != NULL)
+            {
+                oc_link_t *link_one = oc_new_link(resource_case2);
+                oc_collection_add_link((oc_resource_t*)tempCollection, link_one);
+                printf("\nLink of resource with URI:'%s' has been added to the group '%s'\n", resource_uri_case2, tempCollection->name.ptr);
+            }
+            else{
+                printf("\n!!!!!Resource with above entered URI is not found!!!!!\n");
+            }
+
+            printf("\nFollowing resources are part of '%s' after addition of resource\n", tempCollection->name.ptr);
+
+            oc_link_t* resource_links_case2 = oc_collection_get_links((oc_resource_t*)tempCollection);
+            int count_case2_1=1;
+
+            while(resource_links_case2 != NULL)
+            {
+                printf("Resource %d - URI: '%s'\n", count_case2_1, resource_links_case2->resource->uri.ptr);
+                count_case2_1++;
+                resource_links_case2 = resource_links_case2->next;
+            }
+
+            break;
+
+        case 3: printf("\nEnter the URI of the resource to be removed from the group\n");
+            unsigned int count_case3 = 25;
+            char* resource_uri_case3 = malloc((size_t)count_case3);
+            int scanf_returnValue_case3 = scanf("%s", resource_uri_case3);
+            if(scanf_returnValue_case3)
+                printf("\nResource URI read is as follows: %s\n", resource_uri_case3);
+
+            oc_resource_t *resource_case3 = oc_ri_get_app_resource_by_uri(resource_uri_case3, strlen(resource_uri_case3),0);
+            if(resource_case3 == NULL)
+            printf("\n!!!!!Resource with above entered URI is not found!!!!!\n");
+            else{
+            oc_link_t* resource_links_case3 = oc_collection_get_links((oc_resource_t*)tempCollection);
+
+            while(resource_links_case3 != NULL)
+            {
+                if(!strcmp(resource_links_case3->resource->uri.ptr, resource_uri_case3))
+                {
+                    printf("\nLink of resource with uri: '%s' will be removed from '%s'\n", resource_links_case3->resource->uri.ptr,
+                        tempCollection->name.ptr);
+                    oc_collection_remove_link((oc_resource_t*)tempCollection, resource_links_case3);
+                    printf("\n........Resource(resource link) removed from the group........\n");
+                    break;
+                }
+                resource_links_case3 = resource_links_case3->next;
+            }
+            }
+            break;
+
+        case 4: printf("Enter the URI of resource whose properties are to be updated\n");
+            int resourcePropertyOptionNumber = -1;
+
+            unsigned int count_case4 = 25;
+            char* resource_uri_case4 = malloc((size_t)count_case4);
+            int scanf_returnValue_case4 = scanf("%s", resource_uri_case4);
+            if(scanf_returnValue_case4)
+            printf("\nResource URI read is as follows: %s\n", resource_uri_case4);
+
+            oc_resource_t *resource_case4 = oc_ri_get_app_resource_by_uri(resource_uri_case4, strlen(resource_uri_case4),0);
+
+            if(resource_case4 == NULL){
+                printf("!!!!!Resource not found!!!!!\nPlease choose 'Option 33', 'sub-option 4' again and enter approriate URI\n");
+            }
+            else{
+
+            unsigned int count_case4_2 = 25;
+            char* resource_property_case4 = malloc((size_t)count_case4_2);
+
+            int resourceInterfaceIntegerValue = 1;
+
+            while(resourcePropertyOptionNumber != 0)
+            {
+            case4_label:
+                printf("\t\t..................\n");
+                printf("\t\tUpdate resource properties:\n");
+                printf("\t\t..................\n");
+                printf("\t\tChoose from below options by entering the option number\n\t\t1. Update resource type\n"
+                "\t\t2. Update resource interface\n\t\t3. Update resource path\n\t\t0. Exit Update Resource Properties\n");
+
+                int scanf_returnValue_case4_2 = scanf("%d",&resourcePropertyOptionNumber);
+                if(scanf_returnValue_case4_2)
+                {
+                    if(resourcePropertyOptionNumber == 0)
+                    {
+                        printf("'Exit Update Resource Properties' chosen\n");
+                        break;
+                    }
+                    else if(resourcePropertyOptionNumber == 1)
+                    {
+                        printf("Option 1 chosen.\n");
+                        printf("Presently, resource type is '%s'\n",resource_case4->types.ptr);
+                        printf("Please enter new 'resource type'\n");
+                        int scanf_returnValue_case4_3 = scanf("%s", resource_property_case4);
+                        if(scanf_returnValue_case4_3)
+                        printf("\nResource property read is as follows: %s\n", resource_property_case4);
+                    }
+                    else if(resourcePropertyOptionNumber == 2)
+                    {
+                        printf("\nOption 2 chosen.\n");
+                        printf("Presently, interface value is %d\n\n",resource_case4->interfaces);
+                        printf("Please enter a suitable integer number using the guide below\nto have the required interfaces for the resource\n\n");
+                        printf("2: corresponds to Baseline(OC_IF_BASELINE) interface\n"
+                            "4: corresponds to Link Lists(OC_IF_LL) interface\n"
+                            "8: corresponds to Batch(OC_IF_B) interface\n"
+                            "16: corresponds to Read-only(OC_IF_R) interface\n"
+                            "32: corresponds to Read-Write(OC_IF_RW) interface\n"
+                            "64: corresponds to Actuator(OC_IF_A) interface\n"
+                            "128: corresponds to Sensor(OC_IF_S) interface\n");
+                        printf("66(2+64): corresponds to interfaces of Baseline(2) and Actuator(64)\n");
+                        printf("18(2+16): corresponds to interfaces of Baseline(2) and Read-only(16)\netc.,\n");
+                        int scanf_returnValue_case4_4 = scanf("%d",&resourceInterfaceIntegerValue);
+                        if (scanf_returnValue_case4_4)
+                            printf("Resource Interface Integer Value entered: %d\n", resourceInterfaceIntegerValue);
+
+                    }
+                    else if (resourcePropertyOptionNumber == 3)
+                    {
+                        printf("Option 3 chosen.\n");
+                        printf("Presently, resource uri is '%s'\n",resource_case4->uri.ptr);
+                        printf("Please enter new 'resource URI'\n");
+                        int scanf_returnValue_case4_5 = scanf("%s", resource_property_case4);
+                        if(scanf_returnValue_case4_5)
+                        printf("\nNew URI read is as follows: %s\n", resource_property_case4);
+                    }
+                    else
+                    {
+                        printf("!!!!!!!!Invalid option chosen!!!!!!!!\n");
+                        goto case4_label;
+                    }
+                }
+                else
+                    printf("Read from scanf was unsuccessful\n");
+
+                switch(resourcePropertyOptionNumber)
+                {
+                    case 1:
+                        printf("\nResource type of resource '%s' before updation: %s\n",resource_case4->name.ptr,resource_case4->types.ptr);
+                        resource_case4->types.ptr = resource_property_case4;
+                        printf("Resource type of resource '%s' after updation: %s\n", resource_case4->name.ptr,
+                        resource_case4->types.ptr);
+                        break;
+
+                    case 2:
+                        printf("\nResource interface of resource '%s' before updation: %d\n", resource_case4->name.ptr,
+                        resource_case4->interfaces);
+
+                        resource_case4->interfaces = resourceInterfaceIntegerValue;
+
+                        printf("Resource interface of resource '%s' after updation: %d\n", resource_case4->name.ptr,
+                        resource_case4->interfaces);
+                        break;
+
+                    case 3:
+                        printf("\nResource URI of resource '%s' before updation: %s\n", resource_case4->name.ptr,
+                        resource_case4->uri.ptr);
+                        resource_case4->uri.ptr = resource_property_case4;
+                        printf("Resource URI of resource '%s' after updation: %s\n", resource_case4->name.ptr,
+                        resource_case4->uri.ptr);
+                        break;
+
+                    default: printf("Entered 'default case' of switch statement in 'case 4' of outer switch statement\n");
+                        break;
+                }
+            }
+            }
+            break;
+
+        default: printf("!!!!Invalid Option Entered!!!!\n");
+            break;
+    }
+
+    }
+
+    return tempCollection;
+}
+
+/* Following function takes a resource URI as input and allows for the updation of the resource's
+properties(namely type, interface and path) */
+static void updateLocalResourceManually(char* uri_input)
+{
+    oc_resource_t *resource = oc_ri_get_app_resource_by_uri(uri_input, strlen(uri_input),0);
+    if(resource == NULL){
+        printf("\n!!!!!Resource not found!!!!!\nPlease choose 'Option 34' again and enter approriate URI\n");
+        return;
+    }
+    else{
+    unsigned int count_case4_2 = 25;
+    char* resource_property_case4 = malloc((size_t)count_case4_2);
+
+    int resourcePropertyOptionNumber = -1;
+    int resourceInterfaceIntegerValue = 1;
+            while(resourcePropertyOptionNumber != 0)
+            {
+            case4_label:
+                printf("\t\t..................\n");
+                printf("\t\tUpdate resource properties:\n");
+                printf("\t\t..................\n");
+                printf("\t\tChoose from below options by entering the option number\n\t\t1. Update resource type\n"
+                       "\t\t2. Update resource interface\n\t\t3. Update resource path\n\t\t0. Exit Update Resource Properties\n");
+
+                int scanf_returnValue_case4_2 = scanf("%d",&resourcePropertyOptionNumber);
+                if(scanf_returnValue_case4_2)
+                {
+                    if(resourcePropertyOptionNumber == 0)
+                    {
+                        printf("'Exit Update Resource Properties' chosen\n");
+                        break;
+                    }
+                    else if(resourcePropertyOptionNumber == 1)
+                    {
+                        printf("Option 1 chosen.\n");
+                        printf("Presently, resource type is '%s'\n",resource->types.ptr);
+                        printf("Please enter new 'resource type'\n");
+                        int scanf_returnValue_case4_3 = scanf("%s", resource_property_case4);
+                        if(scanf_returnValue_case4_3)
+                        printf("\nResource property read is as follows: %s\n", resource_property_case4);
+                    }
+                    else if(resourcePropertyOptionNumber == 2)
+                    {
+                        printf("\nOption 2 chosen.\n");
+                        printf("Presently, interface value is %d\n\n",resource->interfaces);
+                        printf("Please enter a suitable integer number using the guide below\nto have the required interfaces for the resource\n\n");
+                        printf("2: corresponds to Baseline(OC_IF_BASELINE) interface\n"
+                            "4: corresponds to Link Lists(OC_IF_LL) interface\n"
+                            "8: corresponds to Batch(OC_IF_B) interface\n"
+                            "16: corresponds to Read-only(OC_IF_R) interface\n"
+                            "32: corresponds to Read-Write(OC_IF_RW) interface\n"
+                            "64: corresponds to Actuator(OC_IF_A) interface\n"
+                            "128: corresponds to Sensor(OC_IF_S) interface\n");
+                        printf("66(2+64): corresponds to interfaces of Baseline(2) and Actuator(64)\n");
+                        printf("18(2+16): corresponds to interfaces of Baseline(2) and Read-only(16)\netc.,\n");
+                        int scanf_returnValue_case4_4 = scanf("%d",&resourceInterfaceIntegerValue);
+                        if (scanf_returnValue_case4_4)
+                            printf("Resource Interface Integer Value entered: %d\n", resourceInterfaceIntegerValue);
+
+                    }
+                    else if (resourcePropertyOptionNumber == 3)
+                    {
+                        printf("Option 3 chosen.\n");
+                        printf("Presently, resource uri is '%s'\n",resource->uri.ptr);
+                        printf("Please enter new 'resource URI'\n");
+                        int scanf_returnValue_case4_5 = scanf("%s", resource_property_case4);
+                        if(scanf_returnValue_case4_5)
+                        printf("\nNew URI read is as follows: %s\n", resource_property_case4);
+                    }
+                    else
+                    {
+                        printf("!!!!!!!!Invalid option chosen!!!!!!!!\n");
+                        goto case4_label;
+                    }
+                }
+                else
+                    printf("Read from scanf was unsuccessful\n");
+
+                switch(resourcePropertyOptionNumber)
+                {
+                    case 1: printf("\nResource type before updation: %s\n",resource->types.ptr);
+                        resource->types.ptr = resource_property_case4;
+                        printf("Resource type after updation: %s\n",resource->types.ptr);
+                        break;
+
+                    case 2:
+                        printf("\nResource interface before updation: %d\n",resource->interfaces);
+                        resource->interfaces = resourceInterfaceIntegerValue;
+                        printf("Resource interface after updation: %d\n",resource->interfaces);
+                        break;
+
+                    case 3:printf("\nResource URI before updation: %s\n",resource->uri.ptr);
+                        resource->uri.ptr = resource_property_case4;
+                        printf("Resource URI after updation: %s\n",resource->uri.ptr);
+                        break;
+
+                    default: printf("Entered 'default case' of switch statement\n");
+                        break;
+                }
+            }
+    }
+}
+
+/* Following function takes a collection URI as input and obtains the collection's pointer and prints
+the collection name */
+static void findGroup(char* uri_input)
+{
+
+    printf("\nFind Group option chosen\n");
+
+    printf("\nparameter passed: %s\n",uri_input);
+
+    oc_collection_t* tempCollection_findGroup = oc_get_collection_by_uri(uri_input, strlen(uri_input), 0);
+
+    if(tempCollection_findGroup == NULL)
+        printf("\nGroup does not exist\n");
+    else
+        printf("\nGroup found. Collection name is %s\n\n", tempCollection_findGroup->name.ptr);
+
+}
+
+void
+get_binaryswitchcb(oc_request_t *request, oc_interface_mask_t interfaces, void *user_data)
+{
+    (void)user_data;  // not used
+
+    printf("get_binaryswitch: interface %d\n", interfaces);
+    oc_rep_start_root_object();
+    switch (interfaces) {
+    case OC_IF_BASELINE:
+    /* fall through */
+    case OC_IF_A:
+        printf("Adding Baseline info\n" );
+        oc_process_baseline_interface(request->resource);
+        oc_rep_set_boolean(root, value, g_binaryswitch_valuecb);
+        printf("   %s : %d\n", g_binaryswitch_RESOURCE_PROPERTY_NAME_value,  g_binaryswitch_valuecb );
+        break;
+        default:
+        break;
+    }
+    oc_rep_end_root_object();
+    oc_send_response(request, OC_STATUS_OK);
+}
+
+/*binary switch call back */
+void
+post_binaryswitchcb(oc_request_t *request, oc_interface_mask_t interfaces, void *user_data)
+{
+    (void)interfaces;
+    (void)user_data;
+    bool error_state = false;
+    printf("post_binaryswitch:\n");
+    oc_rep_t *rep = request->request_payload;
+    while (rep != NULL) {
+        printf("key: (check) %s ", oc_string(rep->name));
+        if (strcmp ( oc_string(rep->name), g_binaryswitch_RESOURCE_PROPERTY_NAME_value) == 0) {
+    /*
+    value exists in payload
+    */
+            if (rep->type != OC_REP_BOOL)
+                {
+                    error_state = true;
+                    printf ("   property 'value' is not of type bool %d \n", rep->type);
+            }
+        }
+                rep = rep->next;
+    }
+           if (error_state == false) {
+              oc_rep_t *rep = request->request_payload;
+              while (rep != NULL) {
+                    printf("key: (assign) %s ", oc_string(rep->name));
+                   /* no error: assign the variables */
+                    if (strcmp ( oc_string(rep->name), g_binaryswitch_RESOURCE_PROPERTY_NAME_value)== 0){
+                      /* assign value */
+                       g_binaryswitch_valuecb = rep->value.boolean;
+                    }
+                       rep = rep->next;
+            }
+                      /* set the response */
+                      oc_rep_start_root_object();
+                      oc_rep_set_boolean(root, value, g_binaryswitch_valuecb);
+                      oc_rep_end_root_object();
+                      oc_send_response(request, OC_STATUS_CHANGED);
+            }
+          else {
+              /* TODO: add error response, if any */
+              oc_send_response(request, OC_STATUS_NOT_MODIFIED);
+          }
+}
+
+int  app_init1()
+ {
+
+    int  ret = oc_init_platform(ENGLISH_NAME_VALUE, NULL, NULL);
+    ret |= oc_add_device("oic/d", "oic.d.airconditioner", "AirConditioner",
+                             OCF_SPEC_VERSION, OCF_DATA_MODEL_VERSION,
+                             NULL, NULL);
+    return ret;
+}
+
+
+/*using the  uri creating the air conditioner resource*/
+static void createSingleAirConResource()
+{
+    printf("Creating AirCon Device Resources!!\n");
+
+    if (g_isAirConDeviceCreated == false) {
+
+        int init;
+        static const oc_handler_t handler = {.init = app_init1,
+                                       .signal_event_loop = signal_event_loop,
+                                       };
+
+        init = oc_main_init(&handler);
+
+        if (init < 0)
+            printf("Not Able to Intialize the mainHandler");
+
+
+       oc_resource_t *res = oc_new_resource("AC-binaryswitch", RESOURCE_AIR_URI, RESOURCE_INTERFACE, DEVICE_COUNT);
+       oc_resource_bind_resource_type(res,SWITCH_RESOURCE_TYPE);
+       for ( int a = 0; a < RESOURCE_INTERFACE; a++ )
+            {
+                oc_resource_bind_resource_interface(res, convert_if_string(g_binaryswitch_AIRCON_RESOURCE_INTERFACE[a]));
+            }
+       oc_resource_set_discoverable(res, true);
+       oc_resource_set_periodic_observable(res, OBSERVE_PERIODIC);
+       oc_resource_set_request_handler(res, OC_GET, get_binaryswitchcb, NULL);
+       oc_resource_set_request_handler(res, OC_POST, post_binaryswitchcb, NULL);
+       bool add_res = oc_add_resource(res);
+
+       if (add_res == true) {
+           printf("AirCon Binary Switch Resource created successfully\n");
+           g_isAirConDeviceCreated = true;
+       }
+       else {
+            printf("Unable to create AirCon Binary Switch resource\n");
+       }
+    }
+    else
+    {
+        printf("Already Smart Home Air Conditioner Device Resource is created!!\n");
+    }
+}
+
+/*running the main poll inside the thread function*/
+static void *
+process_func(void *data)
+{
+    (void)data;
+    oc_clock_time_t next_event;
+
+    while (quit != 1) {
+        pthread_mutex_lock(&app_mutex);
+        next_event = oc_main_poll();
+        pthread_mutex_unlock(&app_mutex);
+        pthread_mutex_lock(&mutex);
+        if (next_event == 0) {
+        /* printf("\nwaiting at process_func \n"); */
+            fflush(stdout);
+            pthread_cond_wait(&cv, &mutex);
+        }
+        else {
+            ts.tv_sec = (next_event / OC_CLOCK_SECOND);
+            ts.tv_nsec = (next_event % OC_CLOCK_SECOND) * 1.e09 / OC_CLOCK_SECOND;
+            pthread_cond_timedwait(&cv, &mutex, &ts);
+        }
+        pthread_mutex_unlock(&mutex);
+    }
+    pthread_exit(0);
+}
+
+int main( int argc, char* argv[])
+{
+    struct sigaction sa;
+
+    sigfillset(&sa.sa_mask);
+    sa.sa_flags = 0;
+    sa.sa_handler = handle_signal;
+    sigaction(SIGINT, &sa, NULL);
+    oc_set_con_res_announced(false);
+    oc_set_mtu_size(4096);
+    oc_set_max_app_data_size(16384);
+
+    int init;
+    static const oc_handler_t handler = {.init = app_init,
+                                       .signal_event_loop = signal_event_loop
+                                      // .register_resources = register_resources
+    #ifdef OC_CLIENT
+                                       ,
+                                       .requests_entry = 0
+    #endif
+                                       };
+
+
+    #ifdef OC_SECURITY
+        oc_storage_config("./CertificationApp_creds/");
+    #endif /* OC_SECURITY */
+
+  if (pthread_mutex_init(&mutex, NULL) < 0) {
+    printf("pthread_mutex_init failed!\n");
+    return -1;
+  }
+
+  if (pthread_mutex_init(&app_mutex, NULL) < 0) {
+    printf("pthread_mutex_init failed!\n");
+    pthread_mutex_destroy(&mutex);
+    return -1;
+  }
+
+    init = oc_main_init(&handler);
+    if (argc > 1) {
+        int optionSelected = atoi(argv[1]);
+           if (optionSelected == 1) {
+               printf("Using CON Server\n");
+               g_qos = HIGH_QOS;
+            }
+            else if (optionSelected == 0) {
+                printf("Using NON Server\n");
+            }
+        else {
+            printf("Invalid input argument. Using default QoS: NON\n");
+        }
+    }
+    else {
+        printf("No QoS supplied. Using default: NON\n");
+
+    }
+    if (argc > 2) {
+        int optionSelected = atoi(argv[1]);
+           if (optionSelected == 2) {
+               printf("option not implemented\n");
+           }
+    }
+
+    if (argc > 3) {
+        int optionSelected = atoi(argv[3]);
+        g_securityType = optionSelected % 10;
+
+        if (g_securityType == 3) {
+            printf("Supported Security Mode: manufacturing certificate\n");
+            int credid = oc_pki_add_mfg_cert(0, my_crt, sizeof(my_crt), my_key, sizeof(my_key));
+
+            oc_pki_add_mfg_intermediate_cert(0, credid, int_ca, sizeof(int_ca));
+
+            oc_pki_add_mfg_trust_anchor(0, root_ca, sizeof(root_ca));
+
+            oc_pki_set_security_profile(0, OC_SP_BLACK, OC_SP_BLACK, credid);
+
+        }
+    }
+
+    if (init < 0)
+        return init;
+                    pthread_t thread;
+    if (pthread_create(&thread, NULL, process_func, NULL) != 0) {
+       printf("Failed to create main thread\n");
+       init = -1;
+       goto exit;
+    }
+
+    while (quit != 1) {
+       showMenu(0, NULL);
+
+       /* Take the input from user and do the selected operation*/
+       handleMenu();
+    }
+    pthread_join(thread, NULL);
+    exit:
+    oc_free_string(&name);
+    free_all_buffer();
+    oc_main_shutdown();
+    pthread_mutex_destroy(&mutex);
+    pthread_mutex_destroy(&app_mutex);
+    return 0;
+}
+
+/*Entering option no  as choice to execute operation*/
+void handleMenu()
+{
+    int choice;
+    do {
+           if (scanf("%d", &choice)) {
+               printf("\n");
+               if (!quit) {
+                  selectMenu(choice);
+                  showMenu(0, NULL);
+               }
+            }
+    } while(choice && (quit == 0));
+}
diff --git a/apps/CertificationApp.json b/apps/CertificationApp.json
new file mode 100644
index 00000000..93a9065e
--- /dev/null
+++ b/apps/CertificationApp.json
@@ -0,0 +1,32 @@
+{
+    "device": "test1",
+    "company": "Open Connectivity Foundation",
+    "role": "Server",
+    "supportedVerticalProfile": [
+        "Smart Home"
+    ],
+    "supportedDeviceTypes": [
+        "None"
+    ],
+    "icv": "ocf.1.0.0",
+    "dmv": "ocf.res.1.3.0, ocf.sh.1.3.0",
+    "resources": [
+        "oic.r.csr",
+        "oic.r.crl",
+        "oic.r.roles",
+
+        "oic.r.switch.binary",
+
+        "oic.r.humidity"
+],
+    "jurisdictionSwitch": false,
+    "OTM": [
+        "oic.sec.doxm.jw"
+    ],
+    "contentFormatVersion": [ "1.0.0" ],
+    "acceptVersion": [ "1.0.0" ],
+
+    "multiValueQuerySupport": false,
+    "observableOICRES": false,
+    "persistentDeviceuuid": false
+}
\ No newline at end of file
diff --git a/apps/CertificationApp_Example.json b/apps/CertificationApp_Example.json
new file mode 100644
index 00000000..8881114a
--- /dev/null
+++ b/apps/CertificationApp_Example.json
@@ -0,0 +1,22 @@
+[
+
+    {
+      "path" : "/binaryswitch",
+      "rt"   : [ "oic.r.switch.binary" ],
+      "if"   : ["oic.if.a", "oic.if.baseline" ],
+      "remove_properties" : [ "range", "step" , "id", "precision" ]
+    },
+    {
+      "path" : "/oic/p",
+      "rt"   : [ "oic.wk.p" ],
+      "if"   : ["oic.if.baseline", "oic.if.r" ],
+      "remove_properties" : [ "n", "range", "value", "step", "precision", "vid"  ]
+    },
+    {
+      "path" : "/humidity",
+      "rt"   : [ "oic.r.humidity" ],
+      "if"   : ["oic.if.a", "oic.if.baseline" ],
+      "remove_properties" : [ "range", "step" , "id", "precision" ]
+    }
+
+]
\ No newline at end of file
diff --git a/apps/device_builder_server.c b/apps/device_builder_server.c
new file mode 100644
index 00000000..c63547ac
--- /dev/null
+++ b/apps/device_builder_server.c
@@ -0,0 +1,571 @@
+//******************************************************************
+//
+// Copyright 2017 Open Connectivity Foundation
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=/
+
+/* Application Design
+*
+* support functions:
+* app_init
+*  initializes the oic/p and oic/d values.
+* register_resources
+*  function that registers all endpoints, e.g. sets the RETRIEVE/UPDATE handlers for each end point
+*
+* main 
+*  starts the stack, with the registered resources.
+*
+* Each endpoint has:
+*  global variables for:
+*    the property name
+*       naming convention: g_<path>_RESOURCE_PROPERTY_NAME_<propertyname>
+*    the actual value of the property, which is typed from the json data type
+*      naming convention: g_<path>_<propertyname>
+*    the path in a variable:
+*      naming convention: g_<path>_RESOURCE_ENDPOINT
+*    array of interfaces, where by the first will be set as default interface
+*      naming convention g_<path>_RESOURCE_INTERFACE
+*
+*  handlers for the implemented methods (get/post)
+*   get_<path>
+*     function that is being called when a RETRIEVE is called on <path>
+*     set the global variables in the output
+*   post_<path>
+*     function that is being called when a UPDATE is called on <path>
+*     checks the input data
+*     if input data is correct
+*       updates the global variables
+*
+*/
+/*
+ tool_version          : 20171123
+ input_file            : ../device_output/out_codegeneration_merged.swagger.json
+ version of input_file : v1.1.0-20160519
+ title of input_file   : Binary Switch
+*/
+
+#include "oc_api.h"
+#include "port/oc_clock.h"
+#include <signal.h>
+
+#ifdef __linux__
+// linux specific code
+#include <pthread.h>
+
+#endif
+
+#ifdef WIN32
+// windows specific code
+#include <windows.h>
+static CONDITION_VARIABLE cv;   // event loop variable
+static CRITICAL_SECTION cs;     // event loop variable
+#endif
+
+#define MAX_STRING 65   // max size of the strings.
+volatile int quit = 0;  // stop variable, used by handle_signal
+pthread_mutex_t mutex;
+pthread_cond_t cv;
+struct timespec ts;
+
+// global variables for path: /binaryswitch
+static char g_binaryswitch_RESOURCE_PROPERTY_NAME_value[] = "value"; // the name for the attribute
+bool g_binaryswitch_value = false; // current value of property "value" Status of the switch
+// global variables for path: /humidity
+static char g_humidity_RESOURCE_PROPERTY_NAME_desiredHumidity[] = "desiredHumidity"; // the name for the attribute
+int g_humidity_desiredHumidity = 40; // current value of property "desiredHumidity" Desired value for Humidity
+static char g_humidity_RESOURCE_PROPERTY_NAME_humidity[] = "humidity"; // the name for the attribute
+int g_humidity_humidity = 40; // current value of property "humidity" Current sensed value for Humidity// registration data variables for the resources
+static char g_binaryswitch_RESOURCE_ENDPOINT[] = "/binaryswitch";  // used path for this resource
+static char g_binaryswitch_RESOURCE_TYPE[][MAX_STRING] = {"oic.r.switch.binary"}; // rt value (as an array)
+int g_binaryswitch_nr_resource_types = 1;
+static char g_binaryswitch_RESOURCE_INTERFACE[][MAX_STRING] = {"oic.if.a","oic.if.baseline"}; // interface if (as an array) 
+int g_binaryswitch_nr_resource_interfaces = 2;
+static char g_humidity_RESOURCE_ENDPOINT[] = "/humidity";  // used path for this resource
+static char g_humidity_RESOURCE_TYPE[][MAX_STRING] = {"oic.r.humidity"}; // rt value (as an array)
+int g_humidity_nr_resource_types = 1;
+static char g_humidity_RESOURCE_INTERFACE[][MAX_STRING] = {"oic.if.a","oic.if.baseline"}; // interface if (as an array) 
+int g_humidity_nr_resource_interfaces = 2;
+/**
+* function to set up the device.
+*
+*/
+int
+app_init(void)
+{
+  int ret = oc_init_platform("ocf", NULL, NULL);
+  ret |= oc_add_device("/oic/d", "oic.d.dehumidifier", "binaryswitch", 
+                       "ocf.2.0.0", // icv value
+                       "ocf.res.2.0.0, ocf.sh.2.0.0",  // dmv value
+                       NULL, NULL);
+  return ret;
+}
+
+/**
+*  function to convert the interface string definition to the constant
+* @param interface the interface string e.g. "oic.if.a"
+*/
+int convert_if_string(char *interface_name)
+{
+  if (strcmp(interface_name, "oic.if.baseline") == 0) return OC_IF_BASELINE;
+  if (strcmp(interface_name, "oic.if.rw") == 0) return OC_IF_RW;
+  if (strcmp(interface_name, "oic.if.r" )== 0) return OC_IF_R;
+  if (strcmp(interface_name, "oic.if.s") == 0) return OC_IF_S;
+  if (strcmp(interface_name, "oic.if.a") == 0) return OC_IF_A;
+  if (strcmp(interface_name, "oic.if.b") == 0) return OC_IF_B;
+  //if strcmp(interface_name, "oic.if.lb") == 0) return OC_IF_LB;
+  if (strcmp(interface_name, "oic.if.ll") == 0) return OC_IF_LL;
+  return OC_IF_A;
+}
+
+/**
+* get method for "/binaryswitch" endpoint to intialize the returned values from the global values
+* This resource describes a binary switch (on/off).
+* The value is a boolean.
+* A value of 'true' means that the switch is on.
+* A value of 'false' means that the switch is off.
+* @param request the request representation.
+* @param interfaces the interface used for this call
+* @param user_data the user data.
+*/
+void
+get_binaryswitch(oc_request_t *request, oc_interface_mask_t interfaces, void *user_data)
+{
+  (void)user_data;  // not used
+  
+  // TODO: SENSOR add here the code to talk to the HW if one implements a sensor.
+  // the calls needs to fill in the global variable before it is returned.
+  // alternative is to have a callback from the hardware that sets the global variables
+  
+  // the current implementation always return everything that belongs to the resource.
+  // this kind of implementation is not optimal, but is correct and will pass CTT1.2.2
+  
+  PRINT("get_binaryswitch: interface %d\n", interfaces);
+  oc_rep_start_root_object();
+  switch (interfaces) {
+  case OC_IF_BASELINE:
+    /* fall through */
+  case OC_IF_A:
+  PRINT("   Adding Baseline info\n" );
+    oc_process_baseline_interface(request->resource);
+    oc_rep_set_boolean(root, value, g_binaryswitch_value); 
+    PRINT("   %s : %d\n", g_binaryswitch_RESOURCE_PROPERTY_NAME_value,  g_binaryswitch_value );
+    break;
+  default:
+    break;
+  }
+  oc_rep_end_root_object();
+  oc_send_response(request, OC_STATUS_OK);
+}
+ 
+/**
+* get method for "/humidity" endpoint to intialize the returned values from the global values
+* This resource describes a sensed or desired humidity.
+* The value humidity is an integer describing the percentage measured relative humidity.
+* The value desiredHumidity is an integer showing the desired target relative humidity.
+* Retrieves the current (relative) humidity level.
+* @param request the request representation.
+* @param interfaces the interface used for this call
+* @param user_data the user data.
+*/
+void
+get_humidity(oc_request_t *request, oc_interface_mask_t interfaces, void *user_data)
+{
+  (void)user_data;  // not used
+  
+  // TODO: SENSOR add here the code to talk to the HW if one implements a sensor.
+  // the calls needs to fill in the global variable before it is returned.
+  // alternative is to have a callback from the hardware that sets the global variables
+  
+  // the current implementation always return everything that belongs to the resource.
+  // this kind of implementation is not optimal, but is correct and will pass CTT1.2.2
+  
+  PRINT("get_humidity: interface %d\n", interfaces);
+  oc_rep_start_root_object();
+  switch (interfaces) {
+  case OC_IF_BASELINE:
+    /* fall through */
+  case OC_IF_A:
+  PRINT("   Adding Baseline info\n" );
+    oc_process_baseline_interface(request->resource);
+    oc_rep_set_int(root, desiredHumidity, g_humidity_desiredHumidity ); 
+    PRINT("   %s : %d\n", g_humidity_RESOURCE_PROPERTY_NAME_desiredHumidity, g_humidity_desiredHumidity );
+    
+    oc_rep_set_int(root, humidity, g_humidity_humidity ); 
+    PRINT("   %s : %d\n", g_humidity_RESOURCE_PROPERTY_NAME_humidity, g_humidity_humidity );
+    break;
+  default:
+    break;
+  }
+  oc_rep_end_root_object();
+  oc_send_response(request, OC_STATUS_OK);
+}
+ 
+/**
+* post method for "/binaryswitch" endpoint to assign the returned values to the global values.
+
+* @param requestRep the request representation.
+*/
+void
+post_binaryswitch(oc_request_t *request, oc_interface_mask_t interfaces, void *user_data)
+{
+  (void)interfaces;
+  (void)user_data;
+  bool error_state = false;
+  PRINT("post_binaryswitch:\n");
+  oc_rep_t *rep = request->request_payload;
+  while (rep != NULL) {
+    PRINT("key: (check) %s ", oc_string(rep->name));if (strcmp ( oc_string(rep->name), g_binaryswitch_RESOURCE_PROPERTY_NAME_value) == 0)
+    {
+      // value exist in payload
+      
+      if (rep->type != OC_REP_BOOL)
+      {
+        error_state = true;
+        PRINT ("   property 'value' is not of type bool %d \n", rep->type);
+      }
+    }
+    
+    
+    rep = rep->next;
+  }
+  if (error_state == false)
+  {
+    oc_rep_t *rep = request->request_payload;
+    while (rep != NULL) {
+      PRINT("key: (assign) %s ", oc_string(rep->name));
+      // no error: assign the variables
+      if (strcmp ( oc_string(rep->name), g_binaryswitch_RESOURCE_PROPERTY_NAME_value)== 0)
+      {
+        // assign value
+        g_binaryswitch_value = rep->value.boolean;
+      }
+      rep = rep->next;
+    }
+    // set the response
+    oc_rep_start_root_object();
+    //oc_process_baseline_interface(request->resource);
+    oc_rep_set_boolean(root, value, g_binaryswitch_value); 
+    oc_rep_end_root_object();
+    
+    // TODO: ACTUATOR add here the code to talk to the HW if one implements an actuator.
+    // one can use the global variables as input to those calls
+    // the global values have been updated already with the data from the request
+    
+    oc_send_response(request, OC_STATUS_CHANGED);
+  }
+  else
+  {
+    // TODO: add error response, if any
+    /*CTT expects error message from IUT when test cases CT1.2.3 and CT1.2.13 are run. 
+    So OC_STATUS_NOT_MODIFIED has been changed to OC_STATUS_BAD_REQUEST below */
+    oc_send_response(request, OC_STATUS_BAD_REQUEST);
+  }
+}
+ 
+/**
+* post method for "/humidity" endpoint to assign the returned values to the global values.
+* Sets the desired relative humidity level.
+* @param requestRep the request representation.
+*/
+void
+post_humidity(oc_request_t *request, oc_interface_mask_t interfaces, void *user_data)
+{
+  (void)interfaces;
+  (void)user_data;
+  bool error_state = false;
+  PRINT("post_humidity:\n");
+  oc_rep_t *rep = request->request_payload;
+  while (rep != NULL) {
+    PRINT("key: (check) %s ", oc_string(rep->name));
+    if (strcmp ( oc_string(rep->name), g_humidity_RESOURCE_PROPERTY_NAME_desiredHumidity) == 0)
+    {
+      int value = rep->value.integer;
+      // value exist in payload
+      
+      if (rep->type != OC_REP_INT)
+      {
+        error_state = true;
+        PRINT ("   property 'desiredHumidity' is not of type int %d \n", rep->type);
+      }
+      
+      if ( value > 100 )
+      {
+        // check the maximum range
+        PRINT ("   property 'desiredHumidity' value exceed max : 0 >  value: %d \n", value);
+        error_state = true;
+      }
+    } 
+    
+    
+    if (strcmp ( oc_string(rep->name), g_humidity_RESOURCE_PROPERTY_NAME_humidity) == 0)
+    {
+      int value = rep->value.integer;
+      // value exist in payload
+      
+      // check if "humidity" is read only
+      error_state = true;
+      PRINT ("   property 'humidity' is readOnly \n");
+      
+      if (rep->type != OC_REP_INT)
+      {
+        error_state = true;
+        PRINT ("   property 'humidity' is not of type int %d \n", rep->type);
+      }
+      
+      if ( value > 100 )
+      {
+        // check the maximum range
+        PRINT ("   property 'humidity' value exceed max : 0 >  value: %d \n", value);
+        error_state = true;
+      }
+    } 
+    
+    
+    rep = rep->next;
+  }
+  if (error_state == false)
+  {
+    oc_rep_t *rep = request->request_payload;
+    while (rep != NULL) {
+      PRINT("key: (assign) %s ", oc_string(rep->name));
+      // no error: assign the variables
+      if (strcmp ( oc_string(rep->name), g_humidity_RESOURCE_PROPERTY_NAME_desiredHumidity) == 0)
+      {
+        // assign desiredHumidity
+        g_humidity_desiredHumidity = rep->value.integer;
+      }if (strcmp ( oc_string(rep->name), g_humidity_RESOURCE_PROPERTY_NAME_humidity) == 0)
+      {
+        // assign humidity
+        g_humidity_humidity = rep->value.integer;
+      }
+      rep = rep->next;
+    }
+    // set the response
+    oc_rep_start_root_object();
+    //oc_process_baseline_interface(request->resource);
+    oc_rep_set_int(root, desiredHumidity, g_humidity_desiredHumidity ); 
+    
+    oc_rep_set_int(root, humidity, g_humidity_humidity ); 
+    oc_rep_end_root_object();
+    
+    // TODO: ACTUATOR add here the code to talk to the HW if one implements an actuator.
+    // one can use the global variables as input to those calls
+    // the global values have been updated already with the data from the request
+    
+    oc_send_response(request, OC_STATUS_CHANGED);
+  }
+  else
+  {
+    // TODO: add error response, if any
+    /*CTT expects error message from IUT when test cases CT1.2.3 and CT1.2.13 are run. 
+    So OC_STATUS_NOT_MODIFIED has been changed to OC_STATUS_BAD_REQUEST below */
+    oc_send_response(request, OC_STATUS_BAD_REQUEST);
+  }
+}
+/**
+*  register all the resources
+*/
+void register_resources(void)
+{
+PRINT("register resource with path /binaryswitch\n");
+  oc_resource_t *res_binaryswitch = oc_new_resource("NULL", g_binaryswitch_RESOURCE_ENDPOINT, g_binaryswitch_nr_resource_types, 0);
+  PRINT("     number of resource types: %d\n", g_binaryswitch_nr_resource_types);
+  for( int a = 0; a < g_binaryswitch_nr_resource_types; a++ )
+  {
+    PRINT("     resource type: %s\n", g_binaryswitch_RESOURCE_TYPE[a]);
+    oc_resource_bind_resource_type(res_binaryswitch,g_binaryswitch_RESOURCE_TYPE[a]);
+  }
+ for( int a = 0; a < g_binaryswitch_nr_resource_interfaces; a++ )
+  {
+    oc_resource_bind_resource_interface(res_binaryswitch, convert_if_string(g_binaryswitch_RESOURCE_INTERFACE[a]));
+  }
+  oc_resource_set_default_interface(res_binaryswitch, convert_if_string(g_binaryswitch_RESOURCE_INTERFACE[0]));  
+  PRINT("     default interface: %d (%s)\n", convert_if_string(g_binaryswitch_RESOURCE_INTERFACE[0]), g_binaryswitch_RESOURCE_INTERFACE[0]);
+  oc_resource_set_discoverable(res_binaryswitch, true);
+  oc_resource_set_periodic_observable(res_binaryswitch, 1);
+   
+  oc_resource_set_request_handler(res_binaryswitch, OC_GET, get_binaryswitch, NULL);
+   
+  oc_resource_set_request_handler(res_binaryswitch, OC_POST, post_binaryswitch, NULL);
+  oc_add_resource(res_binaryswitch);
+
+  PRINT("register resource with path /humidity\n");
+  oc_resource_t *res_humidity = oc_new_resource("NULL", g_humidity_RESOURCE_ENDPOINT, g_humidity_nr_resource_types, 0);
+  PRINT("     number of resource types: %d\n", g_humidity_nr_resource_types);
+  for( int a = 0; a < g_humidity_nr_resource_types; a++ )
+  {
+    PRINT("     resource type: %s\n", g_humidity_RESOURCE_TYPE[a]);
+    oc_resource_bind_resource_type(res_humidity,g_humidity_RESOURCE_TYPE[a]);
+  }
+  for( int a = 0; a < g_humidity_nr_resource_interfaces; a++ )
+  {
+    oc_resource_bind_resource_interface(res_humidity, convert_if_string(g_humidity_RESOURCE_INTERFACE[a]));
+  }
+  oc_resource_set_default_interface(res_humidity, convert_if_string(g_humidity_RESOURCE_INTERFACE[0]));  
+  PRINT("     default interface: %d (%s)\n", convert_if_string(g_humidity_RESOURCE_INTERFACE[0]), g_humidity_RESOURCE_INTERFACE[0]);
+  oc_resource_set_discoverable(res_humidity, true);
+  oc_resource_set_periodic_observable(res_humidity, 1);
+   
+  oc_resource_set_request_handler(res_humidity, OC_GET, get_humidity, NULL);
+   
+  oc_resource_set_request_handler(res_humidity, OC_POST, post_humidity, NULL);
+  oc_add_resource(res_humidity);
+}
+
+#ifdef WIN32
+/**
+* signal the event loop
+*/
+void
+signal_event_loop(void)
+{
+  WakeConditionVariable(&cv);
+}
+#endif
+#ifdef __linux__
+/**
+* signal the event loop
+*/
+void
+signal_event_loop(void)
+{
+  pthread_mutex_lock(&mutex);
+  pthread_cond_signal(&cv);
+  pthread_mutex_unlock(&mutex);
+}
+#endif
+
+/**
+* handle Ctrl-C
+* @param signal the captured signal
+*/
+void
+handle_signal(int signal)
+{
+  (void)signal;
+  signal_event_loop();
+  quit = 1;
+}
+
+/**
+* main application.
+* intializes the global variables
+* registers and starts the handler
+* handles (in a loop) the next event.
+* shuts down the stack
+*/
+/*int
+main(void)
+{
+int init;
+
+#ifdef WIN32
+  // windows specific
+  InitializeCriticalSection(&cs);
+  InitializeConditionVariable(&cv);
+  // install Ctrl-C
+  signal(SIGINT, handle_signal);
+#endif
+#ifdef __linux__
+  // linux specific
+  struct sigaction sa;
+  sigfillset(&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_handler = handle_signal;
+  // install Ctrl-C
+  sigaction(SIGINT, &sa, NULL);
+#endif
+  // initialize global variables for endpoint "/3D Printer"
+  g_3DPrinter_memorysize = 120.5; // current value of property "memorysize"  This value represents the total memory size of the printer. The unit is MB(Mega Bytes)
+  g_3DPrinter_wanconnected = false; // current value of property "wanconnected" This value indicates the connectivity capability of the 3D printer. If the value is false, the printer does not have network facility to Wide Area Network such as internet and GSM. If the value is true, the printer has network connectivity
+  g_3DPrinter_printsizex = 300.0; // current value of property "printsizex"  This represents the maximum size of printing object in the direction of X-axis. The unit is mm.
+  strcpy(g_3DPrinter_3dprinttype,"Digital Light Processing");  // current value of property "3dprinttype" The type of 3D printing technology.
+  g_3DPrinter_printsizez = 250.75; // current value of property "printsizez"  This represents the maximum size of printing object in the direction of Z-axis. The unit is mm.
+  g_3DPrinter_printsizey = 200.5; // current value of property "printsizey"  This represents the maximum size of printing object in the direction of Y-axis. The unit is mm.
+  
+  // initialize global variables for endpoint "/Audio Controls"
+  g_AudioControls_mute = false; // current value of property "mute" Mute setting of an audio rendering device
+  g_AudioControls_volume = 50; // current value of property "volume" Volume setting of an audio rendering device.
+  
+  // initialize global variables for endpoint "/binaryswitch"
+  g_binaryswitch_value = false; // current value of property "value" Status of the switch
+  
+  // initialize global variables for endpoint "/humidity"
+  g_humidity_desiredHumidity = 40; // current value of property "desiredHumidity" Desired value for Humidity
+  g_humidity_humidity = 40; // current value of property "humidity" Current sensed value for Humidity
+   
+  
+  // no oic/con resource.
+  oc_set_con_res_announced(false);
+
+  // initializes the handlers structure
+  static const oc_handler_t handler = {.init = app_init,
+                                       .signal_event_loop = signal_event_loop,
+                                       .register_resources = register_resources
+#ifdef OC_CLIENT
+                                       ,
+                                       .requests_entry = 0 
+#endif
+                                       };
+  oc_clock_time_t next_event;
+  
+  PRINT("file : ../device_output/out_codegeneration_merged.swagger.json\n");
+  PRINT("title: Binary Switch\n");
+
+#ifdef OC_SECURITY
+  PRINT("intialize secure resources\n");
+  oc_storage_config("./device_builder_server_creds/");
+#endif*/ /* OC_SECURITY */
+
+  // start the stack
+  /*init = oc_main_init(&handler);
+  if (init < 0)
+    return init;
+
+#ifdef WIN32
+  // windows specific loop
+  while (quit != 1) {
+    next_event = oc_main_poll();
+    if (next_event == 0) {
+      SleepConditionVariableCS(&cv, &cs, INFINITE);
+    } else {
+      SleepConditionVariableCS(&cv, &cs,
+                               (DWORD)(next_event / (1000 * OC_CLOCK_SECOND)));
+    }
+  }
+#endif
+  
+#ifdef __linux__
+  // linux specific loop
+  while (quit != 1) {
+    next_event = oc_main_poll();
+    pthread_mutex_lock(&mutex);
+    if (next_event == 0) {
+      pthread_cond_wait(&cv, &mutex);
+    } else {
+      ts.tv_sec = (next_event / OC_CLOCK_SECOND);
+      ts.tv_nsec = (next_event % OC_CLOCK_SECOND) * 1.e09 / OC_CLOCK_SECOND;
+      pthread_cond_timedwait(&cv, &mutex, &ts);
+    }
+    pthread_mutex_unlock(&mutex);
+  }
+#endif
+
+  // shut down the stack
+  oc_main_shutdown();
+  return 0;
+}*/
\ No newline at end of file
diff --git a/apps/discover_device.c b/apps/discover_device.c
new file mode 100644
index 00000000..b0254d5e
--- /dev/null
+++ b/apps/discover_device.c
@@ -0,0 +1,181 @@
+/*
+// Copyright (c) 2016 Intel Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#include "oc_api.h"
+#include "port/oc_clock.h"
+#include <pthread.h>
+#include <signal.h>
+#include <stdio.h>
+
+#define PRINTport(endpoint)                                                   \
+  do {                                                                         \
+    if ((endpoint).flags & IPV4) {                                             \
+      PRINT("%d",             \
+             (endpoint).addr.ipv4.port);     \
+    } else {                                                                   \
+      PRINT(                                                                   \
+        "%d",                                                             \
+         (endpoint).addr.ipv6.port);        \
+    }                                                                          \
+} while(0)
+
+#define PRINTIPaddr(endpoint)                                                  \
+  do {                                                                         \
+    if ((endpoint).flags & IPV4) {                                             \
+      PRINT("%d.%d.%d.%d", ((endpoint).addr.ipv4.address)[0],             \
+            ((endpoint).addr.ipv4.address)[1],                                 \
+            ((endpoint).addr.ipv4.address)[2],                                 \
+            ((endpoint).addr.ipv4.address)[3]);     \
+    } else {                                                                   \
+      PRINT(                                                                   \
+        "%02x%02x::%02x%02x:%02x%02x:%02x%02x:%"    \
+        "02x%"                                                                 \
+        "02x",                                                                 \
+        ((endpoint).addr.ipv6.address)[0], ((endpoint).addr.ipv6.address)[1],  \
+        ((endpoint).addr.ipv6.address)[8], ((endpoint).addr.ipv6.address)[9],  \
+        ((endpoint).addr.ipv6.address)[10],                                    \
+        ((endpoint).addr.ipv6.address)[11],                                    \
+        ((endpoint).addr.ipv6.address)[12],                                    \
+        ((endpoint).addr.ipv6.address)[13],                                    \
+        ((endpoint).addr.ipv6.address)[14],                                    \
+        ((endpoint).addr.ipv6.address)[15]);                                   \
+    }                                                                          \
+} while(0)
+pthread_mutex_t mutex;
+pthread_cond_t cv;
+struct timespec ts;
+
+int quit = 0;
+
+static int
+app_init(void)
+{
+  int ret = oc_init_platform("TAFAgent", NULL, NULL);
+  ret |= oc_add_device("/oic/d", "oic.d.phone", "Kishen's IPhone", "ocf.1.0.0",
+                       "ocf.res.1.0.0", NULL, NULL);
+  return ret;
+}
+
+#define MAX_URI_LENGTH (30)
+static char a_light[MAX_URI_LENGTH];
+static oc_endpoint_t *light_server;
+static oc_string_t name;
+static void
+signal_event_loop(void)
+{
+  pthread_mutex_lock(&mutex);
+  pthread_cond_signal(&cv);
+  pthread_mutex_unlock(&mutex);
+}
+static oc_discovery_flags_t
+discovery(const char *anchor, const char *uri, oc_string_array_t types,
+          oc_interface_mask_t interfaces, oc_endpoint_t *endpoint,
+          oc_resource_properties_t bm, void *user_data)
+{
+  (void)anchor;
+  (void)user_data;
+  (void)interfaces;
+  (void)bm;
+  int i;
+  int uri_len = strlen(uri);
+  uri_len = (uri_len >= MAX_URI_LENGTH) ? MAX_URI_LENGTH - 1 : uri_len;
+  for (i = 0; i < (int)oc_string_array_get_allocated_size(types); i++) {
+    char *t = oc_string_array_get_item(types, i);
+    if (strlen(t) == 8 && strncmp(t, "oic.wk.d", 8) == 0) {
+      light_server = endpoint;
+      strncpy(a_light, uri, uri_len);
+      a_light[uri_len] = '\0';
+
+      PRINT("Resource %s hosted at endpoints:\n", a_light);
+      oc_endpoint_t *ep = endpoint;
+      while (ep != NULL) {
+        PRINTIPaddr(*ep);
+        PRINT("\n");
+        PRINTport(*ep);
+        PRINT("\n");
+        ep = ep->next;
+      }
+
+  signal_event_loop();
+  quit = 1;
+      return OC_STOP_DISCOVERY;
+    }
+  }
+  oc_free_server_endpoints(endpoint);
+  return OC_CONTINUE_DISCOVERY;
+}
+
+static void
+issue_requests(void)
+{
+
+  oc_do_ip_discovery("oic.wk.d", &discovery, NULL);
+
+}
+
+
+void
+handle_signal(int signal)
+{
+  (void)signal;
+  signal_event_loop();
+  quit = 1;
+}
+
+int
+main(void)
+{
+  int init;
+  struct sigaction sa;
+  sigfillset(&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_handler = handle_signal;
+  sigaction(SIGINT, &sa, NULL);
+
+  static const oc_handler_t handler = {.init = app_init,
+                                       .signal_event_loop = signal_event_loop,
+                                       .requests_entry = issue_requests };
+
+  oc_clock_time_t next_event;
+
+#ifdef OC_SECURITY
+  oc_storage_config("./discover_device_creds");
+#endif               /* OC_SECURITY */
+
+  init = oc_main_init(&handler);
+  if (init < 0)
+    return init;
+
+  while (quit != 1) {
+    next_event = oc_main_poll();
+    if (quit ==1) 
+      goto exit;
+    pthread_mutex_lock(&mutex);
+    if (next_event == 0) {
+      pthread_cond_wait(&cv, &mutex);
+    } else {
+      ts.tv_sec = (next_event / OC_CLOCK_SECOND);
+      ts.tv_nsec = (next_event % OC_CLOCK_SECOND) * 1.e09 / OC_CLOCK_SECOND;
+      pthread_cond_timedwait(&cv, &mutex, &ts);
+    }
+    pthread_mutex_unlock(&mutex);
+  }
+  exit: 
+  oc_free_server_endpoints(light_server);
+  oc_free_string(&name);
+  oc_main_shutdown();
+  return 0;
+}
diff --git a/include/Certification.h b/include/Certification.h
new file mode 100644
index 00000000..b45cd18a
--- /dev/null
+++ b/include/Certification.h
@@ -0,0 +1,348 @@
+/******************************************************************
+ *
+ * Copyright 2018 GRANITE RIVER LABS All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+#define RESOURCE_NAME "lightbulb"
+#define RESOURCE_URI "/light/"
+#define NUM_RESOURCES_TYPES 1
+#define Device_TYPE_LIGHT "oic.d.light"
+#define RESOURCE_LIGHT_TYPE "core.light"
+#define MAX_LIGHT_RESOURCE_COUNT 100
+#define NUM_DEVICE 1
+#define MAX_STRING 65 
+#define FAN_INVISIBLE_URI "/device/fan-invisible"
+#define SWITCH_RESOURCE_TYPE "oic.r.switch.binary"
+#define LIGHT_COUNT 2
+#define OCF_SPEC_VERSION "ocf.1.0.0"
+#define OCF_DATA_MODEL_VERSION "ocf.res.1.3.0, ocf.sh.1.3.0"
+#define RESOURCE_1_URI "/binaryswitch"
+#define RESOURCE_2_URI "/humidity"
+#define RESOURCE_AIR_URI "/AC-binaryswitch"
+#define AIR_CON_DEVICE_URI "oic/d"
+#define MAX_URI_LENGTH (30)
+#define ENGLISH_NAME_VALUE "x.vendor.rt.airconditioner"
+#define OBSERVE_PERIODIC 1
+#define RESOURCE_INTERFACE 2
+#define DEVICE_COUNT 0
+#define CANCEL_SELECTION 0
+#define MAX_NUM_RES 100
+
+typedef struct oc_discoverResource_t
+{
+  struct oc_discoverResource_t *next;
+  oc_endpoint_t *endpoint;
+  char uri[64];
+} oc_discoverResource_t;
+
+const int CALLBACK_WAIT_MIN = 1;
+const int CALLBACK_WAIT_MAX = 5;
+
+
+static char g_binaryswitch_RESOURCE_URI[] = "/binaryswitch";
+static char g_binaryswitch_AIRCON_RESOURCE_INTERFACE[][MAX_STRING] = {"oic.if.a","oic.if.baseline"};
+
+#define PRINTport(endpoint)                                                   \
+  do {                                                                         \
+    if ((endpoint).flags & IPV4) {                                             \
+      PRINT("%d",             \
+             (endpoint).addr.ipv4.port);     \
+    } else {                                                                   \
+      PRINT(                                                                   \
+        "%d",                                                             \
+         (endpoint).addr.ipv6.port);        \
+    }                                                                          \
+} while(0)
+
+#define PRINTIPaddr(endpoint)                                                  \
+  do {                                                                         \
+    if ((endpoint).flags & IPV4) {                                             \
+      PRINT("%d.%d.%d.%d", ((endpoint).addr.ipv4.address)[0],             \
+            ((endpoint).addr.ipv4.address)[1],                                 \
+            ((endpoint).addr.ipv4.address)[2],                                 \
+            ((endpoint).addr.ipv4.address)[3]);     \
+    } else {                                                                   \
+      PRINT(                                                                   \
+        "%02x%02x::%02x%02x:%02x%02x:%02x%02x:%"    \
+        "02x%"                                                                 \
+        "02x",                                                                 \
+        ((endpoint).addr.ipv6.address)[0], ((endpoint).addr.ipv6.address)[1],  \
+        ((endpoint).addr.ipv6.address)[8], ((endpoint).addr.ipv6.address)[9],  \
+        ((endpoint).addr.ipv6.address)[10],                                    \
+        ((endpoint).addr.ipv6.address)[11],                                    \
+        ((endpoint).addr.ipv6.address)[12],                                    \
+        ((endpoint).addr.ipv6.address)[13],                                    \
+        ((endpoint).addr.ipv6.address)[14],                                    \
+        ((endpoint).addr.ipv6.address)[15]);                                   \
+    }                                                                          \
+} while(0)
+
+static void createResource();
+static void createInvisibleResource();
+static void createResourceWithUrl();
+static void createManyLightResources();
+static oc_collection_t* createGroupResource();
+static void deleteAllResources();
+static void deleteCreatedGroup();
+static void sendPOSTRequest_partialUpdate_userInput();
+static void findGroup(char *);
+static oc_collection_t* updateGroup();
+static void updateLocalResourceManually();
+static void createSingleAirConResource();
+void handleMenu();
+void selectMenu(int);
+int app_init1();
+static void  discoverDevice(bool);
+static void discoverPlatform(bool);
+static void findAllResources();
+static void discoverIntrospection();
+static void sendGetRequest();
+static void sendPutRequestUpdate(void);
+static void sendPostRequestUpdate();
+static void findResource_UserResType(char *);
+static bool is_resource_found();
+static void observe_request();
+static void stop_observe();
+int  selectResource();
+void waitForCallback();
+static void get_platform(oc_client_response_t *data);
+static void get_device(oc_client_response_t *data);
+
+extern int quit;
+pthread_mutex_t mutex;
+pthread_cond_t cv;
+struct timespec ts;
+
+extern void register_resources();
+extern int app_init(void);
+extern void signal_event_loop();
+extern void handle_signal();
+extern int convert_if_string(char *);
+
+  const unsigned char my_crt[] = {
+    0x30, 0x82, 0x03, 0xf8, 0x30, 0x82, 0x03, 0x9e, 0xa0, 0x03, 0x02, 0x01,
+    0x02, 0x02, 0x09, 0x00, 0x8d, 0x0a, 0xfb, 0x7b, 0x53, 0xb2, 0x4c, 0xb6,
+    0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02,
+    0x30, 0x5b, 0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c,
+    0x03, 0x4f, 0x43, 0x46, 0x31, 0x22, 0x30, 0x20, 0x06, 0x03, 0x55, 0x04,
+    0x0b, 0x0c, 0x19, 0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x65, 0x73,
+    0x74, 0x20, 0x49, 0x6e, 0x66, 0x72, 0x61, 0x73, 0x74, 0x72, 0x75, 0x63,
+    0x74, 0x75, 0x72, 0x65, 0x31, 0x27, 0x30, 0x25, 0x06, 0x03, 0x55, 0x04,
+    0x03, 0x0c, 0x1e, 0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x45, 0x53,
+    0x54, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6d, 0x65, 0x64, 0x69, 0x61,
+    0x74, 0x65, 0x20, 0x43, 0x41, 0x30, 0x30, 0x30, 0x32, 0x30, 0x1e, 0x17,
+    0x0d, 0x31, 0x38, 0x31, 0x32, 0x31, 0x33, 0x31, 0x33, 0x33, 0x36, 0x33,
+    0x30, 0x5a, 0x17, 0x0d, 0x31, 0x39, 0x30, 0x36, 0x31, 0x31, 0x31, 0x33,
+    0x33, 0x36, 0x33, 0x30, 0x5a, 0x30, 0x61, 0x31, 0x0c, 0x30, 0x0a, 0x06,
+    0x03, 0x55, 0x04, 0x0a, 0x0c, 0x03, 0x4f, 0x43, 0x46, 0x31, 0x22, 0x30,
+    0x20, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x19, 0x4b, 0x79, 0x72, 0x69,
+    0x6f, 0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x49, 0x6e, 0x66, 0x72, 0x61,
+    0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x31, 0x2d, 0x30,
+    0x2b, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x24, 0x39, 0x39, 0x30, 0x30,
+    0x30, 0x30, 0x31, 0x30, 0x2d, 0x31, 0x31, 0x31, 0x31, 0x2d, 0x31, 0x31,
+    0x31, 0x31, 0x2d, 0x31, 0x31, 0x31, 0x31, 0x2d, 0x31, 0x31, 0x31, 0x31,
+    0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x59, 0x30, 0x13,
+    0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a,
+    0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0xe4,
+    0xbf, 0xcf, 0x9a, 0x29, 0x2d, 0x91, 0x54, 0x4b, 0x6d, 0x2c, 0x67, 0x38,
+    0x7b, 0xe8, 0x7c, 0x58, 0x96, 0x60, 0x40, 0xc7, 0x72, 0xc2, 0x41, 0xb7,
+    0x6f, 0xa6, 0x1a, 0x09, 0xe8, 0x85, 0x96, 0xad, 0x02, 0x4c, 0x95, 0xbf,
+    0x67, 0x75, 0x24, 0x88, 0x98, 0x3c, 0x2a, 0x9a, 0xdb, 0x95, 0x96, 0x62,
+    0x74, 0xce, 0x2d, 0x79, 0xe8, 0x30, 0xfa, 0x4c, 0x4a, 0x97, 0x5e, 0xaf,
+    0xb9, 0xb3, 0x5c, 0xa3, 0x82, 0x02, 0x43, 0x30, 0x82, 0x02, 0x3f, 0x30,
+    0x09, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04, 0x02, 0x30, 0x00, 0x30, 0x0e,
+    0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02,
+    0x03, 0x88, 0x30, 0x29, 0x06, 0x03, 0x55, 0x1d, 0x25, 0x04, 0x22, 0x30,
+    0x20, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x02, 0x06,
+    0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x01, 0x06, 0x0a, 0x2b,
+    0x06, 0x01, 0x04, 0x01, 0x82, 0xde, 0x7c, 0x01, 0x06, 0x30, 0x1d, 0x06,
+    0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x46, 0x93, 0xfa, 0xa7,
+    0x95, 0xbf, 0xbb, 0x0d, 0x1c, 0x38, 0xc4, 0xce, 0xe7, 0x49, 0x33, 0x16,
+    0xe8, 0x59, 0xe9, 0xbe, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04,
+    0x18, 0x30, 0x16, 0x80, 0x14, 0x19, 0x73, 0x6a, 0x04, 0x1a, 0x0b, 0x07,
+    0x70, 0x4f, 0x53, 0x79, 0x53, 0x36, 0x87, 0xfc, 0x0c, 0xba, 0x7c, 0xae,
+    0x0b, 0x30, 0x81, 0x96, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07,
+    0x01, 0x01, 0x04, 0x81, 0x89, 0x30, 0x81, 0x86, 0x30, 0x5d, 0x06, 0x08,
+    0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x51, 0x68, 0x74,
+    0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x70, 0x6b, 0x69,
+    0x2e, 0x6b, 0x79, 0x72, 0x69, 0x6f, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6f,
+    0x63, 0x66, 0x2f, 0x63, 0x61, 0x63, 0x65, 0x72, 0x74, 0x73, 0x2f, 0x42,
+    0x42, 0x45, 0x36, 0x34, 0x46, 0x39, 0x41, 0x37, 0x45, 0x45, 0x33, 0x37,
+    0x44, 0x32, 0x39, 0x41, 0x30, 0x35, 0x45, 0x34, 0x42, 0x42, 0x37, 0x37,
+    0x35, 0x39, 0x35, 0x46, 0x33, 0x30, 0x38, 0x42, 0x45, 0x34, 0x31, 0x45,
+    0x42, 0x30, 0x37, 0x2e, 0x63, 0x72, 0x74, 0x30, 0x25, 0x06, 0x08, 0x2b,
+    0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x19, 0x68, 0x74, 0x74,
+    0x70, 0x3a, 0x2f, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x6f, 0x63, 0x73, 0x70,
+    0x2e, 0x6b, 0x79, 0x72, 0x69, 0x6f, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x5f,
+    0x06, 0x03, 0x55, 0x1d, 0x1f, 0x04, 0x58, 0x30, 0x56, 0x30, 0x54, 0xa0,
+    0x52, 0xa0, 0x50, 0x86, 0x4e, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f,
+    0x74, 0x65, 0x73, 0x74, 0x70, 0x6b, 0x69, 0x2e, 0x6b, 0x79, 0x72, 0x69,
+    0x6f, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6f, 0x63, 0x66, 0x2f, 0x63, 0x72,
+    0x6c, 0x73, 0x2f, 0x42, 0x42, 0x45, 0x36, 0x34, 0x46, 0x39, 0x41, 0x37,
+    0x45, 0x45, 0x33, 0x37, 0x44, 0x32, 0x39, 0x41, 0x30, 0x35, 0x45, 0x34,
+    0x42, 0x42, 0x37, 0x37, 0x35, 0x39, 0x35, 0x46, 0x33, 0x30, 0x38, 0x42,
+    0x45, 0x34, 0x31, 0x45, 0x42, 0x30, 0x37, 0x2e, 0x63, 0x72, 0x6c, 0x30,
+    0x5f, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x83, 0x91, 0x56, 0x01,
+    0x00, 0x04, 0x51, 0x30, 0x4f, 0x30, 0x09, 0x02, 0x01, 0x02, 0x02, 0x01,
+    0x00, 0x02, 0x01, 0x00, 0x30, 0x36, 0x0c, 0x19, 0x31, 0x2e, 0x33, 0x2e,
+    0x36, 0x2e, 0x31, 0x2e, 0x34, 0x2e, 0x31, 0x2e, 0x35, 0x31, 0x34, 0x31,
+    0x34, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x31, 0x2e, 0x30, 0x0c, 0x19, 0x31,
+    0x2e, 0x33, 0x2e, 0x36, 0x2e, 0x31, 0x2e, 0x34, 0x2e, 0x31, 0x2e, 0x35,
+    0x31, 0x34, 0x31, 0x34, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x32, 0x2e, 0x30,
+    0x0c, 0x03, 0x43, 0x54, 0x54, 0x0c, 0x05, 0x49, 0x6e, 0x74, 0x65, 0x6c,
+    0x30, 0x2a, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x83, 0x91, 0x56,
+    0x01, 0x01, 0x04, 0x1c, 0x30, 0x1a, 0x06, 0x0b, 0x2b, 0x06, 0x01, 0x04,
+    0x01, 0x83, 0x91, 0x56, 0x01, 0x01, 0x00, 0x06, 0x0b, 0x2b, 0x06, 0x01,
+    0x04, 0x01, 0x83, 0x91, 0x56, 0x01, 0x01, 0x01, 0x30, 0x30, 0x06, 0x0a,
+    0x2b, 0x06, 0x01, 0x04, 0x01, 0x83, 0x91, 0x56, 0x01, 0x02, 0x04, 0x22,
+    0x30, 0x20, 0x0c, 0x0e, 0x31, 0x2e, 0x33, 0x2e, 0x36, 0x2e, 0x31, 0x2e,
+    0x34, 0x2e, 0x31, 0x2e, 0x37, 0x31, 0x0c, 0x09, 0x44, 0x69, 0x73, 0x63,
+    0x6f, 0x76, 0x65, 0x72, 0x79, 0x0c, 0x03, 0x31, 0x2e, 0x30, 0x30, 0x0a,
+    0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x03, 0x48,
+    0x00, 0x30, 0x45, 0x02, 0x20, 0x21, 0xac, 0x87, 0x42, 0x81, 0x04, 0x85,
+    0x2f, 0x99, 0x38, 0xd1, 0xfb, 0x1f, 0x9c, 0x2e, 0xa7, 0x56, 0xca, 0x58,
+    0xb5, 0x89, 0xd4, 0x02, 0x7f, 0x2f, 0x6a, 0x63, 0x91, 0x4e, 0xdf, 0xe8,
+    0x5e, 0x02, 0x21, 0x00, 0xd7, 0x0c, 0xc3, 0x66, 0x90, 0xc2, 0x7f, 0xa7,
+    0x27, 0x97, 0xc1, 0x0a, 0x24, 0x1b, 0xdc, 0xb8, 0xd4, 0x48, 0xc1, 0xb6,
+    0x8f, 0xce, 0xaa, 0x82, 0x0f, 0xb0, 0x3a, 0xd7, 0x41, 0x06, 0x6e, 0x1d
+  };
+
+  unsigned char my_key[] = {
+    0x30, 0x77, 0x02, 0x01, 0x01, 0x04, 0x20, 0x34, 0x23, 0xa2, 0xf0,
+    0x44, 0x8a, 0xe4, 0x4c, 0x8b, 0x21, 0x7e, 0x4c, 0x0d, 0x68, 0x8a,
+    0xdc, 0xea, 0x5e, 0xcf, 0xb8, 0x60, 0x0a, 0x97, 0xe3, 0x5a, 0x78,
+    0x13, 0xfb, 0x12, 0x48, 0xad, 0x0d, 0xa0, 0x0a, 0x06, 0x08, 0x2a,
+    0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0xa1, 0x44, 0x03, 0x42,
+    0x00, 0x04, 0xe4, 0xbf, 0xcf, 0x9a, 0x29, 0x2d, 0x91, 0x54, 0x4b,
+    0x6d, 0x2c, 0x67, 0x38, 0x7b, 0xe8, 0x7c, 0x58, 0x96, 0x60, 0x40,
+    0xc7, 0x72, 0xc2, 0x41, 0xb7, 0x6f, 0xa6, 0x1a, 0x09, 0xe8, 0x85,
+    0x96, 0xad, 0x02, 0x4c, 0x95, 0xbf, 0x67, 0x75, 0x24, 0x88, 0x98,
+    0x3c, 0x2a, 0x9a, 0xdb, 0x95, 0x96, 0x62, 0x74, 0xce, 0x2d, 0x79,
+    0xe8, 0x30, 0xfa, 0x4c, 0x4a, 0x97, 0x5e, 0xaf, 0xb9, 0xb3, 0x5c
+  };
+
+  unsigned char int_ca[] = {
+    0x30, 0x82, 0x02, 0xfa, 0x30, 0x82, 0x02, 0xa1, 0xa0, 0x03, 0x02, 0x01,
+    0x02, 0x02, 0x09, 0x00, 0xf3, 0x9b, 0x8c, 0xc0, 0x57, 0x2a, 0x11, 0xb5,
+    0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02,
+    0x30, 0x53, 0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c,
+    0x03, 0x4f, 0x43, 0x46, 0x31, 0x22, 0x30, 0x20, 0x06, 0x03, 0x55, 0x04,
+    0x0b, 0x0c, 0x19, 0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x65, 0x73,
+    0x74, 0x20, 0x49, 0x6e, 0x66, 0x72, 0x61, 0x73, 0x74, 0x72, 0x75, 0x63,
+    0x74, 0x75, 0x72, 0x65, 0x31, 0x1f, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x04,
+    0x03, 0x0c, 0x16, 0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x45, 0x53,
+    0x54, 0x20, 0x52, 0x4f, 0x4f, 0x54, 0x20, 0x43, 0x41, 0x30, 0x30, 0x30,
+    0x32, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x38, 0x31, 0x31, 0x33, 0x30, 0x31,
+    0x38, 0x31, 0x32, 0x31, 0x35, 0x5a, 0x17, 0x0d, 0x32, 0x38, 0x31, 0x31,
+    0x32, 0x36, 0x31, 0x38, 0x31, 0x32, 0x31, 0x35, 0x5a, 0x30, 0x5b, 0x31,
+    0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x03, 0x4f, 0x43,
+    0x46, 0x31, 0x22, 0x30, 0x20, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x19,
+    0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x49,
+    0x6e, 0x66, 0x72, 0x61, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72,
+    0x65, 0x31, 0x27, 0x30, 0x25, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x1e,
+    0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x45, 0x53, 0x54, 0x20, 0x49,
+    0x6e, 0x74, 0x65, 0x72, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x20,
+    0x43, 0x41, 0x30, 0x30, 0x30, 0x32, 0x30, 0x59, 0x30, 0x13, 0x06, 0x07,
+    0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a, 0x86, 0x48,
+    0xce, 0x3d, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0xbc, 0x0f, 0x86,
+    0x9f, 0x7a, 0x1f, 0x46, 0x91, 0xf8, 0xd1, 0x7b, 0x95, 0xa6, 0x90, 0x51,
+    0x7f, 0xbf, 0x26, 0x0e, 0xd7, 0xdc, 0x94, 0xe9, 0x01, 0x77, 0xbf, 0xf7,
+    0xdb, 0x24, 0x1c, 0x98, 0xad, 0x8b, 0x43, 0x4c, 0x26, 0xfe, 0xec, 0xa5,
+    0xd9, 0xcc, 0x9e, 0x00, 0x13, 0xee, 0x37, 0xa3, 0x45, 0x71, 0x1f, 0x7e,
+    0x2d, 0x89, 0x17, 0x67, 0x93, 0xf8, 0x3a, 0xfc, 0xbd, 0x47, 0x8d, 0xd0,
+    0xbe, 0xa3, 0x82, 0x01, 0x54, 0x30, 0x82, 0x01, 0x50, 0x30, 0x12, 0x06,
+    0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x08, 0x30, 0x06, 0x01,
+    0x01, 0xff, 0x02, 0x01, 0x00, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f,
+    0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x1d, 0x06,
+    0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x19, 0x73, 0x6a, 0x04,
+    0x1a, 0x0b, 0x07, 0x70, 0x4f, 0x53, 0x79, 0x53, 0x36, 0x87, 0xfc, 0x0c,
+    0xba, 0x7c, 0xae, 0x0b, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04,
+    0x18, 0x30, 0x16, 0x80, 0x14, 0x28, 0x48, 0xe4, 0xe5, 0x27, 0x58, 0xd9,
+    0x08, 0xee, 0x09, 0x34, 0xe4, 0xb1, 0xbb, 0x3d, 0x59, 0x66, 0x1f, 0xc8,
+    0xf5, 0x30, 0x81, 0x8d, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07,
+    0x01, 0x01, 0x04, 0x81, 0x80, 0x30, 0x7e, 0x30, 0x55, 0x06, 0x08, 0x2b,
+    0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x49, 0x68, 0x74, 0x74,
+    0x70, 0x3a, 0x2f, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x70, 0x6b, 0x69, 0x2e,
+    0x6b, 0x79, 0x72, 0x69, 0x6f, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6f, 0x63,
+    0x66, 0x2f, 0x34, 0x45, 0x36, 0x38, 0x45, 0x33, 0x46, 0x43, 0x46, 0x30,
+    0x46, 0x32, 0x45, 0x34, 0x46, 0x38, 0x30, 0x41, 0x38, 0x44, 0x31, 0x34,
+    0x33, 0x38, 0x46, 0x36, 0x41, 0x31, 0x42, 0x41, 0x35, 0x36, 0x39, 0x35,
+    0x37, 0x31, 0x33, 0x44, 0x36, 0x33, 0x2e, 0x63, 0x72, 0x74, 0x30, 0x25,
+    0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x19,
+    0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x6f,
+    0x63, 0x73, 0x70, 0x2e, 0x6b, 0x79, 0x72, 0x69, 0x6f, 0x2e, 0x63, 0x6f,
+    0x6d, 0x30, 0x5a, 0x06, 0x03, 0x55, 0x1d, 0x1f, 0x04, 0x53, 0x30, 0x51,
+    0x30, 0x4f, 0xa0, 0x4d, 0xa0, 0x4b, 0x86, 0x49, 0x68, 0x74, 0x74, 0x70,
+    0x3a, 0x2f, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x70, 0x6b, 0x69, 0x2e, 0x6b,
+    0x79, 0x72, 0x69, 0x6f, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6f, 0x63, 0x66,
+    0x2f, 0x34, 0x45, 0x36, 0x38, 0x45, 0x33, 0x46, 0x43, 0x46, 0x30, 0x46,
+    0x32, 0x45, 0x34, 0x46, 0x38, 0x30, 0x41, 0x38, 0x44, 0x31, 0x34, 0x33,
+    0x38, 0x46, 0x36, 0x41, 0x31, 0x42, 0x41, 0x35, 0x36, 0x39, 0x35, 0x37,
+    0x31, 0x33, 0x44, 0x36, 0x33, 0x2e, 0x63, 0x72, 0x6c, 0x30, 0x0a, 0x06,
+    0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x03, 0x47, 0x00,
+    0x30, 0x44, 0x02, 0x1f, 0x05, 0xe4, 0x45, 0x87, 0x7e, 0xbb, 0x9a, 0x4e,
+    0x3c, 0x7e, 0x78, 0xe3, 0x00, 0x66, 0x05, 0x12, 0x73, 0xfd, 0xbd, 0x23,
+    0xa6, 0x9b, 0xd4, 0x20, 0x7c, 0x7c, 0x21, 0x41, 0xf4, 0x0a, 0x2a, 0x02,
+    0x21, 0x00, 0xc2, 0xf0, 0x29, 0xcc, 0x55, 0x33, 0x82, 0xe5, 0xa2, 0x28,
+    0xa3, 0x96, 0x20, 0xe2, 0x4e, 0xc1, 0x0c, 0x33, 0x71, 0x6d, 0x14, 0x28,
+    0x3e, 0xe8, 0xd8, 0x7a, 0xcd, 0x0e, 0x4d, 0x51, 0xa0, 0x3c
+  };
+
+  unsigned char root_ca[] = {
+    0x30, 0x82, 0x01, 0xdf, 0x30, 0x82, 0x01, 0x85, 0xa0, 0x03, 0x02, 0x01,
+    0x02, 0x02, 0x09, 0x00, 0xf3, 0x9b, 0x8c, 0xc0, 0x57, 0x2a, 0x11, 0xb2,
+    0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02,
+    0x30, 0x53, 0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c,
+    0x03, 0x4f, 0x43, 0x46, 0x31, 0x22, 0x30, 0x20, 0x06, 0x03, 0x55, 0x04,
+    0x0b, 0x0c, 0x19, 0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x65, 0x73,
+    0x74, 0x20, 0x49, 0x6e, 0x66, 0x72, 0x61, 0x73, 0x74, 0x72, 0x75, 0x63,
+    0x74, 0x75, 0x72, 0x65, 0x31, 0x1f, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x04,
+    0x03, 0x0c, 0x16, 0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x45, 0x53,
+    0x54, 0x20, 0x52, 0x4f, 0x4f, 0x54, 0x20, 0x43, 0x41, 0x30, 0x30, 0x30,
+    0x32, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x38, 0x31, 0x31, 0x33, 0x30, 0x31,
+    0x37, 0x33, 0x31, 0x30, 0x35, 0x5a, 0x17, 0x0d, 0x32, 0x38, 0x31, 0x31,
+    0x32, 0x37, 0x31, 0x37, 0x33, 0x31, 0x30, 0x35, 0x5a, 0x30, 0x53, 0x31,
+    0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x03, 0x4f, 0x43,
+    0x46, 0x31, 0x22, 0x30, 0x20, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x19,
+    0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x49,
+    0x6e, 0x66, 0x72, 0x61, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72,
+    0x65, 0x31, 0x1f, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x16,
+    0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x45, 0x53, 0x54, 0x20, 0x52,
+    0x4f, 0x4f, 0x54, 0x20, 0x43, 0x41, 0x30, 0x30, 0x30, 0x32, 0x30, 0x59,
+    0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06,
+    0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00,
+    0x04, 0x6b, 0x75, 0xb1, 0x4d, 0x90, 0x85, 0x07, 0x0a, 0xfe, 0x47, 0xe5,
+    0x29, 0x21, 0x7d, 0x4c, 0x2a, 0xef, 0x29, 0xa0, 0xdc, 0x90, 0xb5, 0x9d,
+    0x66, 0x8c, 0xaf, 0x3f, 0xac, 0xf4, 0x3a, 0xba, 0x8d, 0x76, 0xd0, 0x6c,
+    0x71, 0x98, 0x15, 0x62, 0xc4, 0x87, 0x31, 0x06, 0x75, 0x47, 0x5f, 0x70,
+    0x5b, 0x1b, 0x1f, 0x96, 0xf3, 0x6b, 0xf1, 0xb3, 0x15, 0x5b, 0x52, 0xb7,
+    0x1d, 0x63, 0x24, 0xa6, 0xc8, 0xa3, 0x42, 0x30, 0x40, 0x30, 0x0f, 0x06,
+    0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x05, 0x30, 0x03, 0x01,
+    0x01, 0xff, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01, 0xff,
+    0x04, 0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d,
+    0x0e, 0x04, 0x16, 0x04, 0x14, 0x28, 0x48, 0xe4, 0xe5, 0x27, 0x58, 0xd9,
+    0x08, 0xee, 0x09, 0x34, 0xe4, 0xb1, 0xbb, 0x3d, 0x59, 0x66, 0x1f, 0xc8,
+    0xf5, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03,
+    0x02, 0x03, 0x48, 0x00, 0x30, 0x45, 0x02, 0x20, 0x25, 0x31, 0x4c, 0x20,
+    0x55, 0xe2, 0xfc, 0x77, 0x95, 0xb8, 0x8d, 0x97, 0x45, 0x27, 0x96, 0x60,
+    0x72, 0x59, 0x3b, 0x5d, 0x3e, 0xba, 0x2c, 0xd3, 0x1f, 0x1a, 0x41, 0x31,
+    0x4a, 0x35, 0x35, 0x9e, 0x02, 0x21, 0x00, 0xd3, 0xaf, 0x4e, 0x67, 0x77,
+    0xd8, 0x0d, 0x24, 0x12, 0xd2, 0x29, 0x1d, 0xb8, 0x8a, 0x03, 0xcf, 0x91,
+    0x14, 0x30, 0x8f, 0x25, 0x68, 0xcd, 0xe2, 0x5a, 0x31, 0xac, 0x10, 0xbb,
+    0xbf, 0x42, 0x44
+  };
\ No newline at end of file
diff --git a/port/linux/Makefile b/port/linux/Makefile
index 7c1ca964..6ce47f61 100644
--- a/port/linux/Makefile
+++ b/port/linux/Makefile
@@ -9,6 +9,8 @@ VERSION_MAJOR = 1
 VERSION_MINOR = 0
 VERSION = $(VERSION_MAJOR).$(VERSION_MINOR)
 DYNAMIC ?= 1
+SECURE ?= 1
+PKI ?= 1
 DESTDIR ?= /usr/local
 install_bin_dir?=${DESTDIR}/opt/iotivity-constrained/bin/
 prefix = $(DESTDIR)
@@ -58,7 +60,8 @@ DTLS= 	aes.c		aesni.c 	arc4.c  	asn1parse.c	asn1write.c	base64.c	\
 	sha512.c	threading.c	timing.c	version.c	version_features.c		\
 	xtea.c  	pkcs11.c 	x509.c 		x509_crt.c	debug.c		net_sockets.c	\
 	ssl_cache.c	ssl_ciphersuites.c		ssl_cli.c	ssl_cookie.c			\
-	ssl_srv.c	ssl_ticket.c	ssl_tls.c	rsa_internal.c
+	ssl_srv.c	ssl_ticket.c	ssl_tls.c	rsa_internal.c	x509write_csr.c\
+	x509write_crt.c	x509_create.c
 DTLSFLAGS=-I../../deps/mbedtls/include -D__OC_RANDOM
 
 CBOR=../../deps/tinycbor/src/cborencoder.c ../../deps/tinycbor/src/cborencoder_close_container_checked.c ../../deps/tinycbor/src/cborparser.c# ../../deps/tinycbor/src/cbortojson.c ../../deps/tinycbor/src/cborpretty.c ../../deps/tinycbor/src/cborparser_dup_string.c
@@ -68,7 +71,7 @@ SRC_COMMON=$(wildcard ../../util/*.c) ${CBOR}
 SRC=$(wildcard ../../messaging/coap/*.c ../../api/*.c ../../port/linux/*.c)
 
 HEADERS = $(wildcard ../../include/*.h)
-HEADERS += ../../port/linux/config.h
+HEADERS += ../../port/linux/oc_config.h
 
 HEADERS_COAP = $(wildcard ../../messaging/coap/*.h)
 HEADERS_UTIL = $(wildcard ../../util/*.h)
@@ -84,23 +87,30 @@ OBJ_CLIENT_SERVER=$(addprefix obj/client_server/,$(notdir $(SRC:.c=.o)))
 VPATH=../../messaging/coap/:../../util/:../../api/:../../deps/tinycbor/src/:../../deps/mbedtls/library:
 LIBS?= -lm -pthread -lrt
 
-SAMPLES = server client temp_sensor simpleserver simpleclient client_collections_linux \
+SAMPLES = CertificationApp discover_device server client temp_sensor simpleserver simpleserver_pki simpleclient client_collections_linux \
 	  server_collections_linux server_block_linux client_block_linux smart_home_server_linux multi_device_server multi_device_client smart_lock server_multithread_linux client_multithread_linux
 
 OBT = onboarding_tool
 
 ifeq ($(DEBUG),1)
 	CFLAGS += -DOC_DEBUG -g -O0
+ifeq ($(DEBUG_TLS),1)
+	CFLAGS += -DOC_DEBUG_TLS
+endif
 else
 	CFLAGS += -Wl,--gc-sections
 endif
 
+ifeq ($(PKI),1)
+	EXTRA_CFLAGS += -DOC_PKI
+endif
+
 ifeq ($(DYNAMIC),1)
 	EXTRA_CFLAGS += -DOC_DYNAMIC_ALLOCATION
 endif
 
 ifneq ($(SECURE),0)
-	SRC += $(addprefix ../../security/,oc_acl.c oc_cred.c oc_doxm.c oc_pstat.c oc_tls.c oc_svr.c oc_store.c)
+	SRC += $(addprefix ../../security/,oc_acl.c oc_cred.c oc_doxm.c oc_pstat.c oc_tls.c oc_svr.c oc_store.c oc_pki.c oc_certs.c oc_sp.c oc_keypair.c oc_csr.c)
 	SRC_COMMON += $(addprefix $(MBEDTLS_DIR)/library/,${DTLS})
 	MBEDTLS_PATCH_FILE := $(MBEDTLS_DIR)/patched.txt
 ifeq ($(DYNAMIC),1)
@@ -148,7 +158,7 @@ $(GTEST):
 
 $(API_TEST_OBJ_DIR)/%.o: $(API_TEST_DIR)/%.cpp
 	@mkdir -p ${@D}
-	$(CXX) $(GTEST_CPPFLAGS) $(TEST_CXXFLAGS) $(HEADER_DIR) -I$(ROOT_DIR)/deps/tinycbor/src -c $< -o $@
+	$(CXX) $(GTEST_CPPFLAGS) $(TEST_CXXFLAGS) $(EXTRA_CFLAGS) $(HEADER_DIR) -I$(ROOT_DIR)/deps/tinycbor/src -c $< -o $@
 
 apitest: $(API_TEST_OBJ_FILES) libiotivity-constrained-client-server.a | $(GTEST)
 	$(CXX) $^ -o $@ $(GTEST_CPPFLAGS) $(TEST_CXXFLAGS) $(EXTRA_CFLAGS) $(HEADER_DIR) -L$(OUT_DIR) -L$(GTEST_DIR)/make -l:gtest_main.a -liotivity-constrained-client-server -lpthread
@@ -227,6 +237,10 @@ simpleserver: libiotivity-constrained-server.a $(ROOT_DIR)/apps/simpleserver.c
 	@mkdir -p $@_creds
 	${CC} -o $@ ../../apps/simpleserver.c libiotivity-constrained-server.a -DOC_SERVER ${CFLAGS}  ${LIBS}
 
+simpleserver_pki: libiotivity-constrained-server.a $(ROOT_DIR)/apps/simpleserver_pki.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/simpleserver_pki.c libiotivity-constrained-server.a -DOC_SERVER ${CFLAGS}  ${LIBS}
+
 simpleclient: libiotivity-constrained-client.a $(ROOT_DIR)/apps/simpleclient.c
 	@mkdir -p $@_creds
 	${CC} -o $@ ../../apps/simpleclient.c libiotivity-constrained-client.a -DOC_CLIENT ${CFLAGS}  ${LIBS}
@@ -268,6 +282,13 @@ server_multithread_linux: libiotivity-constrained-server.a $(ROOT_DIR)/apps/serv
 client_multithread_linux: libiotivity-constrained-client.a $(ROOT_DIR)/apps/client_multithread_linux.c
 	@mkdir -p $@_creds
 	${CC} -o $@ ../../apps/client_multithread_linux.c libiotivity-constrained-client.a -DOC_CLIENT ${CFLAGS}  ${LIBS}
+CertificationApp: libiotivity-constrained-server.a $(ROOT_DIR)/apps/CertificationApp.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/device_builder_server.c ../../apps/CertificationApp.c libiotivity-constrained-client-server.a -DOC_SERVER -DOC_CLIENT  ${CFLAGS} ${LIBS}
+
+discover_device: libiotivity-constrained-client.a $(ROOT_DIR)/apps/discover_device.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/discover_device.c libiotivity-constrained-client.a -DOC_CLIENT ${CFLAGS}  ${LIBS}
 
 iotivity-constrained-server.pc: iotivity-constrained-server.pc.in
 	$(SED) > $@ < $< \
diff --git a/tests/automation/ctt/Makefile b/tests/automation/ctt/Makefile
new file mode 100644
index 00000000..48628d97
--- /dev/null
+++ b/tests/automation/ctt/Makefile
@@ -0,0 +1,2 @@
+tafagent: src/ResourceMap.c src/TAFAgent.c src/MiniHttpServer.c src/DUTController.c
+	gcc -o tafagent src/ResourceMap.c src/TAFAgent.c src/MiniHttpServer.c src/DUTController.c -luv -lxml2 -lm -I ./include -I /usr/include/libxml2 -I /usr/include -I /usr/local/include/uv -L /usr/local/lib/
\ No newline at end of file
diff --git a/tests/automation/ctt/README.rst b/tests/automation/ctt/README.rst
new file mode 100644
index 00000000..9b247b5b
--- /dev/null
+++ b/tests/automation/ctt/README.rst
@@ -0,0 +1,106 @@
+Getting Started
+---------------
+
+- Refer the 'README.rst' in the
+`link <https://github.com/iotivity/iotivity-constrained/blob/master/README.rst>`_,
+to download the iotivity-lite files and setup the source tree.
+
+- Open iotivity-constrained folder, then open a terminal from within that
+folder and using ``git pull https://gerrit.iotivity.org/gerrit/iotivity-constrained refs/changes/23/26923/38``,
+pull the patch having source codes of CertificationApp, tafagent etc.,
+
+Contents
+--------
+
+- `Generating CertificationApp.exe`_
+- `Steps to be followed to Run TAF Agent along with CTT`_
+
+Generating CertificationApp.exe
+-------------------------------
+
+- Move to the folder specified by the path ``iotivity-constrained/port/linux``
+  and open a terminal from within that folder.
+
+- Generate CertificationApp.exe using ``make -f Makefile``
+
+- Execute CertificationApp using ``./CertificationApp``
+
+- On successfully executing CertificationApp, an options-menu, as shown below,
+  having a list of available server and client operations, gets displayed.
+
+	-----------------------------------------------------
+	Please Select an option from the menu and press Enter
+	-----------------------------------------------------
+		0   : Quit Certification App
+
+	Server Operations:
+		1   : Create Normal Resource
+		2   : Create Invisible Resource
+		3   : Create Resource With Complete URL
+		4   : Create Secured Resource
+		5   : Create 100 Light Resources
+		6   : Create Group Resource
+		7   : Delete All Resources
+		8   : Delete Created Group
+
+	Client Operations:
+		9   : Find Introspection
+		11  : Find specific type of resource
+		12  : Find All Resources
+		17  : Send GET Request
+		22  : Send POST Request - Partial Update - User Input
+		25  : Observe Resource - Retrieve Request with Observe
+		26  : Cancel Observing Resource
+		31  : Find Group
+		33  : Update Group
+		34  : Update Local Resource Manually
+		107 : Create Air Conditioner Single Resource
+
+Steps to be followed to Run TAF Agent along with CTT
+----------------------------------------------------
+
+- The test case numbers(e.g., CT1.1.1, CT1.2.10 etc.,) of test cases on CTT that
+  need to be run, have to be mentioned in the ``server_config.txt`` file present
+  in ``iotivity-constrained/tests/automation/ctt``
+
+- Move to ``iotivity-constrained/tests/automation/ctt`` and open a terminal from
+  within that folder
+
+- Run ``./run_taf_agent.sh`` to execute run_taf_agent.sh and install the
+  dependent packages
+
+- Run ``make`` to generate tafagent.exe
+
+- Run the tafagent using ``./tafagent server_config.txt 1 6 11 1.3 1 6``
+
+    [Arguments passed in the above command(from left to right) are to make
+     below mentioned selections
+     1 for QOS_CON
+     6 for IPv6
+     11 for security
+     1.3 for OCF version 1.3
+     1 for choosing 'Create Normal Resource' option on CertificationApp
+     6 for choosing 'Create Group Resource' option on CertificationApp]
+
+- Then open CTT, click on ``Test Run``>``Automation``
+
+- Set the appropriate ``NetworkInterface``
+
+- Set the following port values
+
+  - ``Basic API port`` as: 32000
+
+  - ``Extended API port`` as: 32001
+
+  - ``Setup API port`` as: 32002
+
+- Set ``Remote IP address`` be the IP address of Linux machine that runs the
+  tafagent
+
+- Then select ``Basic API``, ``Extended API`` and ``Setup API`` by clicking
+  corresponding check boxes.
+
+- Then click ``Connect``
+
+- CTT then connects to TAF agent, following which TAF agent would communicate
+  with CertificationApp.
\ No newline at end of file
diff --git a/tests/automation/ctt/include/DUTController.h b/tests/automation/ctt/include/DUTController.h
new file mode 100755
index 00000000..2ee5aac9
--- /dev/null
+++ b/tests/automation/ctt/include/DUTController.h
@@ -0,0 +1,50 @@
+/******************************************************************
+ *
+ * Copyright 2016 Granite River Labs All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+#ifndef __DUTLIBC_H__
+#define __DUTLIBC_H__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+//#include <libxml/parser.h>
+#include <libxml/tree.h>
+#include <ResourceMap.h>
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+void initDutControllers();
+void addRouteBasic(const char* method, const char* path, resourceCB onResource, afterResourceCB onAfterResource);
+void addRouteSetup(const char* method, const char* path, resourceCB onResource, afterResourceCB onAfterResource);
+void addRouteExtended(const char* method, const char* path, resourceCB onResource, afterResourceCB onAfterResource);
+void startDutControllerBasic(const char* ip, int port);
+void startDutControllerSetup(const char* ip, int port);
+void startDutControllerExtended(const char* ip, int port);
+void stopDutControllers();
+void disposeDutControllers();
+xmlDocPtr stringToDoc(const char* str);
+char* docToString(xmlDocPtr doc);
+
+#ifdef __cplusplus
+}
+#endif
+#endif //__DUTLIBC_H__
diff --git a/tests/automation/ctt/include/MiniHttpServer.h b/tests/automation/ctt/include/MiniHttpServer.h
new file mode 100755
index 00000000..02aa44af
--- /dev/null
+++ b/tests/automation/ctt/include/MiniHttpServer.h
@@ -0,0 +1,41 @@
+/******************************************************************
+ *
+ * Copyright 2016 Granite River Labs All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+#ifndef __MINI_HTTP_SERVER__
+#define __MINI_HTTP_SERVER__
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+typedef char* (*httpRequestCB)(const char* method, const char* url, const char* body);
+typedef void (*afterHttpRequestCB)(char* rspBody);
+void startMiniHttpServerBasic(const char* addr, int port, httpRequestCB onHttpRequest, afterHttpRequestCB onAfterHttpRequest);
+void startMiniHttpServerSetup(const char* addr, int port, httpRequestCB onHttpRequest, afterHttpRequestCB onAfterHttpRequest);
+void startMiniHttpServerExtended(const char* addr, int port, httpRequestCB onHttpRequest, afterHttpRequestCB onAfterHttpRequest);
+void stopMiniHttpServerBasic();
+void stopMiniHttpServerSetup();
+void stopMiniHttpServerExtended();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //__MINI_HTTP_SERVER__
diff --git a/tests/automation/ctt/include/ResourceMap.h b/tests/automation/ctt/include/ResourceMap.h
new file mode 100755
index 00000000..7f118b53
--- /dev/null
+++ b/tests/automation/ctt/include/ResourceMap.h
@@ -0,0 +1,60 @@
+/******************************************************************
+ *
+ * Copyright 2016 Granite River Labs All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+#ifndef __RESOURCE_MAP_H__
+#define __RESOURCE_MAP_H__
+
+#include <libxml/parser.h>
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+typedef xmlDocPtr (*resourceCB)(xmlDocPtr);
+typedef void (*afterResourceCB)(xmlDocPtr);
+#define MAX_METHOD 32
+#define MAX_PATH 256
+typedef struct 
+{
+    resourceCB onResource;
+    afterResourceCB onAfterResource;
+} ResourceCBS;
+
+typedef struct 
+{
+    char method[MAX_METHOD + 1];
+    char path[MAX_PATH + 1];
+    ResourceCBS resourceCBS;
+    struct Resource* next;
+}Resource;
+
+typedef struct 
+{
+    Resource* head;
+}ResourceMap;
+
+
+ResourceMap* createResourceMap();
+void addResourceCBS(ResourceMap* self, const char* method, const char* path, resourceCB onResource, afterResourceCB onAfterResource);
+ResourceCBS getResourceCBS(ResourceMap* self, const char* method, const char* path);
+void deleteResourceMap(ResourceMap* self);
+#ifdef __cplusplus
+}
+#endif
+#endif //__RESOURCE_MAP_H__
diff --git a/tests/automation/ctt/run_taf_agent.sh b/tests/automation/ctt/run_taf_agent.sh
new file mode 100755
index 00000000..48b66d90
--- /dev/null
+++ b/tests/automation/ctt/run_taf_agent.sh
@@ -0,0 +1,14 @@
+#!/bin/bash
+sudo apt-get update
+sudo apt-get update --fix-missing 
+sudo apt-get install libuv1.dev
+sudo apt-get install libxml2-dev
+sudo apt-get install xdotool
+
+cp ../../../port/linux/discover_device .
+cp ../../../port/linux/CertificationApp .
+
+mkdir CertificationApp_creds
+
+export LD_LIBRARY_PATH=/usr/local/lib
+
diff --git a/tests/automation/ctt/server_config.txt b/tests/automation/ctt/server_config.txt
new file mode 100644
index 00000000..18bb5e09
--- /dev/null
+++ b/tests/automation/ctt/server_config.txt
@@ -0,0 +1,100 @@
+<configuration>
+  <endpoint>
+    <ip>%IP%</ip>
+    <port>%PORT%</port>
+  </endpoint>
+  <deviceClass>OCFServer</deviceClass>
+  <profiles>
+    <profile>Server</profile>
+  </profiles>
+  <testCases>
+    <testCase>CT1.1.2</testCase>
+    <testCase>CT1.1.3</testCase>
+    <testCase>CT1.1.4</testCase>
+    <testCase>CT1.1.5</testCase>
+    <testCase>CT1.1.7</testCase>
+    <testCase>CT1.2.3</testCase>
+    <testCase>CT1.2.6</testCase>
+    <testCase>CT1.2.7</testCase> 
+    <testCase>CT1.2.8</testCase>
+    <testCase>CT1.2.9</testCase>
+    <testCase>CT1.2.10</testCase>
+    <testCase>CT1.2.14</testCase> 
+    <testCase>CT1.2.15</testCase> 
+    <testCase>CT1.2.16</testCase> 
+    <testCase>CT1.2.17</testCase> 
+    <testCase>CT1.2.18</testCase> 
+    <testCase>CT1.2.19</testCase> 
+    <testCase>CT1.2.20</testCase>
+    <testCase>CT1.2.21</testCase>
+    <testCase>CT1.2.22</testCase>
+    <testCase>CT1.3.3-1</testCase> 
+    <testCase>CT1.3.3-2</testCase> 
+    <testCase>CT1.3.3-3</testCase> 
+    <testCase>CT1.3.4</testCase>
+    <testCase>CT1.3.5</testCase>
+    <testCase>CT1.3.6</testCase> 
+    <testCase>CT1.3.7</testCase>
+    <testCase>CT1.3.8</testCase>
+    <testCase>CT1.3.9</testCase>
+    <testCase>CT1.3.10</testCase> 
+    <testCase>CT1.3.11</testCase> 
+    <testCase>CT1.4.1</testCase>
+    <testCase>CT1.4.2</testCase>
+    <testCase>CT1.4.3</testCase> 
+    <testCase>CT1.4.4</testCase>
+    <testCase>CT1.4.5</testCase>
+    <testCase>CT1.4.6</testCase> 
+    <testCase>CT1.4.7</testCase>    
+    <testCase>CT1.7.2.1-1</testCase> 
+    <testCase>CT1.7.2.1-2</testCase> 
+    <testCase>CT1.7.2.2-1</testCase> 
+    <testCase>CT1.7.2.2-2</testCase> 
+    <testCase>CT1.7.2.3-1</testCase>
+    <testCase>CT1.7.2.3-2</testCase>
+    <testCase>CT1.7.3.1</testCase>
+    <testCase>CT1.7.3.2</testCase>
+    <testCase>CT1.7.4.1</testCase>
+    <testCase>CT1.7.4.2</testCase>
+    <testCase>CT1.7.4.3</testCase>
+    <testCase>CT1.7.4.4</testCase>
+    <testCase>CT1.7.4.5</testCase>
+    <testCase>CT1.7.5.1</testCase>
+    <testCase>CT1.7.5.2</testCase>
+    <testCase>CT1.7.7.1</testCase>
+    <testCase>CT1.7.8.1</testCase>
+    <testCase>CT1.7.8.2</testCase>
+    <testCase>CT1.7.8.5</testCase>
+    <testCase>CT1.7.8.7</testCase>
+    <testCase>CT1.7.8.9</testCase>
+    <testCase>CT1.7.9.1</testCase>
+    <testCase>CT1.7.9.2</testCase> 
+    <testCase>CT1.7.9.3</testCase> 
+    <testCase>CT1.7.9.4</testCase> 
+    <testCase>CT1.7.9.6-1</testCase>
+    <testCase>CT1.7.9.6-2</testCase> 
+    <testCase>CT1.7.9.6-3</testCase>
+    <testCase>CT1.7.10.3</testCase>
+    <testCase>CT1.7.10.4</testCase>
+    <testCase>CT1.7.10.5</testCase>
+    <testCase>CT1.7.10.6</testCase>
+    <testCase>CT1.7.11.1</testCase>
+    <testCase>CT1.7.11.2</testCase>
+    <testCase>CT1.7.12.2</testCase>
+    <testCase>CT1.7.12.4</testCase>
+  </testCases>
+  <pics>{
+    "role": "Server",
+    "supportedVerticalProfile": ["Smart Home"],
+    "supportedDeviceTypes": ["oic.d.dehumidifier"],
+    "icv": "ocf.2.0.0",
+    "dmv": "ocf.res.1.0.0, ocf.sh.1.0.0",
+    "resources": [ "oic.r.switch.binary", "oic.r.humidity", "oic.wk.col" ],
+    "jurisdictionSwitch": false,
+    "OTM":["oic.sec.doxm.jw"],
+    "contentFormatVersion": [ "1.0.0" ],
+    "acceptVersion": [ "1.0.0" ],
+    "sct": 1,
+    "persistentDeviceuuid": false
+}</pics>
+</configuration>
\ No newline at end of file
diff --git a/tests/automation/ctt/src/DUTController.c b/tests/automation/ctt/src/DUTController.c
new file mode 100755
index 00000000..788fb10d
--- /dev/null
+++ b/tests/automation/ctt/src/DUTController.c
@@ -0,0 +1,262 @@
+/******************************************************************
+ *
+ * Copyright 2016 Granite River Labs All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+#include <DUTController.h>
+#include <MiniHttpServer.h>
+#include <uv.h>
+
+/*Static resources Start*/
+static ResourceMap* s_resourceMapBasic = 0;
+static ResourceMap* s_resourceMapExtended = 0;
+static ResourceMap* s_resourceMapSetup = 0;
+static uv_thread_t s_serverID;
+/*Static resource End*/
+
+/*Doc to string conversion*/
+char* docToString(xmlDocPtr doc)
+{
+    char* ret = 0;
+
+    if (doc != 0)
+    {
+        xmlChar* xmlbuff;
+        int buffersize;
+        xmlDocDumpFormatMemory(doc, &xmlbuff, &buffersize, 1);
+        ret = (char*)xmlbuff;
+    }
+
+    return ret;
+}
+
+/*String to Doc conversion*/
+xmlDocPtr stringToDoc(const char* str)
+{
+    return xmlParseMemory(str, strlen(str));
+}
+
+/*Callback Function to be invoked for Basic HTTP request*/
+char* onHttpRequestBasic(const char* method, const char* url, const char* body)
+{
+    xmlDocPtr reqDoc = 0;
+    xmlDocPtr rspDoc = 0;
+    char* ret = 0;
+    ResourceCBS resourceCBS;
+
+    if (body != 0)
+    {
+        reqDoc = stringToDoc(body);
+
+        if (reqDoc == 0) goto error;
+    }
+
+    resourceCBS = getResourceCBS(s_resourceMapBasic, method, url);
+
+    if (resourceCBS.onResource)
+    {
+        rspDoc = resourceCBS.onResource(reqDoc);
+        ret = docToString(rspDoc);
+    }
+
+    if (resourceCBS.onAfterResource)
+    {
+        resourceCBS.onAfterResource(rspDoc);
+    }
+
+    goto cleanup;
+
+error:
+    printf("Error for %s %s\n", method, url);
+
+cleanup:
+    if (reqDoc != 0)
+    {
+        xmlFreeDoc(reqDoc);
+    }
+
+    return ret;
+}
+
+/*Callback Function to be invoked after executing Basic HTTP request*/
+void onAfterHttpRequestBasic(char* rspBody)
+{
+    free(rspBody);
+}
+
+
+/*Callback Function to be invoked for Setup HTTP request*/
+char* onHttpRequestSetup(const char* method, const char* url, const char* body)
+{
+    xmlDocPtr reqDoc = 0;
+    xmlDocPtr rspDoc = 0;
+    char* ret = 0;
+    ResourceCBS resourceCBS;
+
+    if (body != 0)
+    {
+        reqDoc = stringToDoc(body);
+
+        if (reqDoc == 0) goto error;
+    }
+
+    resourceCBS = getResourceCBS(s_resourceMapSetup, method, url);
+
+    if (resourceCBS.onResource)
+    {
+        rspDoc = resourceCBS.onResource(reqDoc);
+        ret = docToString(rspDoc);
+    }
+
+    if (resourceCBS.onAfterResource)
+    {
+        resourceCBS.onAfterResource(rspDoc);
+
+    }
+
+    goto cleanup;
+
+error:
+    printf("Error for %s %s\n", method, url);
+
+cleanup:
+    if (reqDoc != 0)
+    {
+        xmlFreeDoc(reqDoc);
+    }
+
+    return ret;
+}
+
+
+/*Callback Function to be invoked after executing Setup HTTP request*/
+void onAfterHttpRequestSetup(char* rspBody)
+{
+    free(rspBody);
+}
+
+
+/*Callback Function to be invoked for Extended HTTP request*/
+char* onHttpRequestExtended(const char* method, const char* url, const char* body)
+{
+    xmlDocPtr reqDoc = 0;
+    xmlDocPtr rspDoc = 0;
+    char* ret = 0;
+    ResourceCBS resourceCBS;
+
+    if (body != 0)
+    {
+        reqDoc = stringToDoc(body);
+
+        if (reqDoc == 0) goto error;
+    }
+
+    resourceCBS = getResourceCBS(s_resourceMapExtended, method, url);
+
+    if (resourceCBS.onResource)
+    {
+        rspDoc = resourceCBS.onResource(reqDoc);
+        ret = docToString(rspDoc);
+    }
+
+    if (resourceCBS.onAfterResource)
+    {
+        resourceCBS.onAfterResource(rspDoc);
+    }
+
+    goto cleanup;
+
+error:
+    printf("Error for %s %s\n", method, url);
+
+cleanup:
+    if (reqDoc != 0)
+    {
+        xmlFreeDoc(reqDoc);
+    }
+
+    return ret;
+}
+
+
+/*Callback Function to be invoked after executing Extended HTTP request*/
+void onAfterHttpRequestExtended(char* rspBody)
+{
+    free(rspBody);
+}
+
+
+/*Init DUT Controllers related to Basic,Setup and Extended*/
+void initDutControllers()
+{
+    s_resourceMapBasic = createResourceMap();
+    s_resourceMapSetup = createResourceMap();
+    s_resourceMapExtended = createResourceMap();
+}
+
+/*Dispose DUT Controllers related to Basic,Setup and Extended*/
+void disposeDutControllers()
+{
+    deleteResourceMap(s_resourceMapBasic);
+    deleteResourceMap(s_resourceMapSetup);
+    deleteResourceMap(s_resourceMapExtended);
+}
+
+/*Add Route for Basic HTTP request*/
+void addRouteBasic(const char* method, const char* path, resourceCB onResource, afterResourceCB onAfterResource)
+{
+    addResourceCBS(s_resourceMapBasic, method, path, onResource, onAfterResource);
+}
+
+/*Add Route for Setup HTTP request*/
+void addRouteSetup(const char* method, const char* path, resourceCB onResource, afterResourceCB onAfterResource)
+{
+    addResourceCBS(s_resourceMapSetup, method, path, onResource, onAfterResource);
+}
+
+/*Add Route for Extended HTTP request*/
+void addRouteExtended(const char* method, const char* path, resourceCB onResource, afterResourceCB onAfterResource)
+{
+    addResourceCBS(s_resourceMapExtended, method, path, onResource, onAfterResource);
+}
+
+/*Start DUT controller Basic*/
+void startDutControllerBasic(const char* ip, int port)
+{
+    startMiniHttpServerBasic(ip, port, onHttpRequestBasic, onAfterHttpRequestBasic);
+}
+
+/*Start DUT controller Setup*/
+void startDutControllerSetup(const char* ip, int port)
+{
+    startMiniHttpServerSetup(ip, port, onHttpRequestSetup, onAfterHttpRequestSetup);
+}
+
+/*Start DUT controller Extended*/
+void startDutControllerExtended(const char* ip, int port)
+{
+    startMiniHttpServerExtended(ip, port, onHttpRequestExtended, onAfterHttpRequestExtended);
+}
+
+/*Stop DUT controllers*/
+void stopDutControllers()
+{
+    stopMiniHttpServerBasic();
+    stopMiniHttpServerSetup();
+    stopMiniHttpServerExtended();
+}
diff --git a/tests/automation/ctt/src/MiniHttpServer.c b/tests/automation/ctt/src/MiniHttpServer.c
new file mode 100755
index 00000000..bf9230f4
--- /dev/null
+++ b/tests/automation/ctt/src/MiniHttpServer.c
@@ -0,0 +1,751 @@
+/******************************************************************
+ *
+ * Copyright 2016 Granite River Labs All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pthread.h>
+#include <MiniHttpServer.h>
+#include <uv.h>
+
+/*Static resource start*/
+static uv_loop_t s_loopBasic;
+static uv_async_t s_stopAsyncBasic;
+static uv_thread_t s_serverThreadIDBasic;
+static char* s_addrBasic;
+static int s_portBasic;
+static uv_loop_t s_loopSetup;
+static uv_async_t s_stopAsyncSetup;
+static uv_thread_t s_serverThreadIDSetup;
+static char* s_addrSetup;
+static int s_portSetup;
+static uv_loop_t s_loopExtended;
+static uv_async_t s_stopAsyncExtended;
+static uv_thread_t s_serverThreadIDExtended;
+static char* s_addrExtended;
+static int s_portExtended;
+static httpRequestCB s_onHttpRequestBasic;
+static afterHttpRequestCB s_onAfterHttpRequestBasic;
+static httpRequestCB s_onHttpRequestSetup;
+static afterHttpRequestCB s_onAfterHttpRequestSetup;
+static httpRequestCB s_onHttpRequestExtended;
+static afterHttpRequestCB s_onAfterHttpRequestExtended;
+/*Static resource end*/
+
+typedef struct 
+{
+    uv_tcp_t* tcp;
+    uv_buf_t buf;
+} ReqData;
+
+/*On Allocation of memory*/
+static void onAlloc(uv_handle_t* client, size_t suggested_size, uv_buf_t* buf)
+{
+    buf->base = (char*)malloc(suggested_size);
+    buf->len = suggested_size;
+}
+
+/*Free Work request*/
+static void freeWorkReq(uv_work_t* req, int status)
+{
+    free(req);
+}
+
+/*Create the response*/
+static char* createResponse(char* body)
+{
+    //response template used for responding to TAF query
+    char rspTemplate[] = "HTTP/1.1 200 OK\r\n" \
+                       "Content-Type: text/xml; charset=iso-8859-1\r\n" \
+                       "Content-Length: %d\r\n" \
+                       "Connection: close\r\n" \
+                       "\r\n" \
+                       "%s";
+    char* rsp = 0;
+
+    if (body)
+    {
+        rsp = (char*)malloc(sizeof(char) * (strlen(body) + strlen(rspTemplate) + 16));
+        sprintf(rsp, rspTemplate, strlen(body), body);
+    }
+    else
+    {
+        rsp = (char*)malloc(sizeof(char) * (strlen("") + strlen(rspTemplate) + 16));
+        sprintf(rsp, rspTemplate, strlen(""), "");
+    }
+
+    return rsp;
+}
+
+/*Get string from the request buffer*/
+static char* getMethod(uv_buf_t* req)
+{
+    char* end = strstr(req->base, " ");
+    size_t size = end - req->base;
+    char* ret = (char*)malloc(sizeof(char) * (size + 1));
+
+    strncpy(ret, req->base, size);
+    ret[size] = 0;
+
+    return ret;
+}
+
+
+/*Get content length from the request buffer*/
+static int getContentLength(uv_buf_t* req)
+{
+    int ret = -1;
+
+    char* cl = strstr(req->base, "Content-Length:");
+    char* rn = strstr(req->base, "\r\n\r\n");
+
+    if (cl == 0) goto error;
+    if (cl > rn) goto error;
+
+    sscanf(cl, "Content-Length: %d", &ret);
+
+    return ret;
+
+error:
+    return -1;
+}
+
+/*Calculate content length from the request buffer*/
+static int calcContentLength(uv_buf_t* req)
+{
+    char* rn = strstr(req->base, "\r\n\r\n");
+    int header_len = 0;
+
+    if (rn == 0) goto error;
+
+    header_len = rn - req->base + 4;
+
+    return req->len - header_len;
+
+error:
+    return -1;
+}
+
+/*Get the URL from the request buffer*/
+static char* getUrl(uv_buf_t* req)
+{
+    char* begin = strstr(req->base, " ") + 1;
+    char* end = strstr(begin, " ");
+    size_t size = end - begin;
+    char* ret = (char*)malloc(sizeof(char) * (size + 1));
+
+    strncpy(ret, begin, size);
+    ret[size] = 0;
+
+    return ret;
+}
+
+/*Get the body from the request buffer*/
+static char* getBody(uv_buf_t* req)
+{
+    char* begin = 0;
+    char* end = 0;
+    char* ret = 0;
+    size_t size = 0;
+
+    begin = strstr(req->base, "\r\n\r\n");
+    if (!begin) goto error;
+    begin += 4;
+
+    end = req->base + req->len;
+    size = end - begin;
+
+    if (size > 0)
+    {
+        ret = (char*)malloc(sizeof(char) * (size + 1));
+
+        strncpy(ret, begin, size);
+        ret[size] = 0;
+    }
+
+    return ret;
+
+error:
+    free(ret);
+
+    return 0;
+}
+
+/*Delete the handle of request buffer*/
+void deleteHandle(uv_handle_t* handle)
+{
+    free(handle);
+}
+
+/*Finish the request*/
+void finishRequest(uv_write_t* req, int status)
+{
+    ReqData* reqData = (ReqData*)req->data;
+
+    uv_close((uv_handle_t*) reqData->tcp, deleteHandle);
+
+    free(reqData->buf.base);
+    free(reqData);
+    free(req);
+}
+
+/*Process Basic Request*/
+static void processRequestBasic(uv_work_t* req)
+{
+    ReqData* reqData = (ReqData*) req->data;
+    uv_write_t* writeReq = 0;
+    char* rspBody = 0;
+    char* rsp = 0;
+
+    char* reqMethod = getMethod(&reqData->buf);
+    char* reqUrl = getUrl(&reqData->buf);
+    char* reqBody = getBody(&reqData->buf);
+
+    if (s_onHttpRequestBasic)
+    {
+        rspBody = s_onHttpRequestBasic(reqMethod, reqUrl, reqBody);
+    }
+
+    rsp = createResponse(rspBody);
+
+    free(reqData->buf.base);
+
+    reqData->buf.base = rsp;
+    reqData->buf.len = strlen(rsp);
+
+    writeReq = (uv_write_t*)malloc(sizeof(uv_write_t));
+    writeReq->data = reqData;
+
+    uv_write(writeReq, (uv_stream_t*) reqData->tcp, &reqData->buf, 1, finishRequest);
+
+    if (s_onAfterHttpRequestBasic)
+    {
+        s_onAfterHttpRequestBasic(rspBody);
+    }
+
+    free(reqBody);
+    free(reqUrl);
+    free(reqMethod);
+}
+
+/*Process Setup Request*/
+static void processRequestSetup(uv_work_t* req)
+{
+    ReqData* reqData = (ReqData*) req->data;
+    uv_write_t* writeReq = 0;
+    char* rspBody = 0;
+    char* rsp = 0;
+
+    char* reqMethod = getMethod(&reqData->buf);
+    char* reqUrl = getUrl(&reqData->buf);
+    char* reqBody = getBody(&reqData->buf);
+
+    if (s_onHttpRequestSetup)
+    {
+        rspBody = s_onHttpRequestSetup(reqMethod, reqUrl, reqBody);
+    }
+
+    rsp = createResponse(rspBody);
+
+    free(reqData->buf.base);
+
+    reqData->buf.base = rsp;
+    reqData->buf.len = strlen(rsp);
+
+    writeReq = (uv_write_t*)malloc(sizeof(uv_write_t));
+    writeReq->data = reqData;
+
+    uv_write(writeReq, (uv_stream_t*) reqData->tcp, &reqData->buf, 1, finishRequest);
+
+    if (s_onAfterHttpRequestSetup)
+    {
+        s_onAfterHttpRequestSetup(rspBody);
+    }
+
+    free(reqBody);
+    free(reqUrl);
+    free(reqMethod);
+}
+
+/*Process Extended Request*/
+static void processRequestExtended(uv_work_t* req)
+{
+    ReqData* reqData = (ReqData*) req->data;
+    uv_write_t* writeReq = 0;
+    char* rspBody = 0;
+    char* rsp = 0;
+
+    char* reqMethod = getMethod(&reqData->buf);
+    char* reqUrl = getUrl(&reqData->buf);
+    char* reqBody = getBody(&reqData->buf);
+
+    if (s_onHttpRequestExtended)
+    {
+        rspBody = s_onHttpRequestExtended(reqMethod, reqUrl, reqBody);
+    }
+
+    rsp = createResponse(rspBody);
+
+    free(reqData->buf.base);
+
+    reqData->buf.base = rsp;
+    reqData->buf.len = strlen(rsp);
+
+    writeReq = (uv_write_t*)malloc(sizeof(uv_write_t));
+    writeReq->data = reqData;
+
+    uv_write(writeReq, (uv_stream_t*) reqData->tcp, &reqData->buf, 1, finishRequest);
+
+    if (s_onAfterHttpRequestExtended)
+    {
+        s_onAfterHttpRequestExtended(rspBody);
+    }
+
+    free(reqBody);
+    free(reqUrl);
+    free(reqMethod);
+}
+
+/*Check if the request is complete*/
+static int isRequestComplete(uv_buf_t* buf)
+{
+    int gcl = getContentLength(buf);
+    int ccl = calcContentLength(buf);
+    char* rnrn = strstr(buf->base, "\r\n\r\n");
+    int ret = 0;
+
+    if (rnrn)
+    {
+        if (gcl < 0)
+        {
+            ret = 1;
+        }
+        else if (gcl == ccl)
+        {
+            ret = 1;
+        }
+    }
+
+    return ret;
+}
+
+/*Concatenate 2 strings*/
+static char* concatString(char* str1, size_t len1, char* str2, size_t len2)
+{
+    char* ret = (char*)malloc(sizeof(char) * (len1 + len2 + 1));
+
+    strncpy(ret, str1, len1);
+    strncpy(ret + len1, str2, len2);
+    ret[len1 + len2] = 0;
+
+    return ret;
+}
+
+/*Read Basic Request*/
+static void onReadBasic(uv_stream_t* tcp, ssize_t nread, const uv_buf_t* buf)
+{
+    if (nread >= 0)
+    {
+        uv_work_t* req;
+        ReqData* reqData;
+        uv_buf_t* tcpBuf = 0;
+        char* newBase = 0;
+        int newLen = 0;
+
+        if (tcp->data == 0)
+        {
+            tcp->data = malloc(sizeof(uv_buf_t));
+            ((uv_buf_t*)tcp->data)->len = 0;
+            ((uv_buf_t*)tcp->data)->base = 0;
+        }
+
+        tcpBuf = (uv_buf_t*)tcp->data;
+        newLen = tcpBuf->len + nread;
+        newBase = concatString(tcpBuf->base, tcpBuf->len, buf->base, nread);
+
+        free(tcpBuf->base);
+        tcpBuf->base = newBase;
+        tcpBuf->len = newLen;
+
+        if (isRequestComplete(tcpBuf))
+        {
+            req = (uv_work_t*) malloc(sizeof(uv_work_t));
+            reqData = (ReqData*) malloc(sizeof(ReqData));
+
+            reqData->tcp = (uv_tcp_t*)tcp;
+            reqData->buf.base = tcpBuf->base;
+            reqData->buf.len = tcpBuf->len;
+            req->data = (void*)reqData;
+
+            free(tcpBuf);
+            tcp->data = 0;
+
+            uv_queue_work(&s_loopBasic, req, processRequestBasic, freeWorkReq);
+        }
+    }
+    else if (nread != UV__EOF)
+    {
+        if (tcp->data)
+        {
+            free(((uv_buf_t*)tcp->data)->base);
+            free(tcp->data);
+        }
+
+        uv_close((uv_handle_t*) tcp, deleteHandle);
+    }
+
+    free(buf->base);
+}
+
+/*On New Basic Connection*/
+static void onNewConnectionBasic(uv_stream_t *server, int status)
+{
+    uv_tcp_t *client;
+
+    if (status == -1) {
+        return;
+    }
+
+    client = (uv_tcp_t*) malloc(sizeof(uv_tcp_t));
+    client->data = 0;
+    uv_tcp_init(&s_loopBasic, client);
+
+    if (uv_accept(server, (uv_stream_t*) client) == 0)
+    {
+        uv_read_start((uv_stream_t*) client, onAlloc, onReadBasic);
+    }
+    else
+    {
+        uv_close((uv_handle_t*) client, deleteHandle);
+    }
+}
+
+/*Read Setup Request*/
+static void onReadSetup(uv_stream_t* tcp, ssize_t nread, const uv_buf_t* buf)
+{
+    if (nread >= 0)
+    {
+        uv_work_t* req;
+        ReqData* reqData;
+        uv_buf_t* tcpBuf = 0;
+        char* newBase = 0;
+        int newLen = 0;
+
+        if (tcp->data == 0)
+        {
+            tcp->data = malloc(sizeof(uv_buf_t));
+            ((uv_buf_t*)tcp->data)->len = 0;
+            ((uv_buf_t*)tcp->data)->base = 0;
+        }
+
+        tcpBuf = (uv_buf_t*)tcp->data;
+        newLen = tcpBuf->len + nread;
+        newBase = concatString(tcpBuf->base, tcpBuf->len, buf->base, nread);
+
+        free(tcpBuf->base);
+        tcpBuf->base = newBase;
+        tcpBuf->len = newLen;
+
+        if (isRequestComplete(tcpBuf))
+        {
+            req = (uv_work_t*) malloc(sizeof(uv_work_t));
+            reqData = (ReqData*) malloc(sizeof(ReqData));
+
+            reqData->tcp = (uv_tcp_t*)tcp;
+            reqData->buf.base = tcpBuf->base;
+            reqData->buf.len = tcpBuf->len;
+            req->data = (void*)reqData;
+
+            free(tcpBuf);
+            tcp->data = 0;
+
+            uv_queue_work(&s_loopSetup, req, processRequestSetup, freeWorkReq);
+        }
+    }
+    else if (nread != UV__EOF)
+    {
+        if (tcp->data)
+        {
+            free(((uv_buf_t*)tcp->data)->base);
+            free(tcp->data);
+        }
+
+        uv_close((uv_handle_t*) tcp, deleteHandle);
+    }
+
+    free(buf->base);
+}
+
+/*On New Setup Connection*/
+static void onNewConnectionSetup(uv_stream_t *server, int status)
+{
+    uv_tcp_t *client;
+
+    if (status == -1) {
+        return;
+    }
+
+    client = (uv_tcp_t*) malloc(sizeof(uv_tcp_t));
+    client->data = 0;
+    uv_tcp_init(&s_loopSetup, client);
+
+    if (uv_accept(server, (uv_stream_t*) client) == 0)
+    {
+        uv_read_start((uv_stream_t*) client, onAlloc, onReadSetup);
+    }
+    else
+    {
+        uv_close((uv_handle_t*) client, deleteHandle);
+    }
+}
+
+
+/*Read Extended Request*/
+static void onReadExtended(uv_stream_t* tcp, ssize_t nread, const uv_buf_t* buf)
+{
+    if (nread >= 0)
+    {
+        uv_work_t* req;
+        ReqData* reqData;
+        uv_buf_t* tcpBuf = 0;
+        char* newBase = 0;
+        int newLen = 0;
+
+        if (tcp->data == 0)
+        {
+            tcp->data = malloc(sizeof(uv_buf_t));
+            ((uv_buf_t*)tcp->data)->len = 0;
+            ((uv_buf_t*)tcp->data)->base = 0;
+        }
+
+        tcpBuf = (uv_buf_t*)tcp->data;
+        newLen = tcpBuf->len + nread;
+        newBase = concatString(tcpBuf->base, tcpBuf->len, buf->base, nread);
+
+        free(tcpBuf->base);
+        tcpBuf->base = newBase;
+        tcpBuf->len = newLen;
+
+        if (isRequestComplete(tcpBuf))
+        {
+            req = (uv_work_t*) malloc(sizeof(uv_work_t));
+            reqData = (ReqData*) malloc(sizeof(ReqData));
+
+            reqData->tcp = (uv_tcp_t*)tcp;
+            reqData->buf.base = tcpBuf->base;
+            reqData->buf.len = tcpBuf->len;
+            req->data = (void*)reqData;
+
+            free(tcpBuf);
+            tcp->data = 0;
+
+            uv_queue_work(&s_loopExtended, req, processRequestExtended, freeWorkReq);
+        }
+    }
+    else if (nread != UV__EOF)
+    {
+        if (tcp->data)
+        {
+            free(((uv_buf_t*)tcp->data)->base);
+            free(tcp->data);
+        }
+
+        uv_close((uv_handle_t*) tcp, deleteHandle);
+    }
+
+    free(buf->base);
+}
+
+/*On New Extended Connection*/
+static void onNewConnectionExtended(uv_stream_t *server, int status)
+{
+    uv_tcp_t *client;
+
+    if (status == -1) {
+        return;
+    }
+
+    client = (uv_tcp_t*) malloc(sizeof(uv_tcp_t));
+    client->data = 0;
+    uv_tcp_init(&s_loopExtended, client);
+
+    if (uv_accept(server, (uv_stream_t*) client) == 0)
+    {
+        uv_read_start((uv_stream_t*) client, onAlloc, onReadExtended);
+    }
+    else
+    {
+        uv_close((uv_handle_t*) client, deleteHandle);
+    }
+}
+
+/*Stop Basic Http Server*/
+static void stopMiniHttpServerAsyncBasic(uv_async_t* handle)
+{
+    uv_stop(&s_loopBasic);
+}
+
+/*Stop Setup Http Server*/
+static void stopMiniHttpServerAsyncSetup(uv_async_t* handle)
+{
+    uv_stop(&s_loopSetup);
+}
+
+/*Stop Extended Http Server*/
+static void stopMiniHttpServerAsyncExtended(uv_async_t* handle)
+{
+    uv_stop(&s_loopExtended);
+}
+
+/*Start Basic Http Server Thread*/
+static void miniHttpServerThreadBasic(void *arg)
+{
+    uv_tcp_t server;
+    struct sockaddr_in bindAddr;
+
+    uv_loop_init(&s_loopBasic);
+    uv_tcp_init(&s_loopBasic, &server);
+    uv_async_init(&s_loopBasic, &s_stopAsyncBasic, stopMiniHttpServerAsyncBasic);
+
+    uv_ip4_addr(s_addrBasic, s_portBasic, &bindAddr);
+    uv_tcp_bind(&server, (const struct sockaddr*)&bindAddr, 0);
+
+    uv_listen((uv_stream_t*) &server, 128, onNewConnectionBasic);
+    uv_run(&s_loopBasic, UV_RUN_DEFAULT);
+
+    uv_close((uv_handle_t*)&server, 0);
+}
+
+/*Stop Basic Http Server*/
+void stopMiniHttpServerBasic()
+{
+    uv_async_send(&s_stopAsyncBasic);
+    uv_thread_join(&s_serverThreadIDBasic);
+
+    free(s_addrBasic);
+    s_addrBasic = 0;
+    s_portBasic = 0;
+    s_onHttpRequestBasic = 0;
+}
+
+/*Start Basic Http Server*/
+void startMiniHttpServerBasic(const char* addr, int port, httpRequestCB onHttpRequest, afterHttpRequestCB onAfterHttpRequest)
+{
+    int addrLen = strlen(addr);
+    s_addrBasic = (char*) malloc(sizeof(char) * (addrLen + 1));
+    strcpy(s_addrBasic, addr);
+    s_addrBasic[addrLen] = 0;
+    s_portBasic = port;
+    s_onHttpRequestBasic = onHttpRequest;
+    s_onAfterHttpRequestBasic = onAfterHttpRequest;
+
+    uv_thread_create(&s_serverThreadIDBasic, miniHttpServerThreadBasic, 0);
+}
+
+/*Start Setup Http Server Thread*/
+static void miniHttpServerThreadSetup(void *arg)
+{
+    uv_tcp_t server;
+    struct sockaddr_in bindAddr;
+
+    uv_loop_init(&s_loopSetup);
+    uv_tcp_init(&s_loopSetup, &server);
+    uv_async_init(&s_loopSetup, &s_stopAsyncSetup, stopMiniHttpServerAsyncSetup);
+
+    uv_ip4_addr(s_addrSetup, s_portSetup, &bindAddr);
+    uv_tcp_bind(&server, (const struct sockaddr*)&bindAddr, 0);
+
+    uv_listen((uv_stream_t*) &server, 128, onNewConnectionSetup);
+    uv_run(&s_loopSetup, UV_RUN_DEFAULT);
+
+    uv_close((uv_handle_t*)&server, 0);
+}
+
+/*Stop Setup Http Server Thread*/
+void stopMiniHttpServerSetup()
+{
+    uv_async_send(&s_stopAsyncSetup);
+    uv_thread_join(&s_serverThreadIDSetup);
+
+    free(s_addrSetup);
+    s_addrSetup = 0;
+    s_portSetup = 0;
+    s_onHttpRequestSetup = 0;
+}
+
+/*Start Setup Http Server*/
+void startMiniHttpServerSetup(const char* addr, int port, httpRequestCB onHttpRequest, afterHttpRequestCB onAfterHttpRequest)
+{
+    int addrLen = strlen(addr);
+    s_addrSetup = (char*) malloc(sizeof(char) * (addrLen + 1));
+    strcpy(s_addrSetup, addr);
+    s_addrSetup[addrLen] = 0;
+    s_portSetup = port;
+    s_onHttpRequestSetup = onHttpRequest;
+    s_onAfterHttpRequestSetup = onAfterHttpRequest;
+
+    uv_thread_create(&s_serverThreadIDSetup, miniHttpServerThreadSetup, 0);
+}
+
+
+/*Start Extended Http Server Thread*/
+static void miniHttpServerThreadExtended(void *arg)
+{
+    uv_tcp_t server;
+    struct sockaddr_in bindAddr;
+
+    uv_loop_init(&s_loopExtended);
+    uv_tcp_init(&s_loopExtended, &server);
+    uv_async_init(&s_loopExtended, &s_stopAsyncExtended, stopMiniHttpServerAsyncExtended);
+
+    uv_ip4_addr(s_addrExtended, s_portExtended, &bindAddr);
+    uv_tcp_bind(&server, (const struct sockaddr*)&bindAddr, 0);
+
+    uv_listen((uv_stream_t*) &server, 128, onNewConnectionExtended);
+    uv_run(&s_loopExtended, UV_RUN_DEFAULT);
+
+    uv_close((uv_handle_t*)&server, 0);
+}
+
+/*Stop Extended Http Server*/
+void stopMiniHttpServerExtended()
+{
+    uv_async_send(&s_stopAsyncExtended);
+    uv_thread_join(&s_serverThreadIDExtended);
+
+    free(s_addrExtended);
+    s_addrExtended = 0;
+    s_portExtended = 0;
+    s_onHttpRequestExtended = 0;
+}
+
+/*Start Extended Http Server*/
+void startMiniHttpServerExtended(const char* addr, int port, httpRequestCB onHttpRequest, afterHttpRequestCB onAfterHttpRequest)
+{
+    int addrLen = strlen(addr);
+    s_addrExtended = (char*) malloc(sizeof(char) * (addrLen + 1));
+    strcpy(s_addrExtended, addr);
+    s_addrExtended[addrLen] = 0;
+    s_portExtended = port;
+    s_onHttpRequestExtended = onHttpRequest;
+    s_onAfterHttpRequestExtended = onAfterHttpRequest;
+
+    uv_thread_create(&s_serverThreadIDExtended, miniHttpServerThreadExtended, 0);
+}
diff --git a/tests/automation/ctt/src/ResourceMap.c b/tests/automation/ctt/src/ResourceMap.c
new file mode 100755
index 00000000..7ff4b00f
--- /dev/null
+++ b/tests/automation/ctt/src/ResourceMap.c
@@ -0,0 +1,87 @@
+/******************************************************************
+ *
+ * Copyright 2016 Granite River Labs All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <libxml/tree.h>
+#include <ResourceMap.h>
+
+
+
+/*Create a Resource Map*/
+ResourceMap* createResourceMap()
+{
+    ResourceMap* map = (ResourceMap*)malloc(sizeof(ResourceMap));
+    map->head = 0;
+
+    return map;
+}
+
+/*Create and add a Resource to the Resource Map*/
+void addResourceCBS(ResourceMap* self, const char* method, const char* path, resourceCB onResource, afterResourceCB onAfterResource)
+{
+    Resource* newElement = (Resource*)malloc(sizeof(Resource));
+
+    strncpy(newElement->method, method, MAX_METHOD);
+    strncpy(newElement->path, path, MAX_PATH);
+    newElement->path[MAX_PATH] = 0;
+    newElement->resourceCBS.onResource = onResource;
+    newElement->resourceCBS.onAfterResource = onAfterResource;
+    newElement->next = self->head;
+
+    self->head = newElement;
+}
+
+/*Get Resource from the Resource Map*/
+ResourceCBS getResourceCBS(ResourceMap* self, const char* method, const char* path)
+{
+    Resource* res = self->head;
+    ResourceCBS resourceCBS;
+
+    resourceCBS.onResource = 0;
+    resourceCBS.onAfterResource = 0;
+
+    while (res != 0)
+    {
+        if (strcmp(res->method, method) == 0 && strcmp(res->path, path) == 0)
+        {
+            resourceCBS = res->resourceCBS;
+            break;
+        }
+
+        res = res->next;
+    };
+
+    return resourceCBS;
+}
+
+/*Delete Resource from the Resource Map*/
+void deleteResourceMap(ResourceMap* self)
+{
+    Resource* head = self->head;
+    Resource* nextHead = 0;
+
+    while (head != 0)
+    {
+        nextHead = head->next;
+        free(head);
+        head = nextHead;
+    };
+}
diff --git a/tests/automation/ctt/src/TAFAgent.c b/tests/automation/ctt/src/TAFAgent.c
new file mode 100644
index 00000000..f0d985ce
--- /dev/null
+++ b/tests/automation/ctt/src/TAFAgent.c
@@ -0,0 +1,1194 @@
+/******************************************************************
+ *
+ * Copyright 2016 Granite River Labs All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+#include <unistd.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/wait.h>
+#include <sys/types.h>
+#include <signal.h>
+#include <ctype.h>
+#include <stdbool.h>
+#include <time.h>
+#include <DUTController.h>
+#include <ifaddrs.h>
+#include <arpa/inet.h>
+
+#define TAG                  "OCF_TAF_AGENT"
+#define DEFAULT_CONTEXT_VALUE 0x99
+#define QOS_NON               0
+#define QOS_CON               1
+#define IPv4                  4
+#define IPv6                  6
+#define SLEEP_TIME            2
+#define JUSTWORKS             1
+#define RANDOMPIN             2
+#define MFG_CERT              3
+#define FRESH_CLIENT          1
+#define REUSE_CLIENT          3
+#define FRESH_SERVER          2
+#define REUSE_SERVER          4
+
+//macros
+#define FREE(x)           if(x){free(x);x=NULL;}
+
+//Globals
+char gCertificationApp[24] = "CertificationApp";
+int gIPDiscovered = 0;
+int gInsideMainLoop = 0;
+pid_t gPid;
+int gQuitFlag = 0;
+int gRestartFlag = 0;
+int gReuseIUT = 0;
+char *gConfigPath = NULL;
+char *gConfigFilename = NULL;
+char *gConfigFileContent = NULL;
+char gIUTlog[100] = "CertificationApp_";
+bool gSecured = false;
+char gIp[30];
+char gLocalIp[50];
+char gPort[25];
+char gUuid[50];
+int gFd;
+char gPinValue[9];
+static char s_DISCOVERY_QUERY[] = "%s/oic/res";
+char gCommandsArray[10][255];
+static int quit = 0;
+static pthread_mutex_t mutex;
+static pthread_cond_t cv;
+static struct timespec ts;
+
+//Function declaration
+void SendDiscovery();
+
+/*Replace String*/
+char *replaceString(const char *str, const char *from, const char *to)
+{
+
+    /* Adjust each of the below values to suit your needs. */
+
+    /* Increment positions cache size initially by this number. */
+    size_t cacheSizeInc = 16;
+    /* Thereafter, each time capacity needs to be increased,
+     * multiply the increment by this factor. */
+    const size_t cacheSizeIncFactor = 3;
+    /* But never increment capacity by more than this number. */
+    const size_t cacheSizeIncMax = 1048576;
+
+    char *pret, *ret = NULL;
+    const char *pstr2, *pstr = str;
+    size_t i, count = 0;
+    ptrdiff_t *posCache = NULL;
+    size_t cacheSize = 0;
+    size_t cpyLen, orgLen, retLen, toLen, fromLen = strlen(from);
+
+    /* Find all matches and cache their positions. */
+    while ((pstr2 = strstr(pstr, from)) != NULL)
+    {
+        count++;
+
+        /* Increase the cache size when necessary. */
+        if (cacheSize < count)
+        {
+            cacheSize += cacheSizeInc;
+            posCache = realloc(posCache, sizeof(*posCache) * cacheSize);
+            if (posCache == NULL)
+            {
+                goto end_repl_str;
+            }
+            cacheSizeInc *= cacheSizeIncFactor;
+            if (cacheSizeInc > cacheSizeIncMax)
+            {
+                cacheSizeInc = cacheSizeIncMax;
+            }
+        }
+
+        posCache[count - 1] = pstr2 - str;
+        pstr = pstr2 + fromLen;
+    }
+
+    orgLen = pstr - str + strlen(pstr);
+
+    /* Allocate memory for the post-replacement string. */
+    if (count > 0)
+    {
+        toLen = strlen(to);
+        retLen = orgLen + (toLen - fromLen) * count;
+    }
+    else    retLen = orgLen;
+    ret = malloc(retLen + 1);
+    if (ret == NULL)
+    {
+        goto end_repl_str;
+    }
+
+    if (count == 0)
+    {
+        /* If no matches, then just duplicate the string. */
+        strcpy(ret, str);
+    }
+    else
+    {
+        /* Otherwise, duplicate the string whilst performing
+         * the replacements using the position cache. */
+        pret = ret;
+        memcpy(pret, str, posCache[0]);
+        pret += posCache[0];
+        for (i = 0; i < count; i++)
+        {
+            memcpy(pret, to, toLen);
+            pret += toLen;
+            pstr = str + posCache[i] + fromLen;
+            cpyLen = (i == count - 1 ? orgLen : posCache[i + 1]) - posCache[i] - fromLen;
+            memcpy(pret, pstr, cpyLen);
+            pret += cpyLen;
+        }
+        ret[retLen] = '\0';
+    }
+
+end_repl_str:
+    /* Free the cache and return the post-replacement string,
+     * which will be NULL in the event of an error. */
+    FREE(posCache);
+    return ret;
+}
+
+/*Function to get the ip address of the machine where TAF is running*/
+void getIP(int ipVersion)
+{
+    struct ifaddrs *ifAddress;
+    char ipv6Address[50];
+    FILE *fp;
+    switch (ipVersion)
+    {
+        case IPv6:
+            
+           
+
+            if (getifaddrs(&ifAddress) == -1)
+            {
+                printf("Could not collect adress interfaces\n");
+                exit(1);
+            }
+
+            do
+            {
+                if (ifAddress->ifa_addr->sa_family == AF_INET6)
+                {
+                    char firstHextet[5];
+                    struct sockaddr_in6 *in6 = (struct sockaddr_in6*) ifAddress->ifa_addr;
+                    inet_ntop(AF_INET6, &in6->sin6_addr, ipv6Address, sizeof(ipv6Address));
+
+                    memcpy(firstHextet, &ipv6Address, 4);
+                    firstHextet[4] = '\0';
+                    if(!strcmp(firstHextet, "fe80"))
+                        break;
+                }
+            } while (ifAddress = ifAddress->ifa_next);
+
+            strcat(gLocalIp, ipv6Address);
+            strcat(gLocalIp, "%");
+            strcat(gLocalIp, ifAddress->ifa_name);
+            printf("Local IP :%s",gLocalIp);
+            break;
+
+        case IPv4:
+            //Works only on ubuntu
+            fp = popen("hostname -I", "r");
+            fscanf(fp, "%s", gLocalIp);
+            pclose(fp);
+            break;
+    }
+
+    if(gLocalIp[0] == '\0')
+    {
+        printf("Could not get Ip address\n");
+        exit(1);
+    }
+
+    printf("Local IP address: %s", gLocalIp);
+}
+
+/*Send command to the IUT simulator*/
+void SendCommand(char *cmd)
+{
+
+    if (cmd != NULL)
+    {
+        char searchCmd[256] = "xdotool search --name \"";
+        strcat(searchCmd, gCertificationApp);
+        strcat(searchCmd, "\" windowactivate");
+        char command[128] = "xdotool type --delay 1 --clearmodifiers ";
+        strcat(command, cmd);
+
+        system(searchCmd);
+        printf("Command %s\n", searchCmd);
+        system("xdotool key --clearmodifiers Return");
+
+        sleep(4);
+
+        system(command);
+        printf("Command %s\n", command);
+
+        system("xdotool key --clearmodifiers Return");
+    }
+}
+
+/*Find the value of the string in the log file*/
+void FindValue(char *searchString, char *value)
+{
+    FILE *fp1 = fopen(gIUTlog, "r");
+    char *line = NULL;
+    int i, j;
+    size_t len = 0;
+    ssize_t read;
+    int lineNo = 0;
+    if (fp1)
+    {
+        while ((read = getline(&line, &len, fp1)) != -1)
+        {
+            ++lineNo;
+            if ( (strstr(line, searchString) != NULL) &&
+                 (strstr(line , ":") != NULL)
+               )
+            {
+                char *pos = strstr(line, ":");
+                char data;
+                for (i = 1, j = 0; * (pos + i) != '\0'; i++)
+                {
+                    data = *(pos + i);
+                    if (!isspace(data))
+                    {
+                        *(value + j) = data;
+                        j++;
+                    }
+                }
+                *(value + j) = '\0';
+
+            }
+
+        }
+        fclose(fp1);
+
+    }
+}
+
+/*Find the key in the string*/
+void FindKey(char *searchString, char *key)
+{
+    FILE *fp1 = fopen(gIUTlog, "r");
+    char *line = NULL;
+    int i, j;
+    size_t len = 0;
+    ssize_t read;
+    int lineNo = 0;
+    if (fp1)
+    {
+        while ((read = getline(&line, &len, fp1)) != -1)
+        {
+            ++lineNo;
+            if ( (strstr(line, ". ") != NULL) &&
+                 (strstr(line , searchString) != NULL))
+            {
+                char *pos = strstr(line, ".");
+                char data;
+                for (i = 0, j = 0; (i < 8) && (line[i] != *pos); i++)
+                {
+                    data = *(line + i);
+                    if (!isspace(data))
+                    {
+                        *(key + j) = data;
+                        j++;
+                    }
+                }
+                *(key + j) = '\0';
+
+            }
+
+        }
+        fclose(fp1);
+
+    }
+}
+
+
+/*Send command to the IUT Simulator in bulk*/
+void SendCommands(int commandLength)
+{
+    printf("Inside SendCommand \n");
+    sleep(5 * SLEEP_TIME);
+    for (int i = 0; i < commandLength; i++)
+    {
+        SendCommand(gCommandsArray[i]);
+        sleep(SLEEP_TIME);
+    }
+}
+
+/*XML Doc Ptr Clean*/
+void CleanXmlDocPtr(xmlDocPtr doc)
+{
+    if(doc)
+        xmlFreeDoc(doc);
+}
+
+/*XML action handler*/
+xmlDocPtr ActionHandler(xmlDocPtr doc)
+{
+
+    char *result = (char *)"";
+    char val[8], value[128];
+
+    const char *messageXml = docToString(doc);
+    printf("Message Received from CTT: %s\n",messageXml);
+
+    if (strstr(messageXml, "<message>Waiting for CoAP response... ") == NULL &&
+        strstr(messageXml, "<message>Please wait...") == NULL )
+    {
+        printf("%s\n", messageXml);
+    }
+
+    if (strstr(messageXml, "<message>Waiting for CoAP response... ") != NULL)
+    {
+        //SKIP
+    }
+    else if ( strstr(messageXml , "<message>If IUT uses an OCF Rooted Certificate Chain") != NULL)
+    {
+        asprintf(&result,
+                 "<actionResult><userDialogResponse><answer>Skip</answer></userDialogResponse></actionResult>");
+    }
+    else if ( strstr(messageXml , "<message>Please provide (paste) public key of CA (PEM type)") != NULL)
+    {
+        printf("Please provide (paste) public key of CA (PEM type) \n");
+
+        const char *publicKey =
+            "-----BEGIN CERTIFICATE-----\n"
+            "MIICBDCCAaugAwIBAgIIZ0QY0VJs8zIwCgYIKoZIzj0EAwIwSjELMAkGA1UEBhMC\n"
+            "VVMxDDAKBgNVBAoMA09DRjETMBEGA1UECwwKT0NGIENUVCBDQTEYMBYGA1UEAwwP\n"
+            "T0NGIENUVCBST09UIENBMB4XDTE3MDEwMTAwMDAwMFoXDTI3MDEwMTAwMDAwMFow\n"
+            "SjELMAkGA1UEBhMCVVMxDDAKBgNVBAoMA09DRjETMBEGA1UECwwKT0NGIENUVCBD\n"
+            "QTEYMBYGA1UEAwwPT0NGIENUVCBST09UIENBMFkwEwYHKoZIzj0CAQYIKoZIzj0D\n"
+            "AQcDQgAEuKkiScoLLyjGALXhr2PijOyf0RRqXnKY8VXFM+aHkdYxiJHD5MziSXsT\n"
+            "hDB82Hx7ykz8Fil0cBuE1tX4gX87/qN7MHkwKwYDVR0jBCQwIoAgVapQxp8Fthci\n"
+            "DZjQdj0AdbaKBr9aXrlJxD9unFaRlCswKQYDVR0OBCIEIFWqUMafBbYXIg2Y0HY9\n"
+            "AHW2iga/Wl65ScQ/bpxWkZQrMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQD\n"
+            "AgEGMAoGCCqGSM49BAMCA0cAMEQCIEfUv9VTQrFDg9/kqnTHpLBDRVgoMlAFsDgW\n"
+            "S02KANuyAiAQsZeEhxTCqGhQwRQpIoI+WJ2maHa+pfuuwGXc+GH+Tg==\n"
+            "-----END CERTIFICATE-----";
+
+        asprintf(&result,
+                 "<actionResult><userDialogResponse><answer>Set_Value</answer><data>%s</data></userDialogResponse></actionResult>",
+                 publicKey);
+    }
+    else if ( strstr(messageXml , "<message>Please enter PIN:") != NULL)
+    {
+        // Get PIN generated by the CertificationApp
+        FindValue("PIN CODE : ", gPinValue);
+
+        asprintf(&result,
+                 "<actionResult><userDialogResponse><answer>Set_Value</answer><data>%s</data></userDialogResponse></actionResult>",
+                 gPinValue);
+    }
+    else if ( strstr(messageXml,
+                     "<message>Please initiate device to revert to \"ready for OTM\" state") != NULL ||
+              strstr(messageXml, "<message>Please reset DUT's ACL in order to have empty list.") != NULL ||
+              strstr(messageXml, "<message>Please revert IUT to RFOTM / reset the device") != NULL)
+    {
+        // Reset the CertificationApp
+        gRestartFlag = 1;
+	sleep(1);
+	while(gInsideMainLoop == 0){
+	    sleep(1);
+	}
+        asprintf(&result,
+                 "<actionResult><userDialogResponse><answer>OK</answer></userDialogResponse></actionResult>");
+    }
+    else if ( strstr(messageXml, "<message>Please cycle power on the IUT") != NULL)
+    {
+        /* Reset the CertificationApp */
+        gRestartFlag = 1;
+        gReuseIUT = 1;
+        gIPDiscovered = 0;
+        printf("Wait for TAF to discover IUT after reset \n");
+        do {sleep(1);} while (!gIPDiscovered);
+        asprintf(&result,
+                 "<actionResult><userDialogResponse><answer>OK</answer></userDialogResponse></actionResult>");
+    }
+    #if 0
+    else if ( strstr(messageXml, "Please revert IUT to RFOTM / reset the device") != NULL)
+    {
+         /* Reset the CertificationApp */
+        gRestartFlag = 1;
+        gReuseIUT = 1;
+        gIPDiscovered = 0;
+        printf("Wait for TAF to discover IUT after reset \n");
+        do {sleep(1);} while (!gIPDiscovered);
+        /* Reset the CertificationApp */
+        asprintf(&result,
+                 "<actionResult><userDialogResponse><answer>OK</answer></userDialogResponse></actionResult>");
+    }
+    #endif
+    else if ( strstr(messageXml, "<message>Please reset the IUT") != NULL)
+    {
+        /* Reset the CertificationApp */
+        asprintf(&result,
+                 "<actionResult><userDialogResponse><answer>OK</answer></userDialogResponse></actionResult>");
+    }
+    
+    else if (strstr(messageXml, "<message>Please change some value in /BinarySwitchResURI resource") !=
+             NULL)
+    {
+
+        if (strstr(messageXml, "and press OK") != NULL)
+        {
+
+            sleep(10);
+            asprintf(&result,
+                     "<actionResult><userDialogResponse><answer>OK</answer></userDialogResponse></actionResult>");
+        }
+        else
+        {
+
+            strcpy(gCommandsArray[0], "34");
+            strcpy(gCommandsArray[1], "1");
+            strcpy(gCommandsArray[2], "value");
+            strcpy(gCommandsArray[3], "4");
+            strcpy(gCommandsArray[4], "0");
+            SendCommands(5);
+        }
+    }
+    else if (strstr(messageXml, "<message>If the device uses an OCF Rooted Certificate Chain, click 'Skip'. Otherwise please provide (paste) the CA (PEM type) known to the device") != NULL)
+    {
+            asprintf(&result,
+                     "<actionResult><userDialogResponse><answer>Skip</answer></userDialogResponse></actionResult>");
+     }
+    else if (strstr(messageXml, "<message>Please change some value in /binaryswitch resource and press OK") != NULL)
+    {
+
+            sleep(2);
+            asprintf(&result,
+                     "<actionResult><userDialogResponse><answer>OK</answer></userDialogResponse></actionResult>");
+     }
+     else if (strstr(messageXml, "<message>Please change some value in /humidity resource and press OK") !=
+             NULL)
+     {
+            sleep(2);
+            asprintf(&result,
+                     "<actionResult><userDialogResponse><answer>OK</answer></userDialogResponse></actionResult>");
+
+     }
+
+    else if (strstr(messageXml, "<message>Did IUT receive response:") != NULL)
+    {
+
+        asprintf(&result,
+                 "<actionResult><userDialogResponse><answer>Yes</answer></userDialogResponse></actionResult>");
+    }
+    else if (strstr(messageXml, "<message>Was device discovered sucessfully?") != NULL)
+    {
+        //TODO: Check if device was indeed discovered
+        asprintf(&result,
+                 "<actionResult><userDialogResponse><answer>Yes</answer></userDialogResponse></actionResult>");
+    }
+    else if (strstr(messageXml, "<message>Did IUT received NOTIFY:") != NULL)
+    {
+        asprintf(&result,
+                 "<actionResult><userDialogResponse><answer>Yes</answer></userDialogResponse></actionResult>");
+
+    }
+    else if (strstr(messageXml, "<message>Please change some value in /AirFlowResURI resource") !=
+             NULL)
+    {
+        if (strstr(messageXml, "and press OK") != NULL)
+        {
+            sleep(10);
+            asprintf(&result,
+                     "<actionResult><userDialogResponse><answer>OK</answer></userDialogResponse></actionResult>");
+        }
+        else
+        {
+            strcpy(gCommandsArray[0], "34");
+            strcpy(gCommandsArray[1], "5");
+            strcpy(gCommandsArray[2], "speed");
+            strcpy(gCommandsArray[3], "1");
+            strcpy(gCommandsArray[4], "25");
+            SendCommands(5);
+
+        }
+    }
+
+    else if (strstr(messageXml, "<message>Please change some value in /TemperatureResURI resource") !=
+             NULL)
+    {
+        if (strstr(messageXml, "and press OK") != NULL)
+        {
+            //OIC_LOG(INFO, TAG, "Temperature URI Ok");
+            sleep(10);
+            asprintf(&result,
+                     "<actionResult><userDialogResponse><answer>OK</answer></userDialogResponse></actionResult>");
+        }
+        else
+        {
+            strcpy(gCommandsArray[0], "34");
+            strcpy(gCommandsArray[1], "3");
+            strcpy(gCommandsArray[2], "temperature");
+            strcpy(gCommandsArray[3], "3");
+            strcpy(gCommandsArray[4], "25.5");
+            SendCommands(5);
+        }
+    }
+    else if (strstr(messageXml,
+                    "<message>Please send a multicast discovery request message (i.e. CoAP GET) to") != NULL ||
+             strstr(messageXml,
+                    "Please initiate the Endpoint discovery process") != NULL)
+    {
+        SendCommand("12");
+        sleep(SLEEP_TIME);
+    }
+    else if (strstr(messageXml, "<message>Please have the IUT establish a TCP connection") != NULL)
+    {
+            SendCommand("12");
+            sleep(2 * SLEEP_TIME);
+            SendCommand("17");
+            FindKey("/BinarySwitchResURI", val);
+            SendCommand(val);
+            sleep(SLEEP_TIME);
+            SendCommand("n");
+            FindKey("coaps+tcp", val);
+            SendCommand(val);
+            sleep(SLEEP_TIME);
+
+        asprintf(&result,
+                 "<actionResult><userDialogResponse><answer>OK</answer></userDialogResponse></actionResult>");
+    }
+    else if (strstr(messageXml, " send a unicast RETRIEVE request (i.e. CoAP GET) to ") != NULL)
+    {
+        if (strstr(messageXml, "/BinarySwitchResURI") != NULL)
+        {
+            printf("Inside /BinarySwitchResURI \n");
+            SendCommand("12");
+            sleep(2 * SLEEP_TIME);
+            SendCommand("17");
+            FindKey("/BinarySwitchResURI", val);
+            SendCommand(val);
+            sleep(SLEEP_TIME);
+            if (strstr(messageXml, "over TCP") != NULL)
+            {
+                SendCommand("n");
+                FindKey("coaps+tcp", val);
+                SendCommand(val);
+            }
+            else
+            {
+                SendCommand("y");
+            }
+            sleep(SLEEP_TIME);
+        }
+        else if (strstr(messageXml, "/TemperatureResURI") != NULL)
+        {
+            printf("Inside /TemperatureResURI \n");
+            SendCommand("12");
+            sleep(2 * SLEEP_TIME);
+            SendCommand("17");
+            FindKey("/TemperatureResURI", val);
+            SendCommand(val);
+            sleep(SLEEP_TIME);
+            if (strstr(messageXml, "over TCP") != NULL)
+            {
+                SendCommand("n");
+                FindKey("coaps+tcp", val);
+                SendCommand(val);
+            }
+            else
+            {
+                SendCommand("y");
+            }
+            sleep(SLEEP_TIME);
+        }
+        else
+        {
+            asprintf(&result,
+                     "<actionResult><userDialogResponse><answer>CANCEL</answer></userDialogResponse></actionResult>");
+        }
+    }
+    else if (strstr(messageXml, "send a unicast partial UPDATE request") != NULL)
+    {
+        sleep(2 * SLEEP_TIME);
+        if (strstr(messageXml, "/BinarySwitchResURI") != NULL)
+        {
+            printf("Inside Switch \n");
+            SendCommand("12");
+            sleep(2 * SLEEP_TIME);
+            SendCommand("17");
+            FindKey("/BinarySwitchResURI", val);
+            SendCommand(val);
+            sleep(SLEEP_TIME);
+            if (strstr(messageXml, "over TCP") != NULL)
+            {
+                SendCommand("n");
+                FindKey("coaps+tcp", val);
+                SendCommand(val);
+            }
+            else
+            {
+                SendCommand("y");
+            }
+            sleep(SLEEP_TIME);
+            FindValue("value", value);
+            SendCommand("22");
+            FindKey("/BinarySwitchResURI", val);
+            SendCommand(val);
+            sleep(SLEEP_TIME);
+            if (strstr(messageXml, "over TCP") != NULL)
+            {
+                SendCommand("n");
+                FindKey("coaps+tcp", val);
+                SendCommand(val);
+            }
+            else
+            {
+                SendCommand("y");
+            }
+            sleep(SLEEP_TIME);
+            SendCommand("value");
+            sleep(SLEEP_TIME);
+            SendCommand("4");
+            sleep(SLEEP_TIME);
+            if (strcmp(value, "false") == 0)
+            {
+                SendCommand("1");
+            }
+            else if (strcmp(value, "true") == 0)
+            {
+                SendCommand("0");
+
+            }
+            sleep(SLEEP_TIME);
+        }
+        else if (strstr(messageXml, "/TemperatureResURI") != NULL)
+        {
+            printf("Inside TemperatureResURI \n");
+            SendCommand("12");
+            sleep(2 * SLEEP_TIME);
+            SendCommand("22");
+            FindKey("/TemperatureResURI", val);
+            SendCommand(val);
+            sleep(SLEEP_TIME);
+            if (strstr(messageXml, "over TCP") != NULL)
+            {
+                SendCommand("n");
+                FindKey("coaps+tcp", val);
+                SendCommand(val);
+            }
+            else
+            {
+                SendCommand("y");
+            }
+            sleep(SLEEP_TIME);
+            SendCommand("temperature");
+            sleep(SLEEP_TIME);
+            SendCommand("3");
+            sleep(SLEEP_TIME);
+            SendCommand("22.5");
+            sleep(SLEEP_TIME);
+
+        }
+        else
+        {
+            asprintf(&result,
+                    "<actionResult><userDialogResponse><answer>CANCEL</answer></userDialogResponse></actionResult>");
+        }
+    }
+    else if (strstr(messageXml, " send a unicast request message (") != NULL)
+    {
+        printf("Inside unicast request \n");
+        if (strstr(messageXml, "/BinarySwitchResURI") != NULL)
+        {
+            sleep(SLEEP_TIME);
+            SendCommand("12");
+            sleep(2 * SLEEP_TIME);
+            if (strstr(messageXml, "with observe option = 0") != NULL)
+            {
+                SendCommand("25");
+            }
+            else if (strstr(messageXml, "with observe option = 1") != NULL)
+            {
+                SendCommand("25");
+                FindKey("/BinarySwitchResURI", val);
+                SendCommand(val);
+                sleep(SLEEP_TIME);
+                if (strstr(messageXml, "over TCP") != NULL)
+                {
+                    SendCommand("n");
+                    FindKey("coaps+tcp", val);
+                    SendCommand(val);
+                }
+                else
+                {
+                    SendCommand("y");
+                }
+                sleep(SLEEP_TIME);
+                SendCommand("26");
+            }
+            FindKey("/BinarySwitchResURI", val);
+            SendCommand(val);
+            sleep(SLEEP_TIME);
+            if (strstr(messageXml, "over TCP") != NULL)
+            {
+                SendCommand("n");
+                FindKey("coaps+tcp", val);
+                SendCommand(val);
+            }
+            else
+            {
+                SendCommand("y");
+            }
+            sleep(SLEEP_TIME);
+        }
+        else if (strstr(messageXml, "/TemperatureResURI") != NULL)
+        {
+            SendCommand("12");
+            sleep(2 * SLEEP_TIME);
+            if (strstr(messageXml, "with observe option = 0") != NULL)
+            {
+                SendCommand("25");
+            }
+            else if (strstr(messageXml, "with observe option = 1") != NULL)
+            {
+                SendCommand("26");
+            }
+            FindKey("/TemperatureResURI", val);
+            SendCommand(val);
+            sleep(SLEEP_TIME);
+            if (strstr(messageXml, "over TCP") != NULL)
+            {
+                SendCommand("n");
+                FindKey("coaps+tcp", val);
+                SendCommand(val);
+            }
+            else
+            {
+                SendCommand("y");
+            }
+            sleep(SLEEP_TIME);
+        }
+    }
+    else if (strstr(messageXml, "send UPDATE to /oic/rd") != NULL)
+    {
+        printf("Inside RD request \n");
+        SendCommand("12");
+        sleep(4 * SLEEP_TIME);
+        SendCommand("110");
+        sleep(2 * SLEEP_TIME);
+    }
+    else if (strstr(messageXml, "send DELETE to /oic/rd") != NULL)
+    {
+        printf("Inside RD request \n");
+        SendCommand("12");
+        sleep(2 * SLEEP_TIME);
+        SendCommand("112");
+        sleep(2 * SLEEP_TIME);
+    }
+    else if (strstr(messageXml, "Please provide the Mediator with the generated cis") != NULL)
+    {
+        asprintf(&result,
+                "<actionResult><userDialogResponse><answer>OK</answer></userDialogResponse></actionResult>");
+    }
+    else if (strstr(messageXml, "Please initiate transfer of Cloud configuration") != NULL)
+    {
+        SendCommand("12");
+        sleep(SLEEP_TIME);
+        SendCommand("39");
+        sleep(SLEEP_TIME);
+    }
+    else if (strstr(messageXml,
+                    "<message>Does IUT have the possibility to display received properties values?") != NULL)
+    {
+        asprintf(&result,
+                 "<actionResult><userDialogResponse><answer>Yes</answer></userDialogResponse></actionResult>");
+    }
+    else if (strstr(messageXml,
+                    "<message>Does IUT has discovered a device (i.e. the CTT) with the expected Resource Types?") !=
+             NULL)
+    {
+        asprintf(&result,
+                 "<actionResult><userDialogResponse><answer>Yes</answer></userDialogResponse></actionResult>");
+    }
+    else if (strstr(messageXml, "<message>Does IUT presents following properties values?") != NULL)
+    {
+        asprintf(&result,
+                 "<actionResult><userDialogResponse><answer>Yes</answer></userDialogResponse></actionResult>");
+    }
+    else
+    {
+        printf("TAF==Received not handled POST /actions: %s \n", messageXml);
+    }
+
+    if (result != "")
+    {
+        printf("%s\n", result);
+    }
+
+    return stringToDoc(result);
+}
+
+/*Abort Signal Handler*/
+xmlDocPtr AbortSignalHandler(xmlDocPtr doc)
+{
+    printf("TAF==Received GET /abortSignal: \n");
+    return stringToDoc("<abortSignal><abortTestcase>false</abortTestcase><abortTestRun>false</abortTestRun></abortSignal>");
+
+}
+
+/*Configuration handler*/
+xmlDocPtr ConfigurationHandler(xmlDocPtr doc)
+{
+    printf("Inside Configuration Handler \n");
+    if (gConfigFileContent == NULL)
+    {
+        long length;
+        FILE *f = fopen (gConfigPath, "rb");
+        if (f)
+        {
+            printf("FILE OPENED \n");
+            fseek (f, 0, SEEK_END);
+            length = ftell (f);
+            fseek (f, 0, SEEK_SET);
+            gConfigFileContent = malloc (length + 1);
+
+            if (gConfigFileContent )
+            {
+                fread (gConfigFileContent , 1, length, f);
+                gConfigFileContent[length] = '\0';
+            }
+            fclose (f);
+        }
+        else
+        {
+            printf("Could not open file %s \n", gConfigFileContent);
+            return stringToDoc("");
+        }
+    }
+    uint32_t tempSize = 0;
+    char *result = gConfigFileContent;
+    char *tmp = replaceString(gConfigFileContent, "%IP%", gIp);
+    strcpy(gUuid,"294f1f35-6161-4895-6e7d-c2d0f729c42c");
+    result = replaceString(tmp, "%PORT%", gPort);
+    printf("config:%s",result);
+    return stringToDoc(result);
+}
+
+/*Init TAF Agent*/
+void  InitTAF()
+{
+
+    printf("TAF Init Start \n");
+
+    initDutControllers();
+    addRouteBasic("POST", "/actions", ActionHandler, CleanXmlDocPtr);
+    addRouteBasic("GET", "/abortSignal", AbortSignalHandler, CleanXmlDocPtr);
+    if (gConfigPath != NULL)
+    {
+        addRouteSetup("GET", "/processes/ctt/configuration", ConfigurationHandler, CleanXmlDocPtr);
+    }
+    startDutControllerBasic("0.0.0.0", 32000);
+    startDutControllerExtended("0.0.0.0", 32001);
+    startDutControllerSetup("0.0.0.0", 32002);
+
+    printf("TAF Init Done \n");
+}
+
+
+/*Init the IUT Simulator*/
+void initIUT(int qosArg, int ipVerArg, int securityArg, char *ocfVerArg, char initActions[][5], int initActionsSize)
+{
+    printf("IUT options: %d %d %d\n", qosArg, ipVerArg, securityArg);
+    char app[255] = "CertificationApp";
+
+    switch (qosArg)
+    {
+        case QOS_NON:
+            strcat(app, " 0");
+            break;
+
+        case QOS_CON:
+            strcat(app, " 1");
+            break;
+
+        default:
+            printf("QoS argument \"%d\" is invalid\n", qosArg);
+            exit(1);
+    }
+
+    switch (ipVerArg)
+    {
+        case IPv4:
+            strcat(app, " 4");
+            break;
+
+        case IPv6:
+            strcat(app, " 6");
+            break;
+
+        default:
+            printf("IP version argument \"%d\" is invalid\n", ipVerArg);
+            exit(1);
+    }
+
+    switch (securityArg/10)
+    {
+        case FRESH_CLIENT:
+            strcat(app, " 1");
+            break;
+
+        case REUSE_CLIENT:
+            strcat(app, " 3");
+            break;
+
+        case FRESH_SERVER:
+            strcat(app, " 2");
+            break;
+
+        case REUSE_SERVER:
+            strcat(app, " 4");
+            break;
+
+        default:
+            printf("Security argument \"%d\" is invalid\n", securityArg);
+            exit(1);
+    }
+
+    switch (securityArg%10)
+    {
+        case JUSTWORKS:
+            strcat(app, "1");
+            break;
+
+        case RANDOMPIN:
+            strcat(app, "2");
+            break;
+
+        case MFG_CERT:
+            strcat(app, "3");
+            break;
+
+        default:
+            printf("Security argument \"%d\" is invalid\n", securityArg);
+            exit(1);
+    }
+
+    strcat(app, " ");
+    strcat(app, ocfVerArg);
+
+    char parameters[255] = "result=1\nwhile [ $result -ne 0 ]; do \nxterm -title \"";
+    strcat(parameters, gCertificationApp);
+    strcat(parameters, "\" -e ./");
+    strcat(parameters, app);
+    strcat(parameters, " | tee ");
+    strcat(parameters, gIUTlog);
+    strcat(parameters, "\n result=$?\ndone");
+    printf("Command Executed:%s\n", parameters);
+    if ((gPid = fork()) < 0)
+    {
+        printf("Fork failed \n");
+        exit(1);
+    }
+    if (gPid == 0)
+    {
+        system("pkill --signal SIGKILL CertificationApp");
+        sleep(1);
+        printf("gPid == 0\n");
+        execlp("/bin/sh", "/bin/sh", "-c", parameters, NULL);
+        sleep(5);
+        exit(0);
+    }
+
+    sleep(3);
+    for(int i = 0; i < initActionsSize; i++)
+    {
+        printf("%d\n", i);
+        printf("Sending %s to CertificationApp\n", initActions[i]);
+        SendCommand(initActions[i]);
+        sleep(1);
+    }
+}
+
+/*Stop the CertificationApp*/
+void stopIUT()
+{
+    char value[255] = "0";
+    printf("Sending %s to CertificationApp\n", value);
+    SendCommand(value);
+}
+
+/*Discovery the IUT Simulator port */
+void discoverIUT(int ipVersion)
+{
+
+  FILE *fp;
+  char path[1035];
+
+  /* Open the command for reading. */
+  fp = popen("./discover_device 2>&1", "r");
+  if (fp == NULL) {
+    printf("Failed to run command\n" );
+    exit(1);
+  }
+  int i = 0;
+  /* Read the output a line at a time - output it. */
+  while (fgets(path, sizeof(path), fp) != NULL) {
+    if(i == 0)
+    {
+      //i++;
+    }
+    else if(i == 1){//IPV6
+
+            printf("%s", path);
+            strcpy(gIp, gLocalIp);
+            strcpy(gIp, strtok(gIp, "%"));
+
+            strcat(gIp, "%13");
+            gIPDiscovered = 1;
+   } 
+    else if(i == 2)//IPV6 coap port not
+    {
+        
+
+        printf("%s", path);
+        strncpy(gPort, path,5);
+
+    }
+    i++;
+  }
+
+  /* close */
+  pclose(fp);        
+  
+
+}
+
+/*SIGINT handler: set gQuitFlag to 1 for graceful termination*/
+void HandleSigInt(int signum)
+{
+    if ((signum == SIGINT) || (signum == SIGTERM) || (signum == SIGTSTP))
+    {
+        gQuitFlag = 1;
+        gRestartFlag = 1;
+       // stopIUT();
+    }
+
+}
+
+void startIUTfromArguments(int argc, char **argv)
+{
+    int qosArg = atoi(argv[2]);
+    int ipVerArg = atoi(argv[3]);
+    int securityArg = atoi(argv[4]);
+    char* ocfVerArg = argv[5];
+    int initialCommandsSize = argc - 6;
+    char initialCommands[initialCommandsSize][5];
+    for(int i = 0; i < initialCommandsSize; i++)
+    {
+        strcpy(initialCommands[i], argv[6 + i]);
+    }
+
+    if (gReuseIUT)
+    {
+        initIUT(qosArg, ipVerArg, securityArg + 20, ocfVerArg, initialCommands, initialCommandsSize);
+        gReuseIUT = 0;
+    }
+    else
+    {
+        initIUT(qosArg, ipVerArg, securityArg, ocfVerArg, initialCommands, initialCommandsSize);
+    }
+}
+
+/*Main Entry point of the code*/
+int main(int argc, char **argv)
+{
+    printf("Started\n");
+
+int ipVerArg = atoi(argv[3]);
+    if (argc < 6)
+    {
+        printf("Error: Wrong amount of arguments, shoule be:\n./TAFAgent conf_path QoS ipVersion security ocfVersion\n");
+        return -1;
+    }
+
+    /* get the configuration file path */
+    gConfigPath = argv[1];
+
+    printf("Start to open file %s\n", gConfigPath);
+    FILE *fp;
+
+    fp = fopen(gConfigPath, "r");
+    if (fp == NULL)
+    {
+        printf("Error: Could not find file %s", gConfigPath);
+        return -1;
+    }
+    fclose(fp);
+ startIUTfromArguments(argc, argv);
+    getIP(ipVerArg);
+
+    signal(SIGINT, HandleSigInt);
+const int trigger = CLOCKS_PER_SEC;
+
+
+    sleep(3);
+   printf("DiscoverIUT first time\n");
+  discoverIUT(atoi(argv[3]));
+    InitTAF();
+    while (!gQuitFlag)
+    {
+        
+        if (!gIPDiscovered)
+        {
+            startIUTfromArguments(argc, argv);
+            discoverIUT(atoi(argv[3]));
+        }
+
+        printf("Entering TAF Agent main loop...\n");
+        clock_t prevClock = clock() - trigger;
+        while (!gRestartFlag)
+        {
+            gInsideMainLoop = 1;
+            clock_t curClock = clock();
+            if(curClock - prevClock >= trigger){
+                printf(".\n");
+                prevClock = curClock;
+            }
+        }
+        gInsideMainLoop = 0;
+        printf("Exiting TAF Agent main loop...\n");
+        stopIUT();
+
+        system("ls -lrt CertificationApp_creds/");
+        system("rm -rf CertificationApp_creds/*");
+
+        gIPDiscovered = 0;
+        gRestartFlag = 0;
+    }
+    stopDutControllers();
+    disposeDutControllers();
+    FREE(gConfigFileContent);
+
+    return 0;
+}
-- 
2.16.1.windows.1

