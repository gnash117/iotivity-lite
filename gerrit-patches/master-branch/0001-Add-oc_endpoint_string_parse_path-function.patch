From 43c99edb56d8f5573b35410fb1b9e5bf350c2af6 Mon Sep 17 00:00:00 2001
From: George Nash <george.nash@intel.com>
Date: Fri, 18 Oct 2019 14:42:55 -0700
Subject: [PATCH] Add oc_endpoint_string_parse_path function

This enables getting just the uri portion of an endpoint from
an endpoint string.

This is useful for a few reasons.
- The introspection contains an endpoint string to
  the introspection data. Since we typically already have the
  endpoint there is no need to used the oc_string_to_endpoint
  function and allocate another copy of the endpoint when we are
  only interested in the path part of the string.

- Language bindings with Java. Functions that return multiple
  values through variables require unusual workarounds to get
  a clean Java API.  By making this availible in a separate
  function we can make two functions with only one
  responability. Making the Java APIs cleaner.

While testing the oc_endpoint_string_parse_path function multiple
failures showed up in the StringToEndpoint unit test. Once
I figured out the failures were due to the fact that my build
did not have IPV4=1 I updated the StringToEndpoint test so
it will not test IPV4 strings if OC_IPV4 is not defined.

Change-Id: Ic8522978cd29e15caba56ebab1007e3cc69ff38a
Signed-off-by: George Nash <george.nash@intel.com>
---
 api/oc_endpoint.c       |  44 +++++++++
 api/unittest/eptest.cpp | 234 ++++++++++++++++++++++++++++++++++++++----------
 include/oc_endpoint.h   |   1 +
 3 files changed, 232 insertions(+), 47 deletions(-)

diff --git a/api/oc_endpoint.c b/api/oc_endpoint.c
index 53286aac..c3022c89 100644
--- a/api/oc_endpoint.c
+++ b/api/oc_endpoint.c
@@ -496,6 +496,50 @@ oc_string_to_endpoint(oc_string_t *endpoint_str, oc_endpoint_t *endpoint,
   return -1;
 }
 
+int
+oc_endpoint_string_parse_path(oc_string_t *endpoint_str, oc_string_t *path)
+{
+  if (!endpoint_str) {
+    return -1;
+  }
+  if (!path) {
+    return -1;
+  }
+
+  const char *address = NULL;
+
+  address = strstr(oc_string(*endpoint_str), "://");
+  if(!address) {
+    return -1;
+  }
+  // 3 is string length of "://"
+  address += 3;
+
+  size_t len = oc_string_len(*endpoint_str) - (address - oc_string(*endpoint_str));
+
+  // the smallest possible address is '0' anything smaller is invalid.
+  if(len < 1) {
+    return -1;
+  }
+  /* Extract a uri path if available */
+  const char *path_start = NULL;
+  const char *query_start = NULL;
+
+  path_start = memchr(address, '/', len);
+  if (path_start) {
+    query_start = memchr((address + (path_start - address)), '?', (len - (path_start - address)));
+    if (query_start) {
+      oc_new_string(path, path_start, (query_start - path_start));
+    } else {
+      oc_new_string(path, path_start, (len - (path_start - address)));
+    }
+  } else {
+    // no path found return an empty string
+    oc_new_string(path, "", 0);
+  }
+  return 0;
+}
+
 int
 oc_ipv6_endpoint_is_link_local(oc_endpoint_t *endpoint)
 {
diff --git a/api/unittest/eptest.cpp b/api/unittest/eptest.cpp
index f078420c..19365ea7 100644
--- a/api/unittest/eptest.cpp
+++ b/api/unittest/eptest.cpp
@@ -21,46 +21,66 @@
 
 TEST(OCEndpoints, StringToEndpoint)
 {
-  const char *spu[4] = { "coaps://10.211.55.3:56789/a/light",
-                          "coap://openconnectivity.org",
-                          "coap://openconnectivity.org/alpha",
-                          "coaps://openconnectivity.org:3456/alpha" };
-  for (int i = 0; i < 4; i++) {
+#ifdef OC_IPV4
+  const char *spu0[1] = { "coaps://10.211.55.3:56789/a/light" };
+    for (int i = 0; i < 1; i++) {
+      oc_string_t s;
+      oc_new_string(&s, spu0[i], strlen(spu0[i]));
+      oc_endpoint_t ep;
+      memset(&ep, 0, sizeof(oc_endpoint_t));
+      oc_string_t uri;
+      memset(&uri, 0, sizeof(oc_string_t));
+
+      int ret = oc_string_to_endpoint(&s, &ep, &uri);
+      EXPECT_EQ(ret, 0) << "spu0[" << i << "] " << spu0[i];
+
+      switch (i) {
+      case 0: {
+        EXPECT_TRUE(ep.flags & IPV4);
+        EXPECT_TRUE(ep.flags & SECURED);
+        EXPECT_FALSE(ep.flags & TCP);
+        EXPECT_EQ(ep.addr.ipv4.port, 56789);
+        EXPECT_STREQ(oc_string(uri), "/a/light");
+        uint8_t addr[4] = { 10, 211, 55, 3 };
+        EXPECT_EQ(0, memcmp(ep.addr.ipv4.address, addr, 4));
+      } break;
+      default:
+        break;
+      }
+      oc_free_string(&s);
+      oc_free_string(&uri);
+    }
+#endif /* OC_IPV4 */
+  const char *spu1[3] = { "coap://openconnectivity.org",
+                         "coap://openconnectivity.org/alpha",
+                         "coaps://openconnectivity.org:3456/alpha" };
+  for (int i = 0; i < 3; i++) {
     oc_string_t s;
-    oc_new_string(&s, spu[i], strlen(spu[i]));
+    oc_new_string(&s, spu1[i], strlen(spu1[i]));
     oc_endpoint_t ep;
     memset(&ep, 0, sizeof(oc_endpoint_t));
     oc_string_t uri;
     memset(&uri, 0, sizeof(oc_string_t));
 
     int ret = oc_string_to_endpoint(&s, &ep, &uri);
-    EXPECT_EQ(ret, 0) << "spu[" << i << "] " << spu[i];
+    EXPECT_EQ(ret, 0) << "spu1[" << i << "] " << spu1[i];
 
     switch (i) {
-    case 0: {
-      EXPECT_TRUE(ep.flags & IPV4);
-      EXPECT_TRUE(ep.flags & SECURED);
-      EXPECT_FALSE(ep.flags & TCP);
-      EXPECT_EQ(ep.addr.ipv4.port, 56789);
-      EXPECT_STREQ(oc_string(uri), "/a/light");
-      uint8_t addr[4] = { 10, 211, 55, 3 };
-      EXPECT_EQ(0, memcmp(ep.addr.ipv4.address, addr, 4));
-    } break;
-    case 1:
+    case 0:
       ASSERT_TRUE((ep.flags & IPV4) || (ep.flags & IPV6));
       ASSERT_FALSE(ep.flags & SECURED);
       ASSERT_FALSE(ep.flags & TCP);
       EXPECT_EQ(ep.addr.ipv4.port, 5683);
       EXPECT_EQ(oc_string_len(uri), 0);
       break;
-    case 2:
+    case 1:
       ASSERT_TRUE((ep.flags & IPV4) || (ep.flags & IPV6));
       ASSERT_FALSE(ep.flags & SECURED);
       ASSERT_FALSE(ep.flags & TCP);
       EXPECT_EQ(ep.addr.ipv4.port, 5683);
       EXPECT_STREQ(oc_string(uri), "/alpha");
       break;
-    case 3:
+    case 2:
       ASSERT_TRUE((ep.flags & IPV4) || (ep.flags & IPV6));
       ASSERT_TRUE(ep.flags & SECURED);
       ASSERT_FALSE(ep.flags & TCP);
@@ -75,50 +95,70 @@ TEST(OCEndpoints, StringToEndpoint)
   }
 
 #ifdef OC_TCP
-    const char *spu2[6] = { "coaps+tcp://10.211.55.3/a/light",
-                            "coap+tcp://1.2.3.4:2568",
-                            "coaps+tcp://openconnectivity.org:3456",
+#ifdef OC_IPV4
+  const char *spu2[2] = { "coaps+tcp://10.211.55.3/a/light",
+                          "coap+tcp://1.2.3.4:2568"};
+      for (int i = 0; i < 2; i++) {
+        oc_string_t s;
+        oc_new_string(&s, spu2[i], strlen(spu2[i]));
+        oc_endpoint_t ep;
+        memset(&ep, 0, sizeof(oc_endpoint_t));
+        oc_string_t uri;
+        memset(&uri, 0, sizeof(oc_string_t));
+
+        int ret = oc_string_to_endpoint(&s, &ep, &uri);
+        EXPECT_EQ(ret, 0) << "spu2[" << i << "] " << spu2[i];
+
+        switch (i) {
+        case 0: {
+          EXPECT_TRUE(ep.flags & IPV4);
+          EXPECT_TRUE(ep.flags & SECURED);
+          EXPECT_TRUE(ep.flags & TCP);
+          EXPECT_EQ(ep.addr.ipv4.port, 5684);
+          EXPECT_STREQ(oc_string(uri), "/a/light");
+          uint8_t addr[4] = { 10, 211, 55, 3 };
+          EXPECT_EQ(0, memcmp(ep.addr.ipv4.address, addr, 4));
+        } break;
+        case 1: {
+          EXPECT_TRUE(ep.flags & IPV4);
+          EXPECT_FALSE(ep.flags & SECURED);
+          EXPECT_TRUE(ep.flags & TCP);
+          EXPECT_EQ(ep.addr.ipv4.port, 2568);
+          EXPECT_EQ(oc_string_len(uri), 0);
+          uint8_t addr[4] = { 1, 2, 3, 4 };
+          EXPECT_EQ(0, memcmp(ep.addr.ipv4.address, addr, 4));
+        } break;
+        default:
+          break;
+        }
+        oc_free_string(&s);
+        oc_free_string(&uri);
+      }
+#endif /* OC_IPV4 */
+    const char *spu3[4] = { "coaps+tcp://openconnectivity.org:3456",
                             "coap+tcp://[ff02::158]",
                             "coaps+tcp://[ff02::158]/a/light",
                             "coaps+tcp://[fe80::12]:2439/a/light" };
-    for (int i = 0; i < 6; i++) {
+    for (int i = 0; i < 4; i++) {
       oc_string_t s;
-      oc_new_string(&s, spu2[i], strlen(spu2[i]));
+      oc_new_string(&s, spu3[i], strlen(spu3[i]));
       oc_endpoint_t ep;
       memset(&ep, 0, sizeof(oc_endpoint_t));
       oc_string_t uri;
       memset(&uri, 0, sizeof(oc_string_t));
 
       int ret = oc_string_to_endpoint(&s, &ep, &uri);
-      EXPECT_EQ(ret, 0) << "spu2[" << i << "] " << spu2[i];
+      EXPECT_EQ(ret, 0) << "spu3[" << i << "] " << spu3[i];
 
       switch (i) {
-      case 0: {
-        EXPECT_TRUE(ep.flags & IPV4);
-        EXPECT_TRUE(ep.flags & SECURED);
-        EXPECT_TRUE(ep.flags & TCP);
-        EXPECT_EQ(ep.addr.ipv4.port, 5684);
-        EXPECT_STREQ(oc_string(uri), "/a/light");
-        uint8_t addr[4] = { 10, 211, 55, 3 };
-        EXPECT_EQ(0, memcmp(ep.addr.ipv4.address, addr, 4));
-      } break;
-      case 1: {
-        EXPECT_TRUE(ep.flags & IPV4);
-        EXPECT_FALSE(ep.flags & SECURED);
-        EXPECT_TRUE(ep.flags & TCP);
-        EXPECT_EQ(ep.addr.ipv4.port, 2568);
-        EXPECT_EQ(oc_string_len(uri), 0);
-        uint8_t addr[4] = { 1, 2, 3, 4 };
-        EXPECT_EQ(0, memcmp(ep.addr.ipv4.address, addr, 4));
-      } break;
-      case 2:
+      case 0:
         ASSERT_TRUE((ep.flags & IPV4) || (ep.flags & IPV6));
         ASSERT_TRUE(ep.flags & SECURED);
         ASSERT_TRUE(ep.flags & TCP);
         EXPECT_EQ(ep.addr.ipv4.port, 3456);
         EXPECT_EQ(oc_string_len(uri), 0);
         break;
-      case 3: {
+      case 1: {
         ASSERT_TRUE(ep.flags & IPV6);
         ASSERT_FALSE(ep.flags & SECURED);
         ASSERT_TRUE(ep.flags & TCP);
@@ -128,7 +168,7 @@ TEST(OCEndpoints, StringToEndpoint)
                              0,    0,    0, 0, 0, 0, 0x01, 0x58 };
         EXPECT_EQ(0, memcmp(ep.addr.ipv6.address, addr, 16));
       } break;
-      case 4: {
+      case 2: {
         ASSERT_TRUE(ep.flags & IPV6);
         ASSERT_TRUE(ep.flags & SECURED);
         ASSERT_TRUE(ep.flags & TCP);
@@ -138,7 +178,7 @@ TEST(OCEndpoints, StringToEndpoint)
         EXPECT_EQ(0, memcmp(ep.addr.ipv6.address, addr, 16));
         EXPECT_STREQ(oc_string(uri), "/a/light");
       } break;
-      case 5: {
+      case 3: {
         ASSERT_TRUE(ep.flags & IPV6);
         ASSERT_TRUE(ep.flags & SECURED);
         ASSERT_TRUE(ep.flags & TCP);
@@ -156,3 +196,103 @@ TEST(OCEndpoints, StringToEndpoint)
     }
 #endif
 }
+
+TEST(OCEndpoints, EndpointStringParsePath)
+{
+  const char *spu[12] = { "coaps://10.211.55.3:56789/a/light",
+                         "coap://openconnectivity.org",
+                         "coap://openconnectivity.org/alpha",
+                         "coaps://openconnectivity.org:3456/alpha",
+                         "coaps+tcp://10.211.55.3/a/light",
+                         "coap+tcp://1.2.3.4:2568",
+                         "coaps+tcp://openconnectivity.org:3456",
+                         "coap+tcp://[ff02::158]",
+                         "coaps+tcp://[ff02::158]/a/light",
+                         "coaps+tcp://[fe80::12]:2439/a/light",
+                         "coaps+tcp://[fe80::12]:2439/a/light?s=100",
+                         "coap://0/foo"};
+  for (int i = 0; i < 12; i++) {
+    oc_string_t s;
+    oc_new_string(&s, spu[i], strlen(spu[i]));
+    oc_string_t path;
+    memset(&path, 0, sizeof(oc_string_t));
+
+    int ret = oc_endpoint_string_parse_path(&s, &path);
+    EXPECT_EQ(0, ret) << "spu[" << i << "] " << spu[i];
+    switch (i) {
+    case 0:
+      EXPECT_STREQ(oc_string(path), "/a/light");
+      break;
+    case 1:
+      EXPECT_EQ(oc_string_len(path), 0);
+      EXPECT_STREQ(oc_string(path), "");
+      break;
+    case 2:
+      EXPECT_STREQ(oc_string(path), "/alpha");
+      break;
+    case 3:
+      EXPECT_STREQ(oc_string(path), "/alpha");
+      break;
+    case 4:
+      EXPECT_STREQ(oc_string(path), "/a/light");
+      break;
+    case 5:
+      EXPECT_EQ(oc_string_len(path), 0);
+      EXPECT_STREQ(oc_string(path), "");
+      break;
+    case 6:
+      EXPECT_EQ(oc_string_len(path), 0);
+      EXPECT_STREQ(oc_string(path), "");
+      break;
+    case 7:
+      EXPECT_EQ(oc_string_len(path), 0);
+      EXPECT_STREQ(oc_string(path), "");
+      break;
+    case 8:
+      EXPECT_STREQ(oc_string(path), "/a/light");
+      break;
+    case 9:
+      EXPECT_STREQ(oc_string(path), "/a/light");
+      break;
+    case 10:
+      EXPECT_STREQ(oc_string(path), "/a/light");
+      break;
+    case 11:
+      EXPECT_STREQ(oc_string(path), "/foo");
+      break;
+    default:
+      break;
+    }
+
+
+  }
+
+  // paths with expected errors
+  const char *spu2[2] = { "coaps://", // no address
+                          "coaps:/10.211.55.3:56789/a/light" // missing ://
+  };
+  for (int i = 0; i < 2; i++) {
+    oc_string_t s;
+    oc_new_string(&s, spu2[i], strlen(spu2[i]));
+    oc_string_t path;
+    memset(&path, 0, sizeof(oc_string_t));
+
+    int ret = oc_endpoint_string_parse_path(&s, &path);
+    EXPECT_EQ(-1, ret) << "spu2[" << i << "] " << spu2[i];
+
+    oc_free_string(&s);
+    oc_free_string(&path);
+  }
+  {
+    oc_string_t path;
+    EXPECT_EQ(-1, oc_endpoint_string_parse_path(NULL, &path));
+    oc_free_string(&path);
+  }
+  {
+    oc_string_t s;
+    oc_new_string(&s, "coap://0/p", strlen("coap://0/p"));
+    EXPECT_EQ(-1, oc_endpoint_string_parse_path(&s, NULL));
+    oc_free_string(&s);
+  }
+
+}
diff --git a/include/oc_endpoint.h b/include/oc_endpoint.h
index c242e203..3ee52917 100644
--- a/include/oc_endpoint.h
+++ b/include/oc_endpoint.h
@@ -91,6 +91,7 @@ void oc_endpoint_set_di(oc_endpoint_t *endpoint, oc_uuid_t *di);
 int oc_endpoint_to_string(oc_endpoint_t *endpoint, oc_string_t *endpoint_str);
 int oc_string_to_endpoint(oc_string_t *endpoint_str, oc_endpoint_t *endpoint,
                           oc_string_t *uri);
+int oc_endpoint_string_parse_path(oc_string_t *endpoint_str, oc_string_t *path);
 int oc_ipv6_endpoint_is_link_local(oc_endpoint_t *endpoint);
 int oc_endpoint_compare(const oc_endpoint_t *ep1, const oc_endpoint_t *ep2);
 int oc_endpoint_compare_address(oc_endpoint_t *ep1, oc_endpoint_t *ep2);
-- 
2.16.1.windows.1

