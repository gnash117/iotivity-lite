From eebf8d5fef236fc6e2d619a5fa6f91bc764e171d Mon Sep 17 00:00:00 2001
From: sachinsk <sachin@graniteriverlabs.in>
Date: Fri, 5 Apr 2019 19:13:42 +0530
Subject: [PATCH] CertificationApp

- CertApp stabilised for running client test cases
- Related improvements in device_builder_server.c,
  server_introspection.dat.h, tafagent.c and tafagent.h

Change-Id: Iedec3ff00ec85e7353911dc609415c7c46521ed8
Signed-off-by: sachinsk <sachin@graniteriverlabs.in>
---
 apps/Certification.h                          |  359 +++
 apps/CertificationApp.c                       | 3044 +++++++++++++++++++++++++
 apps/CertificationApp.json                    |   32 +
 apps/CertificationApp_Example.json            |   22 +
 apps/device_builder_server.c                  | 1354 +++++++++++
 apps/discover_device.c                        |  181 ++
 include/server_introspection.dat.h            |  849 +++++--
 port/linux/Makefile                           |   15 +-
 tests/automation/ctt/Makefile                 |    3 +
 tests/automation/ctt/README.rst               |   86 +
 tests/automation/ctt/client_config.txt        |  131 ++
 tests/automation/ctt/include/DUTController.h  |   49 +
 tests/automation/ctt/include/MiniHttpServer.h |   41 +
 tests/automation/ctt/include/ResourceMap.h    |   59 +
 tests/automation/ctt/include/TAFAgent.h       |  122 +
 tests/automation/ctt/run_taf_agent.sh         |   31 +
 tests/automation/ctt/server_config.txt        |  146 ++
 tests/automation/ctt/src/DUTController.c      |  262 +++
 tests/automation/ctt/src/MiniHttpServer.c     |  751 ++++++
 tests/automation/ctt/src/ResourceMap.c        |   87 +
 tests/automation/ctt/src/TAFAgent.c           |  792 +++++++
 21 files changed, 8179 insertions(+), 237 deletions(-)
 create mode 100644 apps/Certification.h
 create mode 100644 apps/CertificationApp.c
 create mode 100644 apps/CertificationApp.json
 create mode 100644 apps/CertificationApp_Example.json
 create mode 100644 apps/device_builder_server.c
 create mode 100644 apps/discover_device.c
 create mode 100644 tests/automation/ctt/Makefile
 create mode 100644 tests/automation/ctt/README.rst
 create mode 100644 tests/automation/ctt/client_config.txt
 create mode 100755 tests/automation/ctt/include/DUTController.h
 create mode 100755 tests/automation/ctt/include/MiniHttpServer.h
 create mode 100755 tests/automation/ctt/include/ResourceMap.h
 create mode 100644 tests/automation/ctt/include/TAFAgent.h
 create mode 100755 tests/automation/ctt/run_taf_agent.sh
 create mode 100644 tests/automation/ctt/server_config.txt
 create mode 100755 tests/automation/ctt/src/DUTController.c
 create mode 100755 tests/automation/ctt/src/MiniHttpServer.c
 create mode 100755 tests/automation/ctt/src/ResourceMap.c
 create mode 100644 tests/automation/ctt/src/TAFAgent.c

diff --git a/apps/Certification.h b/apps/Certification.h
new file mode 100644
index 00000000..e6f7511d
--- /dev/null
+++ b/apps/Certification.h
@@ -0,0 +1,359 @@
+/******************************************************************
+ *
+ * Copyright 2018 GRANITE RIVER LABS All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+#define RESOURCE_NAME "lightbulb"
+#define RESOURCE_URI "/light/"
+#define NUM_RESOURCES_TYPES 1
+#define Device_TYPE_LIGHT "oic.d.light"
+#define RESOURCE_LIGHT_TYPE "core.r.light"
+#define MAX_LIGHT_RESOURCE_COUNT 100
+#define NUM_DEVICE 1
+#define MAX_STRING 65
+#define LIGHT_INVISIBLE_URI "/device/light-invisible"
+#define SWITCH_RESOURCE_TYPE "oic.r.switch.binary"
+#define LIGHT_COUNT 2
+#define OCF_SPEC_VERSION "ocf.2.0.5"
+#define OCF_DATA_MODEL_VERSION "ocf.res.1.3.0, ocf.sh.1.3.0"
+#define RESOURCE_1_URI "/binaryswitch"
+#define RESOURCE_2_URI "/humidity"
+#define RESOURCE_AIR_URI "/AC-binaryswitch"
+#define AIR_CON_DEVICE_URI "oic/d"
+#define MAX_URI_LENGTH (30)
+#define ENGLISH_NAME_VALUE "x.vendor.rt.airconditioner"
+#define OBSERVE_PERIODIC 1
+#define RESOURCE_INTERFACE 2
+#define DEVICE_COUNT 0
+#define CANCEL_SELECTION 0
+#define PING_RETRY_COUNT (4)
+
+typedef struct oc_discoverResource_t
+{
+  struct oc_discoverResource_t *next;
+  oc_endpoint_t *endpoint;
+  char uri[64];
+} oc_discoverResource_t;
+
+const int CALLBACK_WAIT_MIN = 1;
+const int CALLBACK_WAIT_MAX = 5;
+
+static char g_binaryswitch_AIRCON_RESOURCE_INTERFACE[][MAX_STRING] = {"oic.if.a","oic.if.baseline"};
+
+#define PRINTport(endpoint)                                                   \
+  do {                                                                         \
+    if ((endpoint).flags & IPV4) {                                             \
+      PRINT("%d",             \
+             (endpoint).addr.ipv4.port);     \
+    } else {                                                                   \
+      PRINT(                                                                   \
+        "%d",                                                             \
+         (endpoint).addr.ipv6.port);        \
+    }                                                                          \
+} while(0)
+
+#define PRINTIPaddr(endpoint)                                                  \
+  do {                                                                         \
+    if ((endpoint).flags & IPV4) {                                             \
+      PRINT("%d.%d.%d.%d", ((endpoint).addr.ipv4.address)[0],             \
+            ((endpoint).addr.ipv4.address)[1],                                 \
+            ((endpoint).addr.ipv4.address)[2],                                 \
+            ((endpoint).addr.ipv4.address)[3]);     \
+    } else {                                                                   \
+      PRINT(                                                                   \
+        "%02x%02x::%02x%02x:%02x%02x:%02x%02x:%"    \
+        "02x%"                                                                 \
+        "02x",                                                                 \
+        ((endpoint).addr.ipv6.address)[0], ((endpoint).addr.ipv6.address)[1],  \
+        ((endpoint).addr.ipv6.address)[8], ((endpoint).addr.ipv6.address)[9],  \
+        ((endpoint).addr.ipv6.address)[10],                                    \
+        ((endpoint).addr.ipv6.address)[11],                                    \
+        ((endpoint).addr.ipv6.address)[12],                                    \
+        ((endpoint).addr.ipv6.address)[13],                                    \
+        ((endpoint).addr.ipv6.address)[14],                                    \
+        ((endpoint).addr.ipv6.address)[15]);                                   \
+    }                                                                          \
+} while(0)
+
+extern int quit;
+pthread_mutex_t mutex;
+pthread_cond_t cv;
+struct timespec ts;
+
+extern void register_resources();
+extern int app_init(void);
+extern void signal_event_loop();
+extern void handle_signal();
+extern int convert_if_string(char *);
+static void createResource();
+static void createInvisibleResource();
+static void createResourceWithUrl();
+static void createManyLightResources();
+static oc_collection_t* createGroupResource();
+static void deleteAllResources();
+static void deleteCreatedGroup();
+static void sendPOSTRequest_partialUpdate_userInput();
+static void sendPOSTRequest_partialUpdate_userInput_auto_Bin();
+static void sendPOSTRequest_partialUpdate_userInput_auto_Hum();
+void SendData(char *cmd);
+static void findGroup(char *);
+static oc_collection_t* updateGroup();
+static void updateLocalResourceManually();
+static void createSingleAirConResource();
+static void handleMenu();
+static void selectMenu(int);
+static int app_init1();
+static void discoverDevice(bool);
+static void discoverPlatform(bool);
+static void findAllResources();
+static void discoverIntrospection();
+static void sendGetRequest();
+static void sendPutRequestUpdate(void);
+static void sendPostRequestUpdate();
+static void findResource_UserResType(char *);
+static void observe_request();
+static void stop_observe();
+static int selectResource();
+static void waitForCallback();
+static void get_platform(oc_client_response_t *data);
+static void get_device(oc_client_response_t *data);
+static void printEndpointsList();
+#ifdef OC_TCP
+static void sendPingMessage(uint16_t timeout_seconds);
+#endif
+
+#define ASSERT(expr) \
+    do { \
+        if ((!(expr))) { \
+            fprintf(stderr, "%s:%d: %s: Assertion: `" # expr "' failed.\n", \
+                __FILE__, __LINE__, __func__); \
+            exit(1); \
+        } \
+    } while (0)
+
+  const unsigned char my_crt[] = {
+    0x30, 0x82, 0x03, 0xf8, 0x30, 0x82, 0x03, 0x9e, 0xa0, 0x03, 0x02, 0x01,
+    0x02, 0x02, 0x09, 0x00, 0x8d, 0x0a, 0xfb, 0x7b, 0x53, 0xb2, 0x4c, 0xb6,
+    0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02,
+    0x30, 0x5b, 0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c,
+    0x03, 0x4f, 0x43, 0x46, 0x31, 0x22, 0x30, 0x20, 0x06, 0x03, 0x55, 0x04,
+    0x0b, 0x0c, 0x19, 0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x65, 0x73,
+    0x74, 0x20, 0x49, 0x6e, 0x66, 0x72, 0x61, 0x73, 0x74, 0x72, 0x75, 0x63,
+    0x74, 0x75, 0x72, 0x65, 0x31, 0x27, 0x30, 0x25, 0x06, 0x03, 0x55, 0x04,
+    0x03, 0x0c, 0x1e, 0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x45, 0x53,
+    0x54, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6d, 0x65, 0x64, 0x69, 0x61,
+    0x74, 0x65, 0x20, 0x43, 0x41, 0x30, 0x30, 0x30, 0x32, 0x30, 0x1e, 0x17,
+    0x0d, 0x31, 0x38, 0x31, 0x32, 0x31, 0x33, 0x31, 0x33, 0x33, 0x36, 0x33,
+    0x30, 0x5a, 0x17, 0x0d, 0x31, 0x39, 0x30, 0x36, 0x31, 0x31, 0x31, 0x33,
+    0x33, 0x36, 0x33, 0x30, 0x5a, 0x30, 0x61, 0x31, 0x0c, 0x30, 0x0a, 0x06,
+    0x03, 0x55, 0x04, 0x0a, 0x0c, 0x03, 0x4f, 0x43, 0x46, 0x31, 0x22, 0x30,
+    0x20, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x19, 0x4b, 0x79, 0x72, 0x69,
+    0x6f, 0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x49, 0x6e, 0x66, 0x72, 0x61,
+    0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x31, 0x2d, 0x30,
+    0x2b, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x24, 0x39, 0x39, 0x30, 0x30,
+    0x30, 0x30, 0x31, 0x30, 0x2d, 0x31, 0x31, 0x31, 0x31, 0x2d, 0x31, 0x31,
+    0x31, 0x31, 0x2d, 0x31, 0x31, 0x31, 0x31, 0x2d, 0x31, 0x31, 0x31, 0x31,
+    0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x59, 0x30, 0x13,
+    0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a,
+    0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0xe4,
+    0xbf, 0xcf, 0x9a, 0x29, 0x2d, 0x91, 0x54, 0x4b, 0x6d, 0x2c, 0x67, 0x38,
+    0x7b, 0xe8, 0x7c, 0x58, 0x96, 0x60, 0x40, 0xc7, 0x72, 0xc2, 0x41, 0xb7,
+    0x6f, 0xa6, 0x1a, 0x09, 0xe8, 0x85, 0x96, 0xad, 0x02, 0x4c, 0x95, 0xbf,
+    0x67, 0x75, 0x24, 0x88, 0x98, 0x3c, 0x2a, 0x9a, 0xdb, 0x95, 0x96, 0x62,
+    0x74, 0xce, 0x2d, 0x79, 0xe8, 0x30, 0xfa, 0x4c, 0x4a, 0x97, 0x5e, 0xaf,
+    0xb9, 0xb3, 0x5c, 0xa3, 0x82, 0x02, 0x43, 0x30, 0x82, 0x02, 0x3f, 0x30,
+    0x09, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04, 0x02, 0x30, 0x00, 0x30, 0x0e,
+    0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02,
+    0x03, 0x88, 0x30, 0x29, 0x06, 0x03, 0x55, 0x1d, 0x25, 0x04, 0x22, 0x30,
+    0x20, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x02, 0x06,
+    0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x01, 0x06, 0x0a, 0x2b,
+    0x06, 0x01, 0x04, 0x01, 0x82, 0xde, 0x7c, 0x01, 0x06, 0x30, 0x1d, 0x06,
+    0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x46, 0x93, 0xfa, 0xa7,
+    0x95, 0xbf, 0xbb, 0x0d, 0x1c, 0x38, 0xc4, 0xce, 0xe7, 0x49, 0x33, 0x16,
+    0xe8, 0x59, 0xe9, 0xbe, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04,
+    0x18, 0x30, 0x16, 0x80, 0x14, 0x19, 0x73, 0x6a, 0x04, 0x1a, 0x0b, 0x07,
+    0x70, 0x4f, 0x53, 0x79, 0x53, 0x36, 0x87, 0xfc, 0x0c, 0xba, 0x7c, 0xae,
+    0x0b, 0x30, 0x81, 0x96, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07,
+    0x01, 0x01, 0x04, 0x81, 0x89, 0x30, 0x81, 0x86, 0x30, 0x5d, 0x06, 0x08,
+    0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x51, 0x68, 0x74,
+    0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x70, 0x6b, 0x69,
+    0x2e, 0x6b, 0x79, 0x72, 0x69, 0x6f, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6f,
+    0x63, 0x66, 0x2f, 0x63, 0x61, 0x63, 0x65, 0x72, 0x74, 0x73, 0x2f, 0x42,
+    0x42, 0x45, 0x36, 0x34, 0x46, 0x39, 0x41, 0x37, 0x45, 0x45, 0x33, 0x37,
+    0x44, 0x32, 0x39, 0x41, 0x30, 0x35, 0x45, 0x34, 0x42, 0x42, 0x37, 0x37,
+    0x35, 0x39, 0x35, 0x46, 0x33, 0x30, 0x38, 0x42, 0x45, 0x34, 0x31, 0x45,
+    0x42, 0x30, 0x37, 0x2e, 0x63, 0x72, 0x74, 0x30, 0x25, 0x06, 0x08, 0x2b,
+    0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x19, 0x68, 0x74, 0x74,
+    0x70, 0x3a, 0x2f, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x6f, 0x63, 0x73, 0x70,
+    0x2e, 0x6b, 0x79, 0x72, 0x69, 0x6f, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x5f,
+    0x06, 0x03, 0x55, 0x1d, 0x1f, 0x04, 0x58, 0x30, 0x56, 0x30, 0x54, 0xa0,
+    0x52, 0xa0, 0x50, 0x86, 0x4e, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f,
+    0x74, 0x65, 0x73, 0x74, 0x70, 0x6b, 0x69, 0x2e, 0x6b, 0x79, 0x72, 0x69,
+    0x6f, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6f, 0x63, 0x66, 0x2f, 0x63, 0x72,
+    0x6c, 0x73, 0x2f, 0x42, 0x42, 0x45, 0x36, 0x34, 0x46, 0x39, 0x41, 0x37,
+    0x45, 0x45, 0x33, 0x37, 0x44, 0x32, 0x39, 0x41, 0x30, 0x35, 0x45, 0x34,
+    0x42, 0x42, 0x37, 0x37, 0x35, 0x39, 0x35, 0x46, 0x33, 0x30, 0x38, 0x42,
+    0x45, 0x34, 0x31, 0x45, 0x42, 0x30, 0x37, 0x2e, 0x63, 0x72, 0x6c, 0x30,
+    0x5f, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x83, 0x91, 0x56, 0x01,
+    0x00, 0x04, 0x51, 0x30, 0x4f, 0x30, 0x09, 0x02, 0x01, 0x02, 0x02, 0x01,
+    0x00, 0x02, 0x01, 0x00, 0x30, 0x36, 0x0c, 0x19, 0x31, 0x2e, 0x33, 0x2e,
+    0x36, 0x2e, 0x31, 0x2e, 0x34, 0x2e, 0x31, 0x2e, 0x35, 0x31, 0x34, 0x31,
+    0x34, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x31, 0x2e, 0x30, 0x0c, 0x19, 0x31,
+    0x2e, 0x33, 0x2e, 0x36, 0x2e, 0x31, 0x2e, 0x34, 0x2e, 0x31, 0x2e, 0x35,
+    0x31, 0x34, 0x31, 0x34, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x32, 0x2e, 0x30,
+    0x0c, 0x03, 0x43, 0x54, 0x54, 0x0c, 0x05, 0x49, 0x6e, 0x74, 0x65, 0x6c,
+    0x30, 0x2a, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x83, 0x91, 0x56,
+    0x01, 0x01, 0x04, 0x1c, 0x30, 0x1a, 0x06, 0x0b, 0x2b, 0x06, 0x01, 0x04,
+    0x01, 0x83, 0x91, 0x56, 0x01, 0x01, 0x00, 0x06, 0x0b, 0x2b, 0x06, 0x01,
+    0x04, 0x01, 0x83, 0x91, 0x56, 0x01, 0x01, 0x01, 0x30, 0x30, 0x06, 0x0a,
+    0x2b, 0x06, 0x01, 0x04, 0x01, 0x83, 0x91, 0x56, 0x01, 0x02, 0x04, 0x22,
+    0x30, 0x20, 0x0c, 0x0e, 0x31, 0x2e, 0x33, 0x2e, 0x36, 0x2e, 0x31, 0x2e,
+    0x34, 0x2e, 0x31, 0x2e, 0x37, 0x31, 0x0c, 0x09, 0x44, 0x69, 0x73, 0x63,
+    0x6f, 0x76, 0x65, 0x72, 0x79, 0x0c, 0x03, 0x31, 0x2e, 0x30, 0x30, 0x0a,
+    0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x03, 0x48,
+    0x00, 0x30, 0x45, 0x02, 0x20, 0x21, 0xac, 0x87, 0x42, 0x81, 0x04, 0x85,
+    0x2f, 0x99, 0x38, 0xd1, 0xfb, 0x1f, 0x9c, 0x2e, 0xa7, 0x56, 0xca, 0x58,
+    0xb5, 0x89, 0xd4, 0x02, 0x7f, 0x2f, 0x6a, 0x63, 0x91, 0x4e, 0xdf, 0xe8,
+    0x5e, 0x02, 0x21, 0x00, 0xd7, 0x0c, 0xc3, 0x66, 0x90, 0xc2, 0x7f, 0xa7,
+    0x27, 0x97, 0xc1, 0x0a, 0x24, 0x1b, 0xdc, 0xb8, 0xd4, 0x48, 0xc1, 0xb6,
+    0x8f, 0xce, 0xaa, 0x82, 0x0f, 0xb0, 0x3a, 0xd7, 0x41, 0x06, 0x6e, 0x1d
+  };
+
+  unsigned char my_key[] = {
+    0x30, 0x77, 0x02, 0x01, 0x01, 0x04, 0x20, 0x34, 0x23, 0xa2, 0xf0,
+    0x44, 0x8a, 0xe4, 0x4c, 0x8b, 0x21, 0x7e, 0x4c, 0x0d, 0x68, 0x8a,
+    0xdc, 0xea, 0x5e, 0xcf, 0xb8, 0x60, 0x0a, 0x97, 0xe3, 0x5a, 0x78,
+    0x13, 0xfb, 0x12, 0x48, 0xad, 0x0d, 0xa0, 0x0a, 0x06, 0x08, 0x2a,
+    0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0xa1, 0x44, 0x03, 0x42,
+    0x00, 0x04, 0xe4, 0xbf, 0xcf, 0x9a, 0x29, 0x2d, 0x91, 0x54, 0x4b,
+    0x6d, 0x2c, 0x67, 0x38, 0x7b, 0xe8, 0x7c, 0x58, 0x96, 0x60, 0x40,
+    0xc7, 0x72, 0xc2, 0x41, 0xb7, 0x6f, 0xa6, 0x1a, 0x09, 0xe8, 0x85,
+    0x96, 0xad, 0x02, 0x4c, 0x95, 0xbf, 0x67, 0x75, 0x24, 0x88, 0x98,
+    0x3c, 0x2a, 0x9a, 0xdb, 0x95, 0x96, 0x62, 0x74, 0xce, 0x2d, 0x79,
+    0xe8, 0x30, 0xfa, 0x4c, 0x4a, 0x97, 0x5e, 0xaf, 0xb9, 0xb3, 0x5c
+  };
+
+  unsigned char int_ca[] = {
+    0x30, 0x82, 0x02, 0xfa, 0x30, 0x82, 0x02, 0xa1, 0xa0, 0x03, 0x02, 0x01,
+    0x02, 0x02, 0x09, 0x00, 0xf3, 0x9b, 0x8c, 0xc0, 0x57, 0x2a, 0x11, 0xb5,
+    0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02,
+    0x30, 0x53, 0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c,
+    0x03, 0x4f, 0x43, 0x46, 0x31, 0x22, 0x30, 0x20, 0x06, 0x03, 0x55, 0x04,
+    0x0b, 0x0c, 0x19, 0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x65, 0x73,
+    0x74, 0x20, 0x49, 0x6e, 0x66, 0x72, 0x61, 0x73, 0x74, 0x72, 0x75, 0x63,
+    0x74, 0x75, 0x72, 0x65, 0x31, 0x1f, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x04,
+    0x03, 0x0c, 0x16, 0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x45, 0x53,
+    0x54, 0x20, 0x52, 0x4f, 0x4f, 0x54, 0x20, 0x43, 0x41, 0x30, 0x30, 0x30,
+    0x32, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x38, 0x31, 0x31, 0x33, 0x30, 0x31,
+    0x38, 0x31, 0x32, 0x31, 0x35, 0x5a, 0x17, 0x0d, 0x32, 0x38, 0x31, 0x31,
+    0x32, 0x36, 0x31, 0x38, 0x31, 0x32, 0x31, 0x35, 0x5a, 0x30, 0x5b, 0x31,
+    0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x03, 0x4f, 0x43,
+    0x46, 0x31, 0x22, 0x30, 0x20, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x19,
+    0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x49,
+    0x6e, 0x66, 0x72, 0x61, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72,
+    0x65, 0x31, 0x27, 0x30, 0x25, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x1e,
+    0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x45, 0x53, 0x54, 0x20, 0x49,
+    0x6e, 0x74, 0x65, 0x72, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x20,
+    0x43, 0x41, 0x30, 0x30, 0x30, 0x32, 0x30, 0x59, 0x30, 0x13, 0x06, 0x07,
+    0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a, 0x86, 0x48,
+    0xce, 0x3d, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0xbc, 0x0f, 0x86,
+    0x9f, 0x7a, 0x1f, 0x46, 0x91, 0xf8, 0xd1, 0x7b, 0x95, 0xa6, 0x90, 0x51,
+    0x7f, 0xbf, 0x26, 0x0e, 0xd7, 0xdc, 0x94, 0xe9, 0x01, 0x77, 0xbf, 0xf7,
+    0xdb, 0x24, 0x1c, 0x98, 0xad, 0x8b, 0x43, 0x4c, 0x26, 0xfe, 0xec, 0xa5,
+    0xd9, 0xcc, 0x9e, 0x00, 0x13, 0xee, 0x37, 0xa3, 0x45, 0x71, 0x1f, 0x7e,
+    0x2d, 0x89, 0x17, 0x67, 0x93, 0xf8, 0x3a, 0xfc, 0xbd, 0x47, 0x8d, 0xd0,
+    0xbe, 0xa3, 0x82, 0x01, 0x54, 0x30, 0x82, 0x01, 0x50, 0x30, 0x12, 0x06,
+    0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x08, 0x30, 0x06, 0x01,
+    0x01, 0xff, 0x02, 0x01, 0x00, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f,
+    0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x1d, 0x06,
+    0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x19, 0x73, 0x6a, 0x04,
+    0x1a, 0x0b, 0x07, 0x70, 0x4f, 0x53, 0x79, 0x53, 0x36, 0x87, 0xfc, 0x0c,
+    0xba, 0x7c, 0xae, 0x0b, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04,
+    0x18, 0x30, 0x16, 0x80, 0x14, 0x28, 0x48, 0xe4, 0xe5, 0x27, 0x58, 0xd9,
+    0x08, 0xee, 0x09, 0x34, 0xe4, 0xb1, 0xbb, 0x3d, 0x59, 0x66, 0x1f, 0xc8,
+    0xf5, 0x30, 0x81, 0x8d, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07,
+    0x01, 0x01, 0x04, 0x81, 0x80, 0x30, 0x7e, 0x30, 0x55, 0x06, 0x08, 0x2b,
+    0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x49, 0x68, 0x74, 0x74,
+    0x70, 0x3a, 0x2f, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x70, 0x6b, 0x69, 0x2e,
+    0x6b, 0x79, 0x72, 0x69, 0x6f, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6f, 0x63,
+    0x66, 0x2f, 0x34, 0x45, 0x36, 0x38, 0x45, 0x33, 0x46, 0x43, 0x46, 0x30,
+    0x46, 0x32, 0x45, 0x34, 0x46, 0x38, 0x30, 0x41, 0x38, 0x44, 0x31, 0x34,
+    0x33, 0x38, 0x46, 0x36, 0x41, 0x31, 0x42, 0x41, 0x35, 0x36, 0x39, 0x35,
+    0x37, 0x31, 0x33, 0x44, 0x36, 0x33, 0x2e, 0x63, 0x72, 0x74, 0x30, 0x25,
+    0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x19,
+    0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x6f,
+    0x63, 0x73, 0x70, 0x2e, 0x6b, 0x79, 0x72, 0x69, 0x6f, 0x2e, 0x63, 0x6f,
+    0x6d, 0x30, 0x5a, 0x06, 0x03, 0x55, 0x1d, 0x1f, 0x04, 0x53, 0x30, 0x51,
+    0x30, 0x4f, 0xa0, 0x4d, 0xa0, 0x4b, 0x86, 0x49, 0x68, 0x74, 0x74, 0x70,
+    0x3a, 0x2f, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x70, 0x6b, 0x69, 0x2e, 0x6b,
+    0x79, 0x72, 0x69, 0x6f, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6f, 0x63, 0x66,
+    0x2f, 0x34, 0x45, 0x36, 0x38, 0x45, 0x33, 0x46, 0x43, 0x46, 0x30, 0x46,
+    0x32, 0x45, 0x34, 0x46, 0x38, 0x30, 0x41, 0x38, 0x44, 0x31, 0x34, 0x33,
+    0x38, 0x46, 0x36, 0x41, 0x31, 0x42, 0x41, 0x35, 0x36, 0x39, 0x35, 0x37,
+    0x31, 0x33, 0x44, 0x36, 0x33, 0x2e, 0x63, 0x72, 0x6c, 0x30, 0x0a, 0x06,
+    0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x03, 0x47, 0x00,
+    0x30, 0x44, 0x02, 0x1f, 0x05, 0xe4, 0x45, 0x87, 0x7e, 0xbb, 0x9a, 0x4e,
+    0x3c, 0x7e, 0x78, 0xe3, 0x00, 0x66, 0x05, 0x12, 0x73, 0xfd, 0xbd, 0x23,
+    0xa6, 0x9b, 0xd4, 0x20, 0x7c, 0x7c, 0x21, 0x41, 0xf4, 0x0a, 0x2a, 0x02,
+    0x21, 0x00, 0xc2, 0xf0, 0x29, 0xcc, 0x55, 0x33, 0x82, 0xe5, 0xa2, 0x28,
+    0xa3, 0x96, 0x20, 0xe2, 0x4e, 0xc1, 0x0c, 0x33, 0x71, 0x6d, 0x14, 0x28,
+    0x3e, 0xe8, 0xd8, 0x7a, 0xcd, 0x0e, 0x4d, 0x51, 0xa0, 0x3c
+  };
+
+  unsigned char root_ca[] = {
+    0x30, 0x82, 0x01, 0xdf, 0x30, 0x82, 0x01, 0x85, 0xa0, 0x03, 0x02, 0x01,
+    0x02, 0x02, 0x09, 0x00, 0xf3, 0x9b, 0x8c, 0xc0, 0x57, 0x2a, 0x11, 0xb2,
+    0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02,
+    0x30, 0x53, 0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c,
+    0x03, 0x4f, 0x43, 0x46, 0x31, 0x22, 0x30, 0x20, 0x06, 0x03, 0x55, 0x04,
+    0x0b, 0x0c, 0x19, 0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x65, 0x73,
+    0x74, 0x20, 0x49, 0x6e, 0x66, 0x72, 0x61, 0x73, 0x74, 0x72, 0x75, 0x63,
+    0x74, 0x75, 0x72, 0x65, 0x31, 0x1f, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x04,
+    0x03, 0x0c, 0x16, 0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x45, 0x53,
+    0x54, 0x20, 0x52, 0x4f, 0x4f, 0x54, 0x20, 0x43, 0x41, 0x30, 0x30, 0x30,
+    0x32, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x38, 0x31, 0x31, 0x33, 0x30, 0x31,
+    0x37, 0x33, 0x31, 0x30, 0x35, 0x5a, 0x17, 0x0d, 0x32, 0x38, 0x31, 0x31,
+    0x32, 0x37, 0x31, 0x37, 0x33, 0x31, 0x30, 0x35, 0x5a, 0x30, 0x53, 0x31,
+    0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x03, 0x4f, 0x43,
+    0x46, 0x31, 0x22, 0x30, 0x20, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x19,
+    0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x49,
+    0x6e, 0x66, 0x72, 0x61, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72,
+    0x65, 0x31, 0x1f, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x16,
+    0x4b, 0x79, 0x72, 0x69, 0x6f, 0x20, 0x54, 0x45, 0x53, 0x54, 0x20, 0x52,
+    0x4f, 0x4f, 0x54, 0x20, 0x43, 0x41, 0x30, 0x30, 0x30, 0x32, 0x30, 0x59,
+    0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06,
+    0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00,
+    0x04, 0x6b, 0x75, 0xb1, 0x4d, 0x90, 0x85, 0x07, 0x0a, 0xfe, 0x47, 0xe5,
+    0x29, 0x21, 0x7d, 0x4c, 0x2a, 0xef, 0x29, 0xa0, 0xdc, 0x90, 0xb5, 0x9d,
+    0x66, 0x8c, 0xaf, 0x3f, 0xac, 0xf4, 0x3a, 0xba, 0x8d, 0x76, 0xd0, 0x6c,
+    0x71, 0x98, 0x15, 0x62, 0xc4, 0x87, 0x31, 0x06, 0x75, 0x47, 0x5f, 0x70,
+    0x5b, 0x1b, 0x1f, 0x96, 0xf3, 0x6b, 0xf1, 0xb3, 0x15, 0x5b, 0x52, 0xb7,
+    0x1d, 0x63, 0x24, 0xa6, 0xc8, 0xa3, 0x42, 0x30, 0x40, 0x30, 0x0f, 0x06,
+    0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x05, 0x30, 0x03, 0x01,
+    0x01, 0xff, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01, 0xff,
+    0x04, 0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d,
+    0x0e, 0x04, 0x16, 0x04, 0x14, 0x28, 0x48, 0xe4, 0xe5, 0x27, 0x58, 0xd9,
+    0x08, 0xee, 0x09, 0x34, 0xe4, 0xb1, 0xbb, 0x3d, 0x59, 0x66, 0x1f, 0xc8,
+    0xf5, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03,
+    0x02, 0x03, 0x48, 0x00, 0x30, 0x45, 0x02, 0x20, 0x25, 0x31, 0x4c, 0x20,
+    0x55, 0xe2, 0xfc, 0x77, 0x95, 0xb8, 0x8d, 0x97, 0x45, 0x27, 0x96, 0x60,
+    0x72, 0x59, 0x3b, 0x5d, 0x3e, 0xba, 0x2c, 0xd3, 0x1f, 0x1a, 0x41, 0x31,
+    0x4a, 0x35, 0x35, 0x9e, 0x02, 0x21, 0x00, 0xd3, 0xaf, 0x4e, 0x67, 0x77,
+    0xd8, 0x0d, 0x24, 0x12, 0xd2, 0x29, 0x1d, 0xb8, 0x8a, 0x03, 0xcf, 0x91,
+    0x14, 0x30, 0x8f, 0x25, 0x68, 0xcd, 0xe2, 0x5a, 0x31, 0xac, 0x10, 0xbb,
+    0xbf, 0x42, 0x44
+  };
\ No newline at end of file
diff --git a/apps/CertificationApp.c b/apps/CertificationApp.c
new file mode 100644
index 00000000..46d3d36d
--- /dev/null
+++ b/apps/CertificationApp.c
@@ -0,0 +1,3044 @@
+/******************************************************************
+ *
+ * Copyright 2018 GRANITE RIVER LABS All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+#include <stdio.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <ctype.h>
+#include "oc_api.h"
+#include "Certification.h"
+#include "oc_collection.h"
+#include "oc_rep.h"
+#include "oc_pki.h"
+#include "oc_core_res.h"
+#include "port/oc_clock.h"
+#include "rd_client.h"
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/types.h>
+#include <time.h>
+#ifdef OC_CLIENT
+#include "oc_client_state.h"
+#endif
+
+OC_LIST(discoverResource);
+OC_MEMB(discoverResource_m, oc_discoverResource_t, MAX_NUM_RES);
+
+static bool g_addInvisibleResource = false;
+static bool g_isTempResourceCreated = false;
+static bool g_isManyLightCreated = false;
+static bool g_isInvisibleResourceCreated = false;
+static bool g_createResourceWithURL = false;
+static bool g_isAirConDeviceCreated = false;
+static bool g_binaryswitch_valuecb = false;
+static char postRequestUri[MAX_URI_LENGTH];
+static oc_endpoint_t *postRequestEndpoint = NULL;
+static char observeUri[MAX_URI_LENGTH];
+static oc_endpoint_t *observeEndpoint = NULL;
+static char putRequestUri[MAX_URI_LENGTH];
+static oc_endpoint_t *putRequestEndpoint = NULL;
+static bool light_state = false;
+
+static char g_binaryswitch_RESOURCE_PROPERTY_NAME_value[] = "value";
+static char *UserResourceType_input = NULL;
+static char a_light[MAX_URI_LENGTH];
+static oc_endpoint_t set_ep;
+
+#ifdef OC_TCP
+#define OC_IPV6_ADDRSTRLEN (66)
+static char address[OC_IPV6_ADDRSTRLEN + 8];
+#endif
+#if defined(OC_SECURITY) && defined(OC_PKI)
+static int g_securityType;
+#endif
+
+static bool discoverDev = false;
+static bool discoverDeviceInfo = false;
+static bool discoverPlatformInfo = false;
+static bool g_hasCallbackArrived = false;
+#ifdef OC_TCP
+static size_t ping_count = 0;
+static uint16_t ping_timeout = 1;
+#endif
+static oc_string_t name;
+static bool state;
+static int power;
+static int inChoice  = 0;
+char globalBuffer[1025];
+char temp[1025];
+int gChoiceInt;
+int bufferUpdated;
+
+static oc_endpoint_t *light_server;
+static oc_collection_t *collectionPointer;
+static oc_qos_t g_qos = LOW_QOS;
+static unsigned int uri_size = 25;
+pthread_mutex_t mutex;
+pthread_mutex_t app_mutex;
+
+
+enum run_mode{ MANUAL=0, AUTO };
+enum run_mode RUN_MODE;
+
+/*It display the available options */
+void
+showMenu(int argc, char *argv[]){
+  int choice;
+  PRINT("\n###############################################################################\n");
+  printf("\n\t-----------------------------------------------------\n");
+  printf("\tPlease Select an option from the menu and press Enter\n");
+  printf("\t-----------------------------------------------------\n");
+  printf("\t\t0   : Quit Certification App\n");
+  printf("\n\tServer Operations:\n");
+  printf("\t\t1   : Create Normal Resource\n");
+  printf("\t\t2   : Create Invisible Resource\n");
+  printf("\t\t3   : Create Resource With Complete URL\n");
+  printf("\t\t4   : Create Secured Resource\n");
+  printf("\t\t5   : Create %d Light Resources\n", MAX_LIGHT_RESOURCE_COUNT);
+  printf("\t\t6   : Create Group Resource\n");
+  printf("\t\t7   : Delete All Resources\n");
+  printf("\t\t8   : Delete Created Group\n");
+  printf("\n\tClient Operations:\n");
+  printf("\t\t9   : Find Introspection\n");
+  printf("\t\t11  : Find specific type of resource\n");
+  printf("\t\t12  : Find All Resources\n");
+  printf("\t\t17  : Send GET Request\n");
+  printf("\t\t18  : Print all endpoints\n");
+  printf("\t\t20  : Send PUT Request - Complete Update\n");
+  printf("\t\t21  : Send POST Request - Partial Update - Default\n");
+  printf("\t\t22  : Send POST Request - Partial Update - User Input\n");
+  printf("\t\t25  : Observe Resource - Retrieve Request with Observe\n");
+  printf("\t\t26  : Cancel Observing Resource\n");
+  printf("\t\t28  : Discover Device - Unicast\n");
+  printf("\t\t29  : Discover Device - Multicast\n");
+  printf("\t\t30  : Discover Platform - Multicast\n");
+  printf("\t\t31  : Find Group\n");
+  printf("\t\t33  : Update Group\n");
+  printf("\t\t34  : Update Local Resource Manually\n");
+  printf("\t\t36  : Set Quality of Service - CON(Confirmable)\n");
+  printf("\t\t37  : Set Quality of Service - NON(Non-Confirmable)\n");
+  printf("\t\t40  : Send Ping Message\n");
+  printf("\t\t107 : Create Air Conditioner Single Resource\n");
+  printf("\n\tCloud Operations:\n");
+  PRINT("\t\t111 : Cloud Register\n");
+  PRINT("\t\t112 : Cloud Login\n");
+  PRINT("\t\t113 : Cloud Logout\n");
+  PRINT("\t\t114 : Cloud DeRegister\n");
+  PRINT("\t\t115 : Cloud Refresh Token\n");
+  PRINT("\t\t116 : Publish Resources\n");
+  PRINT("\t\t117 : Cloud Send Ping\n");
+  printf("\n\t\t0   : Quit Certification App\n");
+  PRINT("\n###############################################################################\n");
+  if(argc > 4){
+    for(int i = 5; i < argc; i++){
+    choice = atoi(argv[i]);
+    selectMenu(choice);
+    printf("%d",choice);
+    }
+  }
+}
+
+void
+free_buffer(oc_discoverResource_t *cb1){
+  oc_free_server_endpoints(cb1->endpoint);
+  oc_memb_free(&discoverResource_m, cb1);
+}
+
+/*To clear allocated endpoint during discovery*/
+void
+free_all_buffer(){
+    oc_discoverResource_t *cb_free =(oc_discoverResource_t *)oc_list_pop(discoverResource);
+  //while(cb_free != NULL){
+	   while(cb_free != NULL){
+	  free_buffer(cb_free);
+    cb_free = (oc_discoverResource_t *)oc_list_pop(discoverResource);
+}
+    //oc_free_server_endpoints(discoverResource);
+//  }while(oc_list_length(discoverResource)> 0);
+}
+
+#ifdef OC_CLOUD
+static pthread_mutex_t app_sync_lock;
+static void
+cloud_refresh_token_cb(oc_cloud_context_t *ctx, oc_cloud_status_t status, void *data)
+{
+  (void) data;
+  PRINT("\nCloud Refresh Token status flags:\n");
+  if (status & OC_CLOUD_REGISTERED) {
+    PRINT("\t\t-Registered\n");
+  }
+  if (status & OC_CLOUD_TOKEN_EXPIRY) {
+    PRINT("\t\t-Token Expiry: ");
+    if (ctx) {
+      PRINT("%d\n", oc_cloud_get_token_expiry(ctx));
+    } else {
+      PRINT("\n");
+    }
+  }
+  if (status & OC_CLOUD_FAILURE) {
+    PRINT("\t\t-Failure\n");
+  }
+  if (status & OC_CLOUD_LOGGED_IN) {
+    PRINT("\t\t-Logged In\n");
+  }
+  if (status & OC_CLOUD_LOGGED_OUT) {
+    PRINT("\t\t-Logged Out\n");
+  }
+  if (status & OC_CLOUD_DEREGISTERED) {
+    PRINT("\t\t-DeRegistered\n");
+  }
+  if (status & OC_CLOUD_REFRESHED_TOKEN) {
+    PRINT("\t\t-Refreshed Token\n");
+  }
+}
+
+static void
+cloud_refresh_token(void)
+{
+  oc_cloud_context_t *ctx = oc_cloud_get_context(0);
+  if (!ctx) {
+    return;
+  }
+  pthread_mutex_lock(&app_sync_lock);
+  int ret = oc_cloud_refresh_token(ctx, cloud_refresh_token_cb, NULL);
+  pthread_mutex_unlock(&app_sync_lock);
+  if (ret < 0) {
+    PRINT("\nCould not issue Refresh Token request\n");
+  } else {
+    PRINT("\nIssued Refresh Token request\n");
+  }
+}
+
+static void
+cloud_deregister_cb(oc_cloud_context_t *ctx, oc_cloud_status_t status, void *data)
+{
+  (void) data;
+  PRINT("\nCloud DeRegister status flags:\n");
+  if (status & OC_CLOUD_REGISTERED) {
+    PRINT("\t\t-Registered\n");
+  }
+  if (status & OC_CLOUD_TOKEN_EXPIRY) {
+    PRINT("\t\t-Token Expiry: ");
+    if (ctx) {
+      PRINT("%d\n", oc_cloud_get_token_expiry(ctx));
+    } else {
+      PRINT("\n");
+    }
+  }
+  if (status & OC_CLOUD_FAILURE) {
+    PRINT("\t\t-Failure\n");
+  }
+  if (status & OC_CLOUD_LOGGED_IN) {
+    PRINT("\t\t-Logged In\n");
+  }
+  if (status & OC_CLOUD_LOGGED_OUT) {
+    PRINT("\t\t-Logged Out\n");
+  }
+  if (status & OC_CLOUD_DEREGISTERED) {
+    PRINT("\t\t-DeRegistered\n");
+  }
+}
+
+static void
+cloud_deregister(void)
+{
+  oc_cloud_context_t *ctx = oc_cloud_get_context(0);
+  if (!ctx) {
+    return;
+  }
+  pthread_mutex_lock(&app_sync_lock);
+  int ret = oc_cloud_deregister(ctx, cloud_deregister_cb, NULL);
+  pthread_mutex_unlock(&app_sync_lock);
+  if (ret < 0) {
+    PRINT("\nCould not issue Cloud DeRegister request\n");
+  } else {
+    PRINT("\nIssued Cloud DeRegister request\n");
+  }
+}
+
+static void
+cloud_logout_cb(oc_cloud_context_t *ctx, oc_cloud_status_t status, void *data)
+{
+  (void) data;
+  PRINT("\nCloud Logout status flags:\n");
+  if (status & OC_CLOUD_REGISTERED) {
+    PRINT("\t\t-Registered\n");
+  }
+  if (status & OC_CLOUD_TOKEN_EXPIRY) {
+    PRINT("\t\t-Token Expiry: ");
+    if (ctx) {
+      PRINT("%d\n", oc_cloud_get_token_expiry(ctx));
+    } else {
+      PRINT("\n");
+    }
+  }
+  if (status & OC_CLOUD_FAILURE) {
+    PRINT("\t\t-Failure\n");
+  }
+  if (status & OC_CLOUD_LOGGED_IN) {
+    PRINT("\t\t-Logged In\n");
+  }
+  if (status & OC_CLOUD_LOGGED_OUT) {
+    PRINT("\t\t-Logged Out\n");
+  }
+}
+
+static void
+cloud_logout(void)
+{
+  oc_cloud_context_t *ctx = oc_cloud_get_context(0);
+  if (!ctx) {
+    return;
+  }
+  pthread_mutex_lock(&app_sync_lock);
+  int ret = oc_cloud_logout(ctx, cloud_logout_cb, NULL);
+  pthread_mutex_unlock(&app_sync_lock);
+  if (ret < 0) {
+    PRINT("\nCould not issue Cloud Logout request\n");
+  } else {
+    PRINT("\nIssued Cloud Logout request\n");
+  }
+}
+
+static void
+cloud_login_cb(oc_cloud_context_t *ctx, oc_cloud_status_t status, void *data)
+{
+  (void)data;
+  PRINT("\nCloud Login status flags:\n");
+  if (status & OC_CLOUD_REGISTERED) {
+    PRINT("\t\t-Registered\n");
+  }
+  if (status & OC_CLOUD_TOKEN_EXPIRY) {
+    PRINT("\t\t-Token Expiry: ");
+    if (ctx) {
+      PRINT("%d\n", oc_cloud_get_token_expiry(ctx));
+    } else {
+      PRINT("\n");
+    }
+  }
+  if (status & OC_CLOUD_FAILURE) {
+    PRINT("\t\t-Failure\n");
+  }
+  if (status & OC_CLOUD_LOGGED_IN) {
+    PRINT("\t\t-Logged In\n");
+  }
+}
+
+static void
+cloud_login(void)
+{
+  oc_cloud_context_t *ctx = oc_cloud_get_context(0);
+  if (!ctx) {
+    return;
+  }
+  pthread_mutex_lock(&app_sync_lock);
+  int ret = oc_cloud_login(ctx, cloud_login_cb, NULL);
+  pthread_mutex_unlock(&app_sync_lock);
+  if (ret < 0) {
+    PRINT("\nCould not issue Cloud Login request\n");
+  } else {
+    PRINT("\nIssued Cloud Login request\n");
+  }
+}
+
+static void
+cloud_register_cb(oc_cloud_context_t *ctx, oc_cloud_status_t status, void *data)
+{
+  (void)data;
+  PRINT("\nCloud Register status flags:\n");
+  if (status & OC_CLOUD_REGISTERED) {
+    PRINT("\t\t-Registered\n");
+  }
+  if (status & OC_CLOUD_TOKEN_EXPIRY) {
+    PRINT("\t\t-Token Expiry: ");
+    if (ctx) {
+      PRINT("%d\n", oc_cloud_get_token_expiry(ctx));
+    } else {
+      PRINT("\n");
+    }
+  }
+  if (status & OC_CLOUD_FAILURE) {
+    PRINT("\t\t-Failure\n");
+  }
+}
+
+static void
+cloud_register(void)
+{
+  oc_cloud_context_t *ctx = oc_cloud_get_context(0);
+  if (!ctx) {
+    return;
+  }
+  pthread_mutex_lock(&app_sync_lock);
+  int ret = oc_cloud_register(ctx, cloud_register_cb, NULL);
+  pthread_mutex_unlock(&app_sync_lock);
+  if (ret < 0) {
+    PRINT("\nCould not issue Cloud Register request\n");
+  } else {
+    PRINT("\nIssued Cloud Register request\n");
+  }
+}
+#endif
+
+#ifdef OC_CLOUD
+static void
+ping_handler(oc_client_response_t *data)
+{
+  (void)data;
+  PRINT("\nReceived Pong\n");
+}
+
+static void
+cloud_send_ping(void)
+{
+  PRINT("\nEnter receiving endpoint: ");
+  char addr[256];
+  int scanf_returnValueCloud;
+  scanf_returnValueCloud = scanf("%255s", addr);
+  char endpoint_string[256];
+  if(scanf_returnValueCloud != 0 )
+  sprintf(endpoint_string, "coap+tcp://%s", addr);
+  oc_string_t ep_string;
+  oc_new_string(&ep_string, endpoint_string, strlen(endpoint_string));
+  oc_endpoint_t endpoint;
+  int ret = oc_string_to_endpoint(&ep_string, &endpoint, NULL);
+  oc_free_string(&ep_string);
+  if (ret < 0) {
+    PRINT("\nERROR parsing endpoint string\n");
+    return;
+  }
+
+  if (oc_send_ping(false, &endpoint, 10, ping_handler, NULL)) {
+    PRINT("\nSuccessfully issued Ping request\n");
+    return;
+  }
+
+  PRINT("\nERROR issuing Ping request\n");
+}
+#endif
+
+#ifdef OC_COLLECTIONS_IF_CREATE
+/* Resource creation and request handlers for oic.r.switch.binary instances */
+typedef struct oc_switch_t
+{
+  struct oc_switch_t *next;
+  oc_resource_t *resource;
+  bool state;
+} oc_switch_t;
+OC_MEMB(switch_s, oc_switch_t, 1);
+OC_LIST(switches);
+
+bool
+set_switch_properties(oc_resource_t *resource, oc_rep_t *rep, void *data)
+{
+  (void)resource;
+  oc_switch_t *cswitch = (oc_switch_t *)data;
+  while (rep != NULL) {
+    switch (rep->type) {
+    case OC_REP_BOOL:
+      cswitch->state = rep->value.boolean;
+      break;
+    default:
+      break;
+    }
+    rep = rep->next;
+  }
+  return true;
+}
+
+void
+get_switch_properties(oc_resource_t *resource, oc_interface_mask_t iface_mask,
+                      void *data)
+{
+  oc_switch_t *cswitch = (oc_switch_t *)data;
+  oc_rep_start_root_object();
+  switch (iface_mask) {
+  case OC_IF_BASELINE:
+    oc_process_baseline_interface(resource);
+  /* fall through */
+  case OC_IF_A:
+    oc_rep_set_boolean(root, value, cswitch->state);
+    break;
+  default:
+    break;
+  }
+  oc_rep_end_root_object();
+}
+
+void
+post_cswitch(oc_request_t *request, oc_interface_mask_t iface_mask,
+             void *user_data)
+{
+  (void)iface_mask;
+  oc_switch_t *cswitch = (oc_switch_t *)user_data;
+  oc_rep_t *rep = request->request_payload;
+  bool bad_request = false;
+  while (rep) {
+    switch (rep->type) {
+    case OC_REP_BOOL:
+      if (oc_string_len(rep->name) != 5 ||
+          memcmp(oc_string(rep->name), "value", 5) != 0) {
+        bad_request = true;
+      }
+      break;
+    default:
+      if (oc_string_len(rep->name) > 2) {
+        if (strncmp(oc_string(rep->name), "x.", 2) == 0) {
+          break;
+        }
+      }
+      bad_request = true;
+      break;
+    }
+    rep = rep->next;
+  }
+
+  if (!bad_request) {
+    set_switch_properties(request->resource, request->request_payload, cswitch);
+  }
+
+  oc_rep_start_root_object();
+  oc_rep_set_boolean(root, value, cswitch->state);
+  oc_rep_end_root_object();
+
+  if (!bad_request) {
+    oc_send_response(request, OC_STATUS_CHANGED);
+  } else {
+    oc_send_response(request, OC_STATUS_BAD_REQUEST);
+  }
+}
+
+void
+get_cswitch(oc_request_t *request, oc_interface_mask_t iface_mask,
+            void *user_data)
+{
+  get_switch_properties(request->resource, iface_mask, user_data);
+  oc_send_response(request, OC_STATUS_OK);
+}
+
+oc_resource_t *
+get_switch_instance(const char *href, oc_string_array_t *types,
+                    oc_resource_properties_t bm, oc_interface_mask_t iface_mask,
+                    size_t device)
+{
+  oc_switch_t *cswitch = (oc_switch_t *)oc_memb_alloc(&switch_s);
+  if (cswitch) {
+    cswitch->resource = oc_new_resource(
+      NULL, href, oc_string_array_get_allocated_size(*types), device);
+    if (cswitch->resource) {
+      size_t i;
+      for (i = 0; i < oc_string_array_get_allocated_size(*types); i++) {
+        const char *rt = oc_string_array_get_item(*types, i);
+        oc_resource_bind_resource_type(cswitch->resource, rt);
+      }
+      oc_resource_bind_resource_interface(cswitch->resource, iface_mask);
+      cswitch->resource->properties = bm;
+      oc_resource_set_default_interface(cswitch->resource, OC_IF_A);
+      oc_resource_set_request_handler(cswitch->resource, OC_GET, get_cswitch,
+                                      cswitch);
+      oc_resource_set_request_handler(cswitch->resource, OC_POST, post_cswitch,
+                                      cswitch);
+      oc_resource_set_properties_cbs(cswitch->resource, get_switch_properties,
+                                     cswitch, set_switch_properties, cswitch);
+      oc_add_resource(cswitch->resource);
+
+      oc_list_add(switches, cswitch);
+      return cswitch->resource;
+    } else {
+      oc_memb_free(&switch_s, cswitch);
+    }
+  }
+  return NULL;
+}
+
+void
+free_switch_instance(oc_resource_t *resource)
+{
+  oc_switch_t *cswitch = (oc_switch_t *)oc_list_head(switches);
+  while (cswitch) {
+    if (cswitch->resource == resource) {
+      oc_delete_resource(resource);
+      oc_list_remove(switches, cswitch);
+      oc_memb_free(&switch_s, cswitch);
+      return;
+    }
+    cswitch = cswitch->next;
+  }
+}
+
+#endif /* OC_COLLECTIONS_IF_CREATE */
+/* */
+
+/*Perform the selected operation*/
+void
+selectMenu(int choice){
+  bool isMulticast;
+  switch(choice){
+  case 1:
+    createResource();
+    break;
+
+  case 2:
+    createInvisibleResource();
+    break;
+
+  case 3:
+    createResourceWithUrl();
+    break;
+
+  case 4:
+    printf("By default resource gets created in Secure mode");
+    break;
+
+  case 5:
+    createManyLightResources();
+    break;
+
+  case 6:
+    if (g_isTempResourceCreated == true)
+      collectionPointer = createGroupResource();
+    else
+      printf("\n!!!!!Please create resource first!!!!!\n");
+    break;
+
+  case 7:
+    deleteAllResources();
+    break;
+
+  case 8:
+    deleteCreatedGroup();
+    break;
+
+  case 9:
+    discoverIntrospection();
+    break;
+
+  case 11:
+    printf("Please type the Resource Type to find, then press Enter: ");
+    unsigned int count_restype = 25;
+    UserResourceType_input = malloc((size_t)count_restype);
+    int numResTypes = scanf("%s", UserResourceType_input);
+    if(numResTypes){
+      printf("\nuserResourceType entered is %s\n", UserResourceType_input);
+      findResource_UserResType(UserResourceType_input);
+    }
+    free(UserResourceType_input);
+    break;
+
+  case 12:
+    findAllResources();
+    break;
+
+  case 17:
+    sendGetRequest();
+    break;
+
+  case 18:
+    printEndpointsList();
+    break;
+
+  case 20:
+    sendPutRequestUpdate();
+    break;
+
+  case 21:
+    sendPostRequestUpdate();
+    break;
+
+  case 22:
+    sendPOSTRequest_partialUpdate_userInput();
+    break;
+
+  case 25:
+    observe_request();
+    break;
+
+  case 26:
+    stop_observe();
+    break;
+
+  case 28:
+    isMulticast = false;
+    discoverDevice(isMulticast );
+    break;
+
+  case 29:
+    isMulticast = true;
+    discoverDevice(isMulticast);
+    break;
+
+  case 30:
+    isMulticast = true;
+    discoverPlatform(isMulticast);
+    break;
+
+  case 31:
+    printf("\nPlease enter the group URI\n");
+    /* 'uri_size' specifies the number of bytes allocated to 'char*
+    collection_uri_input' using malloc */
+    char *collection_uri_input = malloc((size_t)uri_size);
+    int scanf_returnValue = scanf("%s", collection_uri_input);
+    if(scanf_returnValue == 1){
+      findGroup(collection_uri_input);
+    } else
+      printf("Failed to read URI");
+    break;
+
+  case 33:
+    printf("Update Group option chosen\n");
+    printf("\nEnter the URI of group to be updated\n");
+    /* 'uri_size' specifies the number of bytes allocated to 'char*
+    collection_uri_input2' using malloc */
+    char *collection_uri_input2 = malloc((size_t)uri_size);
+    int scanf_returnValue2 = scanf("%s", collection_uri_input2);
+    if(scanf_returnValue2 == 1){
+      collectionPointer = updateGroup(collection_uri_input2);
+    } else
+      printf("Failed to read URI");
+    break;
+
+  case 34:
+    printf("'Update local resource maually' chosen\n");
+    printf("Please enter the URI of resource to be updated manually\n");
+    char *resource_uri_input = malloc((size_t)uri_size);
+    int scanf_returnValue3 = scanf("%s", resource_uri_input);
+    if(scanf_returnValue3 == 1){
+      printf("\nResource URI read is as follows: %s\n", resource_uri_input);
+      if(g_isTempResourceCreated == true)
+        updateLocalResourceManually(resource_uri_input);
+      else
+        printf("\n!!!!!Please create resource first!!!!!\n");
+    } else
+      printf("Failed to read URI");
+    break;
+
+  case 36:
+    g_qos = HIGH_QOS;
+    printf("CON type message selected for client\n");
+    break;
+
+  case 37:
+    g_qos = LOW_QOS;
+    printf("NON type message selected for client\n");
+    break;
+#ifdef OC_TCP
+  case 40:
+    ping_count = 0;
+    ping_timeout = 360;
+    printf("Send PING\n");
+    sendPingMessage(ping_timeout);
+    break;
+#endif
+  case 46:
+    sendPOSTRequest_partialUpdate_userInput_auto_Bin();
+    break;
+
+  case 47:
+    sendPOSTRequest_partialUpdate_userInput_auto_Hum();
+    break;
+  case 107:
+    createSingleAirConResource();
+    break;
+#ifdef OC_CLOUD
+  case 111:
+    cloud_register();
+    break;
+
+  case 112:
+    cloud_login();
+    break;
+
+  case 113:
+    cloud_logout();
+    break;
+
+  case 114:
+    cloud_deregister();
+    break;
+
+  case 115:
+    cloud_refresh_token();
+    break;
+
+  case 116:
+    oc_cloud_publish_resources(0);
+    break;
+
+  case 117:
+    cloud_send_ping();
+    break;
+#endif
+  case 0:
+    oc_free_string(&name);
+    free_all_buffer();
+    oc_collection_free(collectionPointer);
+    oc_main_shutdown();
+    pthread_mutex_destroy(&mutex);
+    pthread_mutex_destroy(&app_mutex);
+    exit(0);
+    break;
+
+  default:
+    printf("Invalid Input. Please input your choice again\n");
+  }
+}
+
+void
+waitInSecond(int seconds){
+  sleep(seconds);
+}
+
+/*To sleep for few second to get data from network*/
+void
+waitForCallback(){
+  int elapsedSecond = 0;
+  while(g_hasCallbackArrived == false){
+    waitInSecond(CALLBACK_WAIT_MIN);
+    elapsedSecond++;
+    if(elapsedSecond > CALLBACK_WAIT_MAX){
+      break;
+    }
+  }
+}
+
+/*calling the register_resources  function of device_builder_server.c*/
+static void
+createResource(){
+  printf("\ncreateResource called!!\n");
+  if(g_isTempResourceCreated == false){
+    register_resources();
+    printf("Resource created successfully\n");
+    g_isTempResourceCreated = true;
+  } else{
+    printf("Resource already created\n");
+  }
+}
+
+/*Get call back for many light resource function*/
+static void
+get_light(oc_request_t *request, oc_interface_mask_t interface, void *user_data){
+  (void)user_data;
+  PRINT("GET_light:\n");
+  oc_rep_start_root_object();
+  switch(interface){
+  case OC_IF_BASELINE:
+    oc_process_baseline_interface(request->resource);
+    /* fall through */
+  case OC_IF_RW:
+    oc_rep_set_boolean(root, state, light_state);
+    break;
+  default:
+    break;
+  }
+  oc_rep_end_root_object();
+  oc_send_response(request, OC_STATUS_OK);
+  PRINT("Light state %d\n", light_state);
+}
+
+/* passing the invisible resource uri*/
+static void
+createInvisibleResource(){
+  PRINT("createInvisibleResource called!!\n");
+  if(g_isInvisibleResourceCreated == false){
+    oc_resource_t *res = oc_new_resource(NULL, LIGHT_INVISIBLE_URI, 1, 0);
+    oc_resource_bind_resource_type(res, "core.light");
+    oc_resource_bind_resource_interface(res, OC_IF_RW);
+    oc_resource_set_default_interface(res, OC_IF_RW);
+    oc_resource_set_discoverable(res, false);
+    oc_resource_set_periodic_observable(res, 1);
+    oc_resource_set_request_handler(res, OC_GET, get_light, NULL);
+
+    g_addInvisibleResource = oc_add_resource(res);
+    if(g_addInvisibleResource == true){
+      PRINT("Invisible Light Resource created successfully\n");
+      g_isInvisibleResourceCreated = true;
+    } else{
+      PRINT("Unable to create Invisible Light Resource \n");
+    }
+  } else{
+    PRINT("Resource already created!!\n");
+  }
+}
+
+/*creating the the resource by using url*/
+static void
+createResourceWithUrl(){
+  printf("Creating Resource with complete URL called!!\n");
+  if(g_isTempResourceCreated == false){
+    PRINT(" \n First Create resource and then choose this option \n ");
+  } else{
+    printf("Resource with complete URL already created!!\n");
+  }
+}
+
+static void
+postRequestClientCb(oc_client_response_t *data){
+  PRINT("postRequestClientCb:\n");
+  if(data->code == OC_STATUS_CHANGED)
+    PRINT("POST response OK\n");
+  else
+    PRINT("POST response code %d\n", data->code);
+}
+
+/*Sending post command for selected Resource*/
+static void
+sendPostRequestUpdate(){
+  PRINT("postRequestResource:\n");
+  int selection = selectResource();
+
+  oc_discoverResource_t *cb =
+    (oc_discoverResource_t *)oc_list_head(discoverResource);
+  int i = 1;
+  while(cb != NULL){
+    if(selection == i){
+      strncpy(postRequestUri, cb->uri, strlen(cb->uri));
+      postRequestUri[strlen(cb->uri)] = '\0';
+      postRequestEndpoint = cb->endpoint;
+      if(oc_init_post(postRequestUri, postRequestEndpoint, NULL,
+                       &postRequestClientCb, g_qos, NULL)){
+        oc_rep_start_root_object();
+        oc_rep_set_boolean(root, state, true);
+        oc_rep_end_root_object();
+        if(oc_do_post())
+          PRINT("Sent POST request\n");
+        else
+          PRINT("Could not send POST\n");
+      }else
+        PRINT("Could not init POST\n");
+    } else if(selection == CANCEL_SELECTION){
+      break;
+    }
+    i++;
+    cb = cb->next;
+  }
+}
+
+/*Discovrering the resource registered */
+oc_discovery_flags_t
+discovery(const char *di, const char *uri, oc_string_array_t types,
+          oc_interface_mask_t interfaces, oc_endpoint_t *endpoint,
+          oc_resource_properties_t bm, void *user_data){
+  (void)di;
+  (void)interfaces;
+  (void)user_data;
+  (void)bm;
+  int i;
+  oc_discoverResource_t *l =
+    (oc_discoverResource_t *)oc_memb_alloc(&discoverResource_m);
+  int uri_len = strlen(uri);
+  uri_len = (uri_len >= MAX_URI_LENGTH) ? MAX_URI_LENGTH - 1 : uri_len;
+  PRINT("\n discovery: %s", uri);
+  for(i = 0; i < (int)oc_string_array_get_allocated_size(types); i++){
+    char *t = oc_string_array_get_item(types, i);
+    if(strlen(t) > 0){
+      light_server = endpoint;
+      strncpy(a_light, uri, uri_len);
+      a_light[uri_len] = '\0';
+      oc_endpoint_t *ep = endpoint;
+     /* strncpy(l->uri, uri, strlen(uri));
+      l->uri[strlen(uri)] = '\0';*/
+	  // int uri_len = (strlen(uri) >= 64) ? 63 : strlen(uri);
+    memcpy(l->uri, uri, uri_len);
+    l->uri[uri_len] = '\0';
+      //l->endpoint = endpoint;
+	  oc_endpoint_list_copy(&l->endpoint, endpoint);
+      oc_list_add(discoverResource, l);
+      while(ep != NULL){
+        PRINT("\nIP address: \n");
+        PRINTIPaddr(*ep);
+        PRINT("\nPort:\n");
+        PRINTport(*ep);
+        PRINT("\n");
+        ep = ep->next;
+      }
+      g_hasCallbackArrived = true;
+      PRINT("Resource %s hosted at endpoints:\n", uri);
+      return OC_CONTINUE_DISCOVERY;
+    }
+  }
+  return OC_STOP_DISCOVERY;
+}
+
+static oc_discovery_flags_t
+defined_uri_discovery(const char *anchor, const char *uri,
+                      oc_string_array_t types, oc_interface_mask_t iface_mask,
+                      oc_endpoint_t *endpoint, oc_resource_properties_t bm,
+                      void *user_data){
+  (void)anchor;
+  (void)user_data;
+  (void)iface_mask;
+  (void)bm;
+  int i;
+  int uri_len = strlen(uri);
+  uri_len = (uri_len >= MAX_URI_LENGTH) ? MAX_URI_LENGTH - 1 : uri_len;
+  for(i = 0; i < (int)oc_string_array_get_allocated_size(types); i++){
+    char *t = oc_string_array_get_item(types, i);
+    if(strcmp("oic.wk.introspection", t) == 0 ||
+        strcmp(UserResourceType_input, t) == 1){
+      light_server = endpoint;
+      strncpy(a_light, uri, uri_len);
+      a_light[uri_len] = '\0';
+      g_hasCallbackArrived = true;
+      PRINT("Resource %s hosted at endpoints:\n", a_light);
+      oc_endpoint_t *ep = endpoint;
+      while(ep != NULL){
+        PRINTipaddr(*ep);
+        PRINT("\n");
+        ep = ep->next;
+      }
+      return OC_STOP_DISCOVERY;
+    }
+  }
+  oc_free_server_endpoints(endpoint);
+  return OC_CONTINUE_DISCOVERY;
+}
+
+/*calling the discovery function*/
+static void
+findAllResources(){
+  printf("Find All Resources called\n");
+  g_hasCallbackArrived = false;
+  free_all_buffer();
+  discoverDev = oc_do_ip_discovery(NULL, &discovery, NULL);
+  waitForCallback();
+}
+
+/*calling  discovery function for particular res type*/
+static void
+findResource_UserResType(char *userResourceType){
+  printf("\nfindResource_UserResType called, user input is %s\n",
+         userResourceType);
+  bool discoverResourcetype = false;
+  g_hasCallbackArrived = false;
+  if(userResourceType != NULL){
+    PRINT("call discovery!!\n");
+    discoverResourcetype =
+      oc_do_ip_discovery(userResourceType, &defined_uri_discovery, NULL);
+    waitForCallback();
+  }
+  if(discoverResourcetype == true){
+    PRINT("userResourceType Discovered\n");
+  } else{
+    PRINT("userResourceType is not Discovered");
+  }
+}
+
+static void
+get_response(oc_client_response_t *data){
+  PRINT("GET_light:\n");
+  if(data->code == OC_STATUS_CHANGED)
+    PRINT("GET response: CHANGED\n");
+  else if(data->code == OC_STATUS_CREATED)
+    PRINT("GET response: CREATED\n");
+  else
+    PRINT("GET response code %d\n", data->code);
+  g_hasCallbackArrived = true;
+}
+
+/*select particular resource which discoverd using discovery function*/
+static int
+selectResource(){
+  int selection = -1;
+  oc_discoverResource_t *cb =
+    (oc_discoverResource_t *)oc_list_head(discoverResource);
+  int len = oc_list_length(discoverResource);
+  PRINT("\n Discovery.... Please select resource no. and press Enter: \n");
+  PRINT("\t\t option : 0\t Cancel\n");
+  for(int i = 1; i <= len + 1; i++){
+    if(cb != NULL){
+      PRINT("\t\t option : %d\t", i);
+      PRINT("resource URI:%s \t", cb->uri);
+      PRINT("endpoint:");
+      oc_endpoint_t *endpoint = cb->endpoint;
+      PRINTipaddr(*endpoint);
+      PRINT("\n");
+      if(RUN_MODE == AUTO){
+      if (strcmp(cb->uri, temp)  == 0){
+         selection = i;
+      }
+      }
+      cb = cb->next;
+    }
+  }
+  if (RUN_MODE == MANUAL){
+  if(scanf("%d", &selection)){
+    PRINT("Selcted input for choice %d\n", selection);
+    if(selection < 0 || selection > len + 1){
+      PRINT("Invalid choice and Please choice the option from the menu \n");
+      if(scanf("%d", &selection)){
+        PRINT("Select input from choice %d\n", selection);
+      }
+    }
+  }
+  }
+  return selection;
+}
+
+/*sending get request for selected resource*/
+static void
+sendGetRequest(){
+  PRINT("SEND GET request is called\n ");
+  int selection = selectResource();
+  g_hasCallbackArrived = false;
+  char discoverUri[MAX_URI_LENGTH];
+  oc_endpoint_t *endpoint = NULL;
+  oc_discoverResource_t *cb =
+    (oc_discoverResource_t *)oc_list_head(discoverResource);
+  int i = 1;
+  while(cb != NULL){
+    if(selection == i){
+      strncpy(discoverUri, cb->uri, strlen(cb->uri));
+      discoverUri[strlen(cb->uri)] = '\0';
+      endpoint = cb->endpoint;
+      oc_do_get(discoverUri, endpoint, NULL, &get_response, g_qos, NULL);
+      waitForCallback();
+      while(endpoint != NULL){
+        endpoint = endpoint->next;
+		if (endpoint != NULL){
+        if((endpoint->flags & SECURED) && (endpoint->flags & TCP)){
+          oc_do_get(discoverUri, endpoint, NULL, &get_response, g_qos, NULL);
+          waitForCallback();
+          break;
+        }
+		}
+      }
+    } else if(selection == CANCEL_SELECTION){
+      break;
+    }
+    i++;
+    cb = cb->next;
+  }
+}
+
+static void
+post_observe(oc_client_response_t *data){
+  PRINT("post_observe:\n");
+  if (data->code == OC_STATUS_CHANGED)
+    PRINT("POST response OK\n");
+  else
+    PRINT("POST response code %d\n", data->code);
+}
+
+static void
+observe_response(oc_client_response_t *data){
+  PRINT("OBSERVE_light:\n");
+  oc_rep_t *rep = data->payload;
+  while(rep != NULL){
+    PRINT("key %s, value ", oc_string(rep->name));
+    switch(rep->type) {
+    case OC_REP_BOOL:
+      PRINT("%d\n", rep->value.boolean);
+      light_state = rep->value.boolean;
+      break;
+    default:
+      break;
+    }
+    rep = rep->next;
+  }
+
+  if(oc_init_post(observeUri, observeEndpoint, NULL, &post_observe, g_qos,
+                   NULL)){
+    oc_rep_start_root_object();
+    oc_rep_set_boolean(root, state, !light_state);
+    oc_rep_end_root_object();
+    if(oc_do_post())
+      PRINT("Sent POST request\n");
+    else
+      PRINT("Could not send POST\n");
+  } else
+    PRINT("Could not init POST\n");
+  g_hasCallbackArrived = true;
+}
+
+/*sending the observe request  for selected resource*/
+static void
+observe_request(void){
+  int selection = selectResource();
+  g_hasCallbackArrived = false;
+  oc_discoverResource_t *cb =
+    (oc_discoverResource_t *)oc_list_head(discoverResource);
+  int i = 1;
+  while(cb != NULL){
+    if(selection == i){
+      strncpy(observeUri, cb->uri, strlen(cb->uri));
+      observeUri[strlen(cb->uri)] = '\0';
+      observeEndpoint = cb->endpoint;
+      oc_do_observe(observeUri, observeEndpoint, NULL, &observe_response, g_qos,
+                    NULL);
+      waitForCallback();
+
+      while(observeEndpoint != NULL){
+        observeEndpoint = observeEndpoint->next;
+        if((observeEndpoint->flags & SECURED) &&
+            (observeEndpoint->flags & TCP)){
+          oc_do_observe(observeUri, observeEndpoint, NULL, &observe_response,
+                        g_qos, NULL);
+          waitForCallback();
+          break;
+        }
+      }
+    } else if(selection == CANCEL_SELECTION){
+      break;
+    }
+    i++;
+    cb = cb->next;
+  }
+}
+
+/*sending stop observe request for selected resource*/
+static void
+stop_observe(void){
+  int selection = selectResource();
+  g_hasCallbackArrived = false;
+  char stopObserveUri[MAX_URI_LENGTH];
+  oc_endpoint_t *stopObserveUriEndpoint = NULL;
+
+  oc_discoverResource_t *cb =
+    (oc_discoverResource_t *)oc_list_head(discoverResource);
+  int i = 1;
+  while(cb != NULL){
+    if(selection == i){
+      strncpy(stopObserveUri, cb->uri, strlen(cb->uri));
+      stopObserveUri[strlen(cb->uri)] = '\0';
+      stopObserveUriEndpoint = cb->endpoint;
+      oc_stop_observe(stopObserveUri, stopObserveUriEndpoint);
+      waitForCallback();
+    } else if(selection == CANCEL_SELECTION){
+      break;
+    }
+    i++;
+    cb = cb->next;
+  }
+}
+
+static oc_event_callback_retval_t
+putStopObserverequest(void *data){
+  (void)data;
+  PRINT("Stopping OBSERVE\n");
+  oc_stop_observe(putRequestUri, putRequestEndpoint);
+  return OC_EVENT_DONE;
+}
+
+static void
+putObserveRequestClientCb(oc_client_response_t *data){
+  PRINT("OBSERVE_light:\n");
+  oc_rep_t *rep = data->payload;
+  while(rep != NULL){
+    PRINT("key %s, value ", oc_string(rep->name));
+    switch(rep->type) {
+    case OC_REP_BOOL:
+      PRINT("%d\n", rep->value.boolean);
+      state = rep->value.boolean;
+      break;
+    case OC_REP_INT:
+      PRINT("%d\n", rep->value.integer);
+      power = rep->value.integer;
+      break;
+    case OC_REP_STRING:
+      PRINT("%s\n", oc_string(rep->value.string));
+      if(oc_string_len(name))
+        oc_free_string(&name);
+      oc_new_string(&name, oc_string(rep->value.string),
+                    oc_string_len(rep->value.string));
+      break;
+    default:
+      break;
+    }
+    rep = rep->next;
+  }
+}
+
+static void
+putPostRequestClientCb(oc_client_response_t *data){
+  PRINT("POST_light:\n");
+  if(data->code == OC_STATUS_CHANGED)
+    PRINT("POST response: CHANGED\n");
+  else if(data->code == OC_STATUS_CREATED)
+    PRINT("POST response: CREATED \n");
+  else
+    PRINT("POST response code %d\n", data->code);
+
+  oc_do_observe(putRequestUri, putRequestEndpoint, NULL,
+                &putObserveRequestClientCb, g_qos, NULL);
+  oc_set_delayed_callback(NULL, &putStopObserverequest, 30);
+  PRINT("Sent OBSERVE request\n");
+}
+
+static void
+putRequestClientCb(oc_client_response_t *data){
+  PRINT("PUT_light:\n");
+  if(data->code == OC_STATUS_CHANGED)
+    PRINT("PUT response: CHANGED\n");
+  else
+    PRINT("PUT response code %d\n", data->code);
+
+  if(oc_init_post(putRequestUri, putRequestEndpoint, NULL,
+                   &putPostRequestClientCb, g_qos, NULL)){
+    oc_rep_start_root_object();
+    oc_rep_set_boolean(root, state, false);
+    oc_rep_end_root_object();
+    if(oc_do_post())
+      PRINT("Sent POST request\n");
+    else
+      PRINT("Could not send POST request\n");
+  } else
+    PRINT("Could not init POST request\n");
+}
+
+static void
+getPutRequestClientCb(oc_client_response_t *data){
+  PRINT("getPutRequestClientCb:\n");
+  oc_rep_t *rep = data->payload;
+  while(rep != NULL){
+    PRINT("key %s, value ", oc_string(rep->name));
+    switch(rep->type) {
+    case OC_REP_BOOL:
+      PRINT("%d\n", rep->value.boolean);
+      state = rep->value.boolean;
+      break;
+    case OC_REP_INT:
+      PRINT("%d\n", rep->value.integer);
+      power = rep->value.integer;
+      break;
+    case OC_REP_STRING:
+      PRINT("%s\n", oc_string(rep->value.string));
+      if (oc_string_len(name))
+        oc_free_string(&name);
+      oc_new_string(&name, oc_string(rep->value.string),
+                    oc_string_len(rep->value.string));
+      break;
+    default:
+      break;
+    }
+    rep = rep->next;
+    g_hasCallbackArrived = true;
+  }
+
+  PRINT("get_put:\n");
+  if (oc_init_put(putRequestUri, putRequestEndpoint, NULL, &putRequestClientCb,
+                  g_qos, NULL)) {
+    oc_rep_start_root_object();
+    oc_rep_set_boolean(root, state, true);
+    oc_rep_end_root_object();
+
+    if (oc_do_put())
+      PRINT("Sent PUT request\n");
+    else
+      PRINT("Could not send PUT request\n");
+  } else
+    PRINT("Could not init PUT request\n");
+}
+
+/*sending put request to create resource*/
+static void
+sendPutRequestUpdate(){
+  PRINT("sendPutRequestUpdate\n");
+  int selection = selectResource();
+  g_hasCallbackArrived = false;
+  oc_discoverResource_t *cb =
+    (oc_discoverResource_t *)oc_list_head(discoverResource);
+  int i = 1;
+  while(cb != NULL){
+    if(selection == i){
+      strncpy(putRequestUri, cb->uri, strlen(cb->uri));
+      putRequestUri[strlen(cb->uri)] = '\0';
+      putRequestEndpoint = cb->endpoint;
+      oc_do_get(putRequestUri, putRequestEndpoint, NULL, &getPutRequestClientCb,
+                g_qos, NULL);
+      waitForCallback();
+    } else if(selection == CANCEL_SELECTION){
+      break;
+    }
+    i++;
+    cb = cb->next;
+  }
+}
+
+/*getting the device information wich registered in network*/
+static void
+get_device(oc_client_response_t *data){
+  PRINT("GET_device:\n");
+  oc_rep_t *rep = data->payload;
+  while(rep != NULL){
+    switch(rep->type) {
+    case OC_REP_STRING:
+      if((oc_string_len(rep->name) == 3 &&
+           memcmp(oc_string(rep->name), "pid", 3) == 0) ||
+          (oc_string_len(rep->name) == 3 &&
+           memcmp(oc_string(rep->name), "dmv", 3) == 0) ||
+          (oc_string_len(rep->name) == 3 &&
+           memcmp(oc_string(rep->name), "icv", 3) == 0) ||
+          (oc_string_len(rep->name) == 2 &&
+           memcmp(oc_string(rep->name), "di", 2) == 0)) {
+        PRINT("key: %s, value: %s\n", oc_string(rep->name),
+              oc_string(rep->value.string));
+      }
+      break;
+    case OC_REP_STRING_ARRAY:
+      if(oc_string_len(rep->name) == 2 &&
+          (memcmp(oc_string(rep->name), "rt", 2) == 0 ||
+           memcmp(oc_string(rep->name), "if", 2) == 0)) {
+        int i;
+        PRINT("key: %s, value: ", oc_string(rep->name));
+        for(i = 0;
+             i < (int)oc_string_array_get_allocated_size(rep->value.array);
+             i++) {
+          PRINT(" %s ", oc_string_array_get_item(rep->value.array, i));
+        }
+        PRINT("\n");
+      }
+      break;
+    default:
+      break;
+    }
+    rep = rep->next;
+  }
+  g_hasCallbackArrived = true;
+}
+
+/*getting the platform information of device register in network*/
+static void
+get_platform(oc_client_response_t *data){
+  PRINT("GET_platform:\n");
+  oc_rep_t *rep = data->payload;
+  while(rep != NULL){
+    switch(rep->type) {
+    case OC_REP_STRING:
+      if((oc_string_len(rep->name) == 2 &&
+           memcmp(oc_string(rep->name), "pi", 2) == 0) ||
+          (oc_string_len(rep->name) == 4 &&
+           memcmp(oc_string(rep->name), "mnmn", 4) == 0)) {
+        PRINT("key: %s  value: %s\n", oc_string(rep->name),
+              oc_string(rep->value.string));
+      }
+      break;
+    default:
+      break;
+    }
+    rep = rep->next;
+  }
+  g_hasCallbackArrived = true;
+}
+
+/*sending multicast/unicast request to get device informtion */
+static void
+discoverDevice(bool isMulticast){
+  g_hasCallbackArrived = false;
+  //if(!discoverDev)
+  {
+    if(isMulticast){
+      oc_make_ipv6_endpoint(mcast, IPV6 | DISCOVERY, 5683, 0xff, 0x02, 0, 0, 0,
+                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01, 0x58);
+      mcast.addr.ipv6.scope = 2;
+      oc_endpoint_t set_up;
+      set_up = mcast;
+
+      discoverDev =
+        oc_do_ip_discovery_at_endpoint(NULL, &discovery, &set_up, NULL);
+      waitForCallback();
+
+    } else{
+      discoverDev = oc_do_ip_discovery("oic.d.dehumidifier", &discovery, NULL);
+      waitForCallback();
+    }
+  } /*else{
+    PRINT("Device is already Discovered\n");
+  }*/
+  g_hasCallbackArrived = false;
+  PRINT("\n Taking the endPoint from discoverDevMul ----------->\n");
+  oc_discoverResource_t *cb =
+    (oc_discoverResource_t *)oc_list_head(discoverResource);
+  while(cb != NULL){
+    if(strncmp(cb->uri, "/oic/d", strlen(cb->uri)) == 0){
+      break;
+    }
+    cb = cb->next;
+  }
+  discoverDeviceInfo = oc_do_get("/oic/d", cb->endpoint, "if=oic.if.baseline",
+                                 &get_device, g_qos, NULL);
+  waitForCallback();
+
+  if(discoverDeviceInfo == true){
+
+    PRINT("\nDevice discovery done successfully\n");
+  } else{
+    PRINT("Device discovery failed\n");
+  }
+}
+
+/*Sending unicast or multicast request to get platform information*/
+static void
+discoverPlatform(bool isMulticast){
+  g_hasCallbackArrived = false;
+  if(!discoverDev){
+    if(!isMulticast){
+      oc_make_ipv6_endpoint(mcast, IPV6 | DISCOVERY, 5683, 0xff, 0x02, 0, 0, 0,
+                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01, 0x58);
+      mcast.addr.ipv6.scope = 2;
+      set_ep = mcast;
+      discoverDev =
+        oc_do_ip_discovery_at_endpoint(NULL, &discovery, &set_ep, NULL);
+      waitForCallback();
+    } else{
+      discoverDev = oc_do_ip_discovery(NULL, &discovery, NULL);
+      waitForCallback();
+    }
+  } else{
+    PRINT("Device is already Discovered\n");
+  }
+  g_hasCallbackArrived = false;
+  PRINT("\n Taking the endPoint from discoverDevMul ----------->\n");
+  oc_discoverResource_t *cb =
+    (oc_discoverResource_t *)oc_list_head(discoverResource);
+  while(cb != NULL){
+    if(strncmp(cb->uri, "/oic/p", strlen(cb->uri)) == 0){
+      break;
+    }
+    cb = cb->next;
+  }
+  discoverPlatformInfo =
+    oc_do_get("/oic/p", cb->endpoint, NULL, &get_platform, g_qos, NULL);
+  waitForCallback();
+  if (discoverPlatformInfo == true) {
+    PRINT("Platform discovery done successfully\n");
+  } else{
+    PRINT("Platform discovery failed\n");
+  }
+}
+
+/*sending discover introspection request */
+void
+discoverIntrospection(){
+  PRINT("Discovering Introspection using Multicast... ");
+  g_hasCallbackArrived = false;
+  oc_do_ip_discovery("oic.wk.introspection", &defined_uri_discovery, NULL);
+  waitForCallback();
+}
+
+static void
+post_light(oc_request_t *request, oc_interface_mask_t interface,
+           void *user_data){
+  (void)user_data;
+  (void)interface;
+  PRINT("POST_light:\n");
+  bool state = false;
+  oc_rep_t *rep = request->request_payload;
+  while(rep != NULL){
+    PRINT("key: %s ", oc_string(rep->name));
+    switch(rep->type){
+    case OC_REP_BOOL:
+      state = rep->value.boolean;
+      PRINT("value: %d\n", state);
+      break;
+    default:
+      oc_send_response(request, OC_STATUS_BAD_REQUEST);
+      return;
+      break;
+    }
+    rep = rep->next;
+  }
+  light_state = state;
+  oc_send_response(request, OC_STATUS_CHANGED);
+}
+
+static void
+put_light(oc_request_t *request, oc_interface_mask_t interface, void *user_data){
+  post_light(request, interface, user_data);
+}
+
+/*input is baseUri,lightCount added in the baseUri*/
+static void
+createManyLightResources(){
+  PRINT("createManyLightResources called!!\n");
+  bool add_LightResource;
+  char baseUri[20] = "/light/";
+  int lightCount = LIGHT_COUNT;
+  char uri[20] = "";
+
+  if(g_isManyLightCreated == false){
+    for(int i = 0; i <= MAX_LIGHT_RESOURCE_COUNT; i++, lightCount++){
+      sprintf(uri, "/light/%d", lightCount);
+      PRINT("%s\n", baseUri);
+      PRINT("%s\n", uri);
+      oc_resource_t *res =
+        oc_new_resource(RESOURCE_NAME, uri, NUM_RESOURCES_TYPES, NUM_DEVICE);
+      oc_resource_bind_resource_type(res, RESOURCE_LIGHT_TYPE);
+      oc_resource_bind_resource_interface(res, OC_IF_BASELINE);
+      oc_resource_set_default_interface(res, OC_IF_RW);
+      oc_resource_set_discoverable(res, true);
+      oc_resource_set_periodic_observable(res, 1);
+      oc_resource_set_request_handler(res, OC_GET, get_light, NULL);
+      oc_resource_set_request_handler(res, OC_POST, post_light, NULL);
+      oc_resource_set_request_handler(res, OC_PUT, put_light, NULL);
+      add_LightResource = oc_add_resource(res);
+      if(add_LightResource == true && lightCount == MAX_LIGHT_RESOURCE_COUNT){
+        PRINT("Light Resource created successfully with uri:\n");
+        g_isManyLightCreated = true;
+      }else{
+        PRINT("Unable to create Light resource with uri:\n");
+      }
+    }
+  }else{
+    PRINT("Many Light Resources already created!!\n");
+  }
+}
+
+/* createGroupResource() function creates a collection; also creates links to
+   resources that are to be added to the collection and adds them to the
+   collection; resource pointers are obtained from resource URIs */
+static oc_collection_t *
+createGroupResource(){
+  oc_resource_t *resource_one =
+    oc_ri_get_app_resource_by_uri(RESOURCE_1_URI, strlen(RESOURCE_1_URI), 0);
+
+  const char *collection_name = "ExampleCollection";
+  const char *collection_uri = "/CollectionResURI";
+
+#if defined(OC_COLLECTIONS)
+  oc_resource_t *new_collection =
+    oc_new_collection(collection_name, collection_uri, 1, 0);
+  if(new_collection != NULL)
+    PRINT("New collection created with the following name: %s\n",
+          new_collection->name.ptr);
+
+  oc_resource_bind_resource_type(new_collection, "oic.wk.col");
+  oc_resource_set_discoverable(new_collection, true);
+
+  oc_link_t *link_one = oc_new_link(resource_one);
+  oc_collection_add_link(new_collection, link_one);
+
+  oc_collection_add_supported_rt(new_collection, "oic.r.switch.binary");
+  oc_collection_add_mandatory_rt(new_collection, "oic.r.switch.binary");
+
+  #ifdef OC_COLLECTIONS_IF_CREATE
+  oc_collections_add_rt_factory("oic.r.switch.binary", get_switch_instance,
+                                free_switch_instance);
+  #endif /* OC_COLLECTIONS_IF_CREATE */
+
+  oc_add_collection(new_collection);
+
+#endif /* OC_COLLECTIONS */
+  return (oc_collection_t *)new_collection;
+}
+
+/*delete All  created resource*/
+static void
+deleteAllResources(){
+  PRINT("deteAllResources called!!\n");
+  oc_resource_t *res = oc_ri_get_app_resources();
+  while(res){
+    oc_ri_delete_resource(res);
+    res = oc_ri_get_app_resources();
+  }
+  if(res == NULL){
+    PRINT("All Resources Deleted\n");
+  }
+  g_isManyLightCreated = false;
+  g_addInvisibleResource = false;
+  g_isTempResourceCreated = false;
+  g_createResourceWithURL = false;
+  g_isAirConDeviceCreated = false;
+  free_all_buffer();
+  oc_free_string(&name);
+}
+
+static void
+deleteCreatedGroup(){
+  oc_collection_free(collectionPointer);
+  collectionPointer = NULL;
+  PRINT("\nCollection deleted\n");
+}
+
+static void
+post_response(oc_client_response_t *data){
+  PRINT("POST_light_response:\n");
+  if(data->code == OC_STATUS_CHANGED)
+    PRINT("POST response: CHANGED\n");
+  else if(data->code == OC_STATUS_CREATED)
+    PRINT("POST response: CREATED\n");
+  else
+    PRINT("POST response code %d\n", data->code);
+}
+
+/*Following function takes input of 'attribute key' and 'attribute value' from
+user and sends a POST request */
+static void
+sendPOSTRequest_partialUpdate_userInput_auto_Bin(){
+  char *key_value;
+  key_value = (char *)malloc(256);
+  long int choice = 0;
+  //bool wrongKeyEnter = false;
+  bool validChoice = false;
+  double valueDouble = 0.0;
+  int valueInt;
+  bool valueBool = false;
+  int selection = selectResource();
+  oc_discoverResource_t *cb =
+    (oc_discoverResource_t *)oc_list_head(discoverResource);
+  int i = 1;
+  while(cb != NULL){
+    if(selection == i){
+      strncpy(postRequestUri, cb->uri, strlen(cb->uri));
+      postRequestUri[strlen(cb->uri)] = '\0';
+      postRequestEndpoint = cb->endpoint;
+      if(oc_init_post(postRequestUri, postRequestEndpoint,
+                       "if=oic.if.baseline", &post_response, g_qos, NULL)){
+        PRINT("Please Enter the Key Value\n");
+        strcpy(key_value, "value");
+
+        PRINT("%s\n", key_value);
+        do{
+          PRINT("Please select attribute data type and press Enter: \n");
+          PRINT("\t\t 1. Integer\n");
+          PRINT("\t\t 2. Double Point - Double Precision\n");
+          PRINT("\t\t 3. Boolean\n");
+           choice = 3;
+          //int input = scanf("%d", &choice);
+          //PRINT("input : %d\n", input);
+          if(choice > 0 && choice < 5){
+            validChoice = true;
+          }else{
+            validChoice = false;
+            PRINT("Invalid input for attribute data type. Please select "
+                  "between 1 and 6 \n");
+          }
+        }while(!validChoice);
+        PRINT("Please input Attribute Value: ");
+        switch(choice) {
+        case 1:
+          if(scanf("%d", &valueInt)){
+            PRINT("%d\n", valueInt);
+          }
+          break;
+        case 2:
+          if(scanf("%lf", &valueDouble)){
+            PRINT("%lf\n", valueDouble);
+          }
+          break;
+        case 3:
+          PRINT("\nPlease provide boolean value(O for False, 1 for True) : ");
+          valueBool = 1;
+          break;
+        }
+        oc_rep_start_root_object();
+
+        switch(choice){
+        case 1:
+          oc_rep_set_key(oc_rep_object(root), key_value);
+          oc_rep_set_value_int(root, valueInt);
+          break;
+        case 2:
+          oc_rep_set_key(oc_rep_object(root), key_value);
+          oc_rep_set_value_double(root, valueDouble);
+          break;
+        case 3:
+          oc_rep_set_key(oc_rep_object(root), key_value);
+          oc_rep_set_value_boolean(root, valueBool);
+          break;
+        default:
+          break;
+        }
+        oc_rep_end_root_object();
+        if(oc_do_post()){
+          PRINT("Sent POST request\n");
+        }else
+          PRINT("Could not send POST\n");
+      }else
+        PRINT("Could not init POST\n");
+    }else if(selection == CANCEL_SELECTION){
+      break;
+    }
+    i++;
+    cb = cb->next;
+  }
+}
+
+static void
+sendPOSTRequest_partialUpdate_userInput_auto_Hum(){
+  char *key_value;
+  key_value = (char *)malloc(256);
+  long int choice = 0;
+  //bool wrongKeyEnter = false;
+  bool validChoice = false;
+  double valueDouble = 0.0;
+  int valueInt;
+  bool valueBool = false;
+  int selection = selectResource();
+  oc_discoverResource_t *cb =
+    (oc_discoverResource_t *)oc_list_head(discoverResource);
+  int i = 1;
+  while(cb != NULL){
+    if(selection == i){
+      strncpy(postRequestUri, cb->uri, strlen(cb->uri));
+      postRequestUri[strlen(cb->uri)] = '\0';
+      postRequestEndpoint = cb->endpoint;
+      if(oc_init_post(postRequestUri, postRequestEndpoint,
+                       "if=oic.if.baseline", &post_response, g_qos, NULL)){
+        PRINT("Please Enter the Key Value\n");
+        strcpy(key_value, "desiredHumidity");
+        PRINT("%s\n", key_value);
+        do{
+          PRINT("Please select attribute data type and press Enter: \n");
+          PRINT("\t\t 1. Integer\n");
+          PRINT("\t\t 2. Double Point - Double Precision\n");
+          PRINT("\t\t 3. Boolean\n");
+           choice = 1;
+          //int input = scanf("%d", &choice);
+          //PRINT("input : %d\n", input);
+          if(choice > 0 && choice < 5){
+            validChoice = true;
+          }else{
+            validChoice = false;
+            PRINT("Invalid input for attribute data type. Please select "
+                  "between 1 and 6 \n");
+          }
+        }while(!validChoice);
+        PRINT("Please input Attribute Value: ");
+        switch(choice) {
+        case 1:
+          valueInt = 78;
+          break;
+        case 2:
+          if(scanf("%lf", &valueDouble)){
+            PRINT("%lf\n", valueDouble);
+          }
+          break;
+        case 3:
+          PRINT("\nPlease provide boolean value(O for False, 1 for True) : ");
+          //valueBool = 78;
+          break;
+
+        }
+        oc_rep_start_root_object();
+
+        switch(choice){
+        case 1:
+          oc_rep_set_key(oc_rep_object(root), key_value);
+          oc_rep_set_value_int(root, valueInt);
+          break;
+        case 2:
+          oc_rep_set_key(oc_rep_object(root), key_value);
+          oc_rep_set_value_double(root, valueDouble);
+          break;
+        case 3:
+          oc_rep_set_key(oc_rep_object(root), key_value);
+          oc_rep_set_value_boolean(root, valueBool);
+          break;
+        default:
+          break;
+        }
+        oc_rep_end_root_object();
+        if(oc_do_post()){
+          PRINT("Sent POST request\n");
+        }else
+          PRINT("Could not send POST\n");
+      }else
+        PRINT("Could not init POST\n");
+    }else if(selection == CANCEL_SELECTION){
+      break;
+    }
+    i++;
+    cb = cb->next;
+  }
+}
+
+static void
+sendPOSTRequest_partialUpdate_userInput(){
+  char *key_value;
+  key_value = (char *)malloc(256);
+  long int choice = 0;
+  bool wrongKeyEnter = false;
+  bool validChoice = false;
+  double valueDouble = 0.0;
+  int valueInt;
+  bool valueBool;
+  int selection = selectResource();
+  oc_discoverResource_t *cb =
+    (oc_discoverResource_t *)oc_list_head(discoverResource);
+  int i = 1;
+  while(cb != NULL){
+    if(selection == i){
+      strncpy(postRequestUri, cb->uri, strlen(cb->uri));
+      postRequestUri[strlen(cb->uri)] = '\0';
+      postRequestEndpoint = cb->endpoint;
+      if(oc_init_post(postRequestUri, postRequestEndpoint,
+                       "if=oic.if.baseline", &post_response, g_qos, NULL)){
+        PRINT("Please Enter the Key Value\n");
+
+        do{
+          if(scanf("%s", key_value)){
+            int key_length;
+            key_length = strlen(key_value);
+            key_value[key_length] = '\0';
+            for(int i = 0; i < key_length; i++){
+              if(isalpha(key_value[i])){
+                wrongKeyEnter = true;
+              }else{
+                PRINT("Please Enter the key again\n");
+                break;
+              }
+            }
+          }
+        }while(!wrongKeyEnter);
+        PRINT("%s\n", key_value);
+        do{
+          PRINT("Please select attribute data type and press Enter: \n");
+          PRINT("\t\t 1. Integer\n");
+          PRINT("\t\t 2. Double Point - Double Precision\n");
+          PRINT("\t\t 3. Boolean\n");
+          int input = scanf("%d", &choice);
+          PRINT("input : %d\n", input);
+          if(choice > 0 && choice < 5){
+            validChoice = true;
+          }else{
+            validChoice = false;
+            PRINT("Invalid input for attribute data type. Please select "
+                  "between 1 and 6 \n");
+          }
+        }while(!validChoice);
+        PRINT("Please input Attribute Value: ");
+        switch(choice) {
+        case 1:
+          if(scanf("%d", &valueInt)){
+            PRINT("%d\n", valueInt);
+          }
+          break;
+        case 2:
+          if(scanf("%lf", &valueDouble)){
+            PRINT("%lf\n", valueDouble);
+          }
+          break;
+        case 3:
+          PRINT("\nPlease provide boolean value(O for False, 1 for True) : ");
+          if(scanf("%d", &valueBool)){
+            PRINT("%d\n", valueBool);
+            break;
+          }
+        }
+        oc_rep_start_root_object();
+
+        switch(choice){
+        case 1:
+          oc_rep_set_key(oc_rep_object(root), key_value);
+          oc_rep_set_value_int(root, valueInt);
+          break;
+        case 2:
+          oc_rep_set_key(oc_rep_object(root), key_value);
+          oc_rep_set_value_double(root, valueDouble);
+          break;
+        case 3:
+          oc_rep_set_key(oc_rep_object(root), key_value);
+          oc_rep_set_value_boolean(root, valueBool);
+          break;
+        default:
+          break;
+        }
+        oc_rep_end_root_object();
+        if(oc_do_post()){
+          PRINT("Sent POST request\n");
+        }else
+          PRINT("Could not send POST\n");
+      }else
+        PRINT("Could not init POST\n");
+    }else if(selection == CANCEL_SELECTION){
+      break;
+    }
+    i++;
+    cb = cb->next;
+  }
+}
+
+/* Following function takes URI of the collection to be updated, as input. It
+allows 1. updation of collection properties(namely collection type, collection
+interface and collection path), 2. adding of a resource to the collection, 3.
+removal of a resource from a collection and 4. updation of the properties(namely
+type, interface and path) of a resource in the collection. */
+
+static oc_collection_t *
+updateGroup(char *uri_input){
+  oc_collection_t *tempCollection =
+    oc_get_collection_by_uri(uri_input, strlen(uri_input), 0);
+  int optionNumber;
+
+  if(tempCollection == NULL){
+    PRINT("!!Collection not found!! Collection URI entered may be incorrect OR "
+          "collection is not created OR both\n");
+  }else{
+    PRINT("\nResources part of '%s' are as follows:\n",
+    tempCollection->name.ptr);
+    oc_link_t *resource_links =
+      oc_collection_get_links((oc_resource_t *)tempCollection);
+    int count_resource = 1;
+
+    while(resource_links != NULL){
+      PRINT("Resource %d - URI: '%s'\n", count_resource,
+            resource_links->resource->uri.ptr);
+      count_resource++;
+      resource_links = resource_links->next;
+    }
+    PRINT("..................\n");
+    PRINT("Update Group Menu:\n");
+    PRINT("..................\n");
+    PRINT("Choose from below options by entering the option number\n1. Update "
+          "collection properties\n"
+          "2. Add a resource to group\n3. Remove a resource from group\n4. "
+          "Update a resource's properties\n");
+    int scanf_return_value = scanf("%d", &optionNumber);
+    if(scanf_return_value)
+      PRINT("Option chosen:%d\n", optionNumber);
+
+    switch(optionNumber){
+    case 1:;
+      int collectionPropertyOptionNumber = -1;
+      unsigned int count_case1 = 25;
+      char *resource_property_case1 = malloc((size_t)count_case1);
+      int collectionInterfaceIntegerValue = 1;
+      while(collectionPropertyOptionNumber != 0){
+      case1_label:
+        PRINT("\t\t..................\n");
+        PRINT("\t\tUpdate collection properties:\n");
+        PRINT("\t\t..................\n");
+        PRINT("\t\tChoose from below options by entering the option "
+              "number\n\t\t1. Update collection type\n"
+              "\t\t2. Update collection interface\n\t\t3. Update collection "
+              "path\n\t\t0. Exit Update collection Properties\n");
+
+        int scanf_returnValue_case1 =
+          scanf("%d", &collectionPropertyOptionNumber);
+        if(scanf_returnValue_case1){
+          if(collectionPropertyOptionNumber == 0){
+            PRINT("'Exit Update Collection Properties' chosen\n");
+            break;
+          }else if(collectionPropertyOptionNumber == 1){
+            PRINT("Option 1 chosen.\n");
+            PRINT("Presently, collection type is '%s'\n",
+                  tempCollection->types.ptr);
+            PRINT("Please enter new 'collection type'\n");
+            int scanf_returnValue_case1_2 =
+              scanf("%s", resource_property_case1);
+            if(scanf_returnValue_case1_2)
+              PRINT("\nCollection property read is as follows: %s\n",
+                    resource_property_case1);
+          }else if(collectionPropertyOptionNumber == 2){
+            PRINT("\nOption 2 chosen.\n");
+            PRINT("Presently, interface value is %d\n\n",
+                  tempCollection->interfaces);
+            PRINT("Please enter a suitable integer number using the guide "
+                  "below\nto have"
+                  "the required interfaces for the collection\n\n");
+            PRINT("2: corresponds to Baseline(OC_IF_BASELINE) interface\n"
+                  "4: corresponds to Link Lists(OC_IF_LL) interface\n"
+                  "8: corresponds to Batch(OC_IF_B) interface\n"
+                  "16: corresponds to Read-only(OC_IF_R) interface\n"
+                  "32: corresponds to Read-Write(OC_IF_RW) interface\n"
+                  "64: corresponds to Actuator(OC_IF_A) interface\n"
+                  "128: corresponds to Sensor(OC_IF_S) interface\n");
+            PRINT("66(2+64): corresponds to interfaces of Baseline(2) and "
+                  "Actuator(64)\n");
+            PRINT("18(2+16): corresponds to interfaces of Baseline(2) and "
+                  "Read-only(16)\netc.,\n");
+            int scanf_returnValue_case1_3 =
+              scanf("%d", &collectionInterfaceIntegerValue);
+            if(scanf_returnValue_case1_3)
+              PRINT("Collection Interface Integer Value entered: %d\n",
+                    collectionInterfaceIntegerValue);
+          }else if(collectionPropertyOptionNumber == 3){
+            PRINT("Option 3 chosen.\n");
+            PRINT("Presently, collection URI is '%s'\n",
+                  tempCollection->uri.ptr);
+            PRINT("Please enter 'new collection URI'\n");
+            int scanf_returnValue_case1_4 =
+              scanf("%s", resource_property_case1);
+            if(scanf_returnValue_case1_4)
+              PRINT("\nNew URI read is as follows: %s\n",
+                    resource_property_case1);
+          }else{
+            PRINT("!!!!!!!!Invalid option chosen!!!!!!!!\n");
+            goto case1_label;
+          }
+        }else
+          PRINT("Read from scanf was unsuccessful\n");
+
+        switch(collectionPropertyOptionNumber){
+        case 1:
+          PRINT("\nResource type of collection '%s' before updation: %s\n",
+                tempCollection->name.ptr, tempCollection->types.ptr);
+          tempCollection->types.ptr = resource_property_case1;
+          PRINT("Resource type of collection '%s' after updation: %s\n",
+                tempCollection->name.ptr, tempCollection->types.ptr);
+          break;
+
+        case 2:
+          PRINT("\nInterface of collection '%s' before updation: %d\n",
+                tempCollection->name.ptr, tempCollection->interfaces);
+          tempCollection->interfaces = collectionInterfaceIntegerValue;
+          PRINT("Interface of collection '%s' after updation: %d\n",
+                tempCollection->name.ptr, tempCollection->interfaces);
+          break;
+
+        case 3:
+          /* Still working on updating collection path */
+          PRINT("\nURI of collection '%s' before updation: %s\n",
+                tempCollection->name.ptr, tempCollection->uri.ptr);
+          tempCollection->uri.ptr = resource_property_case1;
+          PRINT("URI of collection '%s' after updation: %s\n",
+                tempCollection->name.ptr, tempCollection->uri.ptr);
+          break;
+
+        default:
+          PRINT("Entered 'default case' of switch statement in 'case 4' of "
+                "outer switch statement\n");
+          break;
+        }
+      }
+      break;
+
+    case 2:
+      PRINT("\nEnter the URI of the resource to be added to the group '%s'\n",
+            tempCollection->name.ptr);
+      unsigned int count_case2 = 25;
+      char *resource_uri_case2 = malloc((size_t)count_case2);
+      int scanf_returnValue_case2 = scanf("%s", resource_uri_case2);
+      if(scanf_returnValue_case2)
+        PRINT("");
+      oc_resource_t *resource_case2 = oc_ri_get_app_resource_by_uri(
+        resource_uri_case2, strlen(resource_uri_case2), 0);
+      if(resource_case2 != NULL){
+        oc_link_t *link_one = oc_new_link(resource_case2);
+        oc_collection_add_link((oc_resource_t *)tempCollection, link_one);
+        PRINT(
+          "\nLink of resource with URI:'%s' has been added to the group '%s'\n",
+          resource_uri_case2, tempCollection->name.ptr);
+      }else{
+        PRINT("\n!!!!!Resource with above entered URI is not found!!!!!\n");
+      }
+      PRINT(
+        "\nFollowing resources are part of '%s' after addition of resource\n",
+        tempCollection->name.ptr);
+      oc_link_t *resource_links_case2 =
+        oc_collection_get_links((oc_resource_t *)tempCollection);
+      int count_case2_1 = 1;
+      while(resource_links_case2 != NULL){
+        PRINT("Resource %d - URI: '%s'\n", count_case2_1,
+              resource_links_case2->resource->uri.ptr);
+        count_case2_1++;
+        resource_links_case2 = resource_links_case2->next;
+      }
+      break;
+
+    case 3:
+      PRINT("\nEnter the URI of the resource to be removed from the group\n");
+      unsigned int count_case3 = 25;
+      char *resource_uri_case3 = malloc((size_t)count_case3);
+      int scanf_returnValue_case3 = scanf("%s", resource_uri_case3);
+      if(scanf_returnValue_case3)
+        PRINT("\nResource URI read is as follows: %s\n", resource_uri_case3);
+
+      oc_resource_t *resource_case3 = oc_ri_get_app_resource_by_uri(
+        resource_uri_case3, strlen(resource_uri_case3), 0);
+      if(resource_case3 == NULL)
+        PRINT("\n!!!!!Resource with above entered URI is not found!!!!!\n");
+      else{
+        oc_link_t *resource_links_case3 =
+          oc_collection_get_links((oc_resource_t *)tempCollection);
+
+        while(resource_links_case3 != NULL){
+          if(!strcmp(resource_links_case3->resource->uri.ptr,
+                      resource_uri_case3)){
+            PRINT("\n........Resource(resource link) removed from the "
+                  "group........\n");
+            PRINT(
+              "\nLink of resource with uri: '%s' will be removed from '%s'\n",
+              resource_links_case3->resource->uri.ptr,
+              tempCollection->name.ptr);
+            oc_collection_remove_link((oc_resource_t *)tempCollection,
+                                      resource_links_case3);
+            PRINT("\n........Resource(resource link) removed from the "
+                  "group........\n");
+            PRINT("\n........Resource(resource link) removed from the "
+                  "group........\n");
+            break;
+          }
+          resource_links_case3 = resource_links_case3->next;
+        }
+      }
+      break;
+
+    case 4:
+      PRINT("Enter the URI of resource whose properties are to be updated\n");
+      int resourcePropertyOptionNumber = -1;
+      unsigned int count_case4 = 25;
+      char *resource_uri_case4 = malloc((size_t)count_case4);
+      int scanf_returnValue_case4 = scanf("%s", resource_uri_case4);
+      if(scanf_returnValue_case4)
+        PRINT("\nResource URI read is as follows: %s\n", resource_uri_case4);
+      oc_resource_t *resource_case4 = oc_ri_get_app_resource_by_uri(
+        resource_uri_case4, strlen(resource_uri_case4), 0);
+      if(resource_case4 == NULL){
+        PRINT("!!!!!Resource not found!!!!!\nPlease choose 'Option 33', "
+              "'sub-option 4' again and enter approriate URI\n");
+      }else{
+        unsigned int count_case4_2 = 25;
+        char *resource_property_case4 = malloc((size_t)count_case4_2);
+        int resourceInterfaceIntegerValue = 1;
+        while(resourcePropertyOptionNumber != 0){
+        case4_label:
+          PRINT("\t\t..................\n");
+          PRINT("\t\tUpdate resource properties:\n");
+          PRINT("\t\t..................\n");
+          PRINT("\t\tChoose from below options by entering the option "
+                "number\n\t\t1. Update resource type\n"
+                "\t\t2. Update resource interface\n\t\t3. Update resource "
+                "path\n\t\t0. Exit Update Resource Properties\n");
+
+          int scanf_returnValue_case4_2 =
+            scanf("%d", &resourcePropertyOptionNumber);
+          if(scanf_returnValue_case4_2){
+            if(resourcePropertyOptionNumber == 0){
+              printf("'Exit Update Resource Properties' chosen\n");
+              break;
+            }else if(resourcePropertyOptionNumber == 1){
+              PRINT("Option 1 chosen.\n");
+              PRINT("Presently, resource type is '%s'\n",
+                    resource_case4->types.ptr);
+              PRINT("Please enter new 'resource type'\n");
+              int scanf_returnValue_case4_3 =
+                scanf("%s", resource_property_case4);
+              if(scanf_returnValue_case4_3)
+                PRINT("\nResource property read is as follows: %s\n",
+                      resource_property_case4);
+            }else if(resourcePropertyOptionNumber == 2){
+              PRINT("\nOption 2 chosen.\n");
+              PRINT("Presently, interface value is %d\n\n",
+                    resource_case4->interfaces);
+              PRINT(
+                "Please enter a suitable integer number using the guide "
+                "below\nto have the required interfaces for the resource\n\n");
+              PRINT("2: corresponds to Baseline(OC_IF_BASELINE) interface\n"
+                    "4: corresponds to Link Lists(OC_IF_LL) interface\n"
+                    "8: corresponds to Batch(OC_IF_B) interface\n"
+                    "16: corresponds to Read-only(OC_IF_R) interface\n"
+                    "32: corresponds to Read-Write(OC_IF_RW) interface\n"
+                    "64: corresponds to Actuator(OC_IF_A) interface\n"
+                    "128: corresponds to Sensor(OC_IF_S) interface\n");
+              PRINT("66(2+64): corresponds to interfaces of Baseline(2) and "
+                    "Actuator(64)\n");
+              PRINT("18(2+16): corresponds to interfaces of Baseline(2) and "
+                    "Read-only(16)\netc.,\n");
+              int scanf_returnValue_case4_4 =
+                scanf("%d", &resourceInterfaceIntegerValue);
+              if(scanf_returnValue_case4_4)
+                printf("Resource Interface Integer Value entered: %d\n",
+                       resourceInterfaceIntegerValue);
+            }else if(resourcePropertyOptionNumber == 3){
+              PRINT("Option 3 chosen.\n");
+              PRINT("Presently, resource uri is '%s'\n",
+                    resource_case4->uri.ptr);
+              PRINT("Please enter new 'resource URI'\n");
+              int scanf_returnValue_case4_5 =
+                scanf("%s", resource_property_case4);
+              if(scanf_returnValue_case4_5)
+                PRINT("\nNew URI read is as follows: %s\n",
+                      resource_property_case4);
+            }else{
+              PRINT("!!!!!!!!Invalid option chosen!!!!!!!!\n");
+              goto case4_label;
+            }
+          }else
+            PRINT("Read from scanf was unsuccessful\n");
+
+          switch(resourcePropertyOptionNumber){
+          case 1:
+            PRINT("\nResource type of resource '%s' before updation: %s\n",
+                  resource_case4->name.ptr, resource_case4->types.ptr);
+            resource_case4->types.ptr = resource_property_case4;
+            PRINT("Resource type of resource '%s' after updation: %s\n",
+                  resource_case4->name.ptr, resource_case4->types.ptr);
+            break;
+
+          case 2:
+            PRINT("\nResource interface of resource '%s' before updation: %d\n",
+                  resource_case4->name.ptr, resource_case4->interfaces);
+            resource_case4->interfaces = resourceInterfaceIntegerValue;
+            PRINT("Resource interface of resource '%s' after updation: %d\n",
+                  resource_case4->name.ptr, resource_case4->interfaces);
+            break;
+
+          case 3:
+            PRINT("\nResource URI of resource '%s' before updation: %s\n",
+                  resource_case4->name.ptr, resource_case4->uri.ptr);
+            resource_case4->uri.ptr = resource_property_case4;
+            PRINT("Resource URI of resource '%s' after updation: %s\n",
+                  resource_case4->name.ptr, resource_case4->uri.ptr);
+            break;
+
+          default:
+            PRINT("Entered 'default case' of switch statement in 'case 4' of "
+                  "outer switch statement\n");
+            break;
+          }
+        }
+      }
+      break;
+
+    default:
+      PRINT("!!!!Invalid Option Entered!!!!\n");
+      break;
+    }
+  }
+  return tempCollection;
+}
+
+/* Following function takes a resource URI as input and allows for the updation
+of the resource's properties(namely type, interface and path) */
+static void
+updateLocalResourceManually(char *uri_input){
+  oc_resource_t *resource =
+    oc_ri_get_app_resource_by_uri(uri_input, strlen(uri_input), 0);
+  if(resource == NULL){
+    PRINT("\n!!!!!Resource not found!!!!!\nPlease choose 'Option 34' again and "
+          "enter approriate URI\n");
+    return;
+  }else{
+    unsigned int count_case4_2 = 25;
+    char *resource_property_case4 = malloc((size_t)count_case4_2);
+    int resourcePropertyOptionNumber = -1;
+    int resourceInterfaceIntegerValue = 1;
+    while(resourcePropertyOptionNumber != 0){
+    case4_label:
+      PRINT("\t\t..................\n");
+      PRINT("\t\tUpdate resource properties:\n");
+      PRINT("\t\t..................\n");
+      PRINT("\t\tChoose from below options by entering the option "
+            "number\n\t\t1. Update resource type\n"
+            "\t\t2. Update resource interface\n\t\t3. Update resource "
+            "path\n\t\t0. Exit Update Resource Properties\n");
+      int scanf_returnValue_case4_2 =
+        scanf("%d", &resourcePropertyOptionNumber);
+      if(scanf_returnValue_case4_2){
+        if(resourcePropertyOptionNumber == 0){
+          PRINT("'Exit Update Resource Properties' chosen\n");
+          break;
+        }else if(resourcePropertyOptionNumber == 1){
+          PRINT("Option 1 chosen.\n");
+          PRINT("Presently, resource type is '%s'\n", resource->types.ptr);
+          PRINT("Please enter new 'resource type'\n");
+          int scanf_returnValue_case4_3 = scanf("%s", resource_property_case4);
+          if(scanf_returnValue_case4_3)
+            PRINT("\nResource property read is as follows: %s\n",
+                  resource_property_case4);
+        } else if(resourcePropertyOptionNumber == 2){
+          PRINT("\nOption 2 chosen.\n");
+          PRINT("Presently, interface value is %d\n\n", resource->interfaces);
+          PRINT("Please enter a suitable integer number using the guide "
+                "below\nto have the required interfaces for the resource\n\n");
+          PRINT("2: corresponds to Baseline(OC_IF_BASELINE) interface\n"
+                "4: corresponds to Link Lists(OC_IF_LL) interface\n"
+                "8: corresponds to Batch(OC_IF_B) interface\n"
+                "16: corresponds to Read-only(OC_IF_R) interface\n"
+                "32: corresponds to Read-Write(OC_IF_RW) interface\n"
+                "64: corresponds to Actuator(OC_IF_A) interface\n"
+                "128: corresponds to Sensor(OC_IF_S) interface\n");
+          PRINT("66(2+64): corresponds to interfaces of Baseline(2) and "
+                "Actuator(64)\n");
+          PRINT("18(2+16): corresponds to interfaces of Baseline(2) and "
+                "Read-only(16)\netc.,\n");
+          int scanf_returnValue_case4_4 =
+            scanf("%d", &resourceInterfaceIntegerValue);
+          if(scanf_returnValue_case4_4)
+            PRINT("Resource Interface Integer Value entered: %d\n",
+                  resourceInterfaceIntegerValue);
+
+        }else if(resourcePropertyOptionNumber == 3){
+          PRINT("Option 3 chosen.\n");
+          PRINT("Presently, resource uri is '%s'\n", resource->uri.ptr);
+          PRINT("Please enter new 'resource URI'\n");
+          int scanf_returnValue_case4_5 = scanf("%s", resource_property_case4);
+          if(scanf_returnValue_case4_5)
+            PRINT("\nNew URI read is as follows: %s\n",
+                  resource_property_case4);
+        }else{
+          PRINT("!!!!!!!!Invalid option chosen!!!!!!!!\n");
+          goto case4_label;
+        }
+      }else
+        PRINT("Read from scanf was unsuccessful\n");
+
+      switch(resourcePropertyOptionNumber){
+      case 1:
+        PRINT("\nResource type before updation: %s\n", resource->types.ptr);
+        resource->types.ptr = resource_property_case4;
+        PRINT("Resource type after updation: %s\n", resource->types.ptr);
+        break;
+
+      case 2:
+        PRINT("\nResource interface before updation: %d\n",
+              resource->interfaces);
+        resource->interfaces = resourceInterfaceIntegerValue;
+        PRINT("Resource interface after updation: %d\n", resource->interfaces);
+        break;
+
+      case 3:
+        PRINT("\nResource URI before updation: %s\n", resource->uri.ptr);
+        resource->uri.ptr = resource_property_case4;
+        PRINT("Resource URI after updation: %s\n", resource->uri.ptr);
+        break;
+
+      default:
+        PRINT("Entered 'default case' of switch statement\n");
+        break;
+      }
+    }
+  }
+}
+
+/* Following function takes a collection URI as input and obtains the
+collection's pointer and prints the collection name */
+static void
+findGroup(char *uri_input){
+  PRINT("\nFind Group option chosen\n");
+  PRINT("\nparameter passed: %s\n", uri_input);
+  oc_collection_t *tempCollection_findGroup =
+    oc_get_collection_by_uri(uri_input, strlen(uri_input), 0);
+  if(tempCollection_findGroup == NULL)
+    PRINT("\nGroup does not exist\n");
+  else
+    PRINT("\nGroup found. Collection name is %s\n\n",
+          tempCollection_findGroup->name.ptr);
+}
+
+void
+get_binaryswitchcb(oc_request_t *request, oc_interface_mask_t interfaces,
+                   void *user_data){
+  (void)user_data; // not used
+  PRINT("get_binaryswitch: interface %d\n", interfaces);
+  oc_rep_start_root_object();
+  switch(interfaces){
+  case OC_IF_BASELINE:
+  /* fall through */
+  case OC_IF_A:
+    PRINT("Adding Baseline info\n");
+    oc_process_baseline_interface(request->resource);
+    oc_rep_set_boolean(root, value, g_binaryswitch_valuecb);
+    PRINT("   %s : %d\n", g_binaryswitch_RESOURCE_PROPERTY_NAME_value,
+          g_binaryswitch_valuecb);
+    break;
+  default:
+    break;
+  }
+  oc_rep_end_root_object();
+  oc_send_response(request, OC_STATUS_OK);
+}
+
+/*binary switch call back */
+void
+post_binaryswitchcb(oc_request_t *request, oc_interface_mask_t interfaces,
+                    void *user_data){
+  (void)interfaces;
+  (void)user_data;
+  bool error_state = false;
+  PRINT("post_binaryswitch:\n");
+  oc_rep_t *rep = request->request_payload;
+  while(rep != NULL){
+    PRINT("key: (check) %s ", oc_string(rep->name));
+    if(strcmp(oc_string(rep->name),
+               g_binaryswitch_RESOURCE_PROPERTY_NAME_value) == 0){
+      /* value exists in payload */
+      if(rep->type != OC_REP_BOOL){
+        error_state = true;
+        PRINT("   property 'value' is not of type bool %d \n", rep->type);
+      }
+    }
+    rep = rep->next;
+  }
+  if(error_state == false){
+    oc_rep_t *rep = request->request_payload;
+    while(rep != NULL){
+      PRINT("key: (assign) %s ", oc_string(rep->name));
+      /* no error: assign the variables */
+      if(strcmp(oc_string(rep->name),
+                 g_binaryswitch_RESOURCE_PROPERTY_NAME_value) == 0){
+        /* assign value */
+        g_binaryswitch_valuecb = rep->value.boolean;
+      }
+      rep = rep->next;
+    }
+    /* set the response */
+    oc_rep_start_root_object();
+    oc_rep_set_boolean(root, value, g_binaryswitch_valuecb);
+    oc_rep_end_root_object();
+    oc_send_response(request, OC_STATUS_CHANGED);
+  }else{
+    /* TODO: add error response, if any */
+    oc_send_response(request, OC_STATUS_NOT_MODIFIED);
+  }
+}
+
+int
+app_init1(){
+  int ret = oc_init_platform(ENGLISH_NAME_VALUE, NULL, NULL);
+  ret |= oc_add_device("oic/d", "oic.d.airconditioner", "AirConditioner",
+                       OCF_SPEC_VERSION, OCF_DATA_MODEL_VERSION, NULL, NULL);
+  return ret;
+}
+
+/*using the  uri creating the air conditioner resource*/
+static void
+createSingleAirConResource(){
+  PRINT("Creating AirCon Device Resources!!\n");
+  if(g_isAirConDeviceCreated == false){
+    int init;
+    static const oc_handler_t handler ={
+      .init = app_init1,
+      .signal_event_loop = signal_event_loop,
+    };
+    init = oc_main_init(&handler);
+    if(init < 0)
+      PRINT("Not Able to Intialize the mainHandler");
+    oc_resource_t *res = oc_new_resource("AC-binaryswitch", RESOURCE_AIR_URI,
+                                         RESOURCE_INTERFACE, DEVICE_COUNT);
+    oc_resource_bind_resource_type(res, SWITCH_RESOURCE_TYPE);
+    for(int a = 0; a < RESOURCE_INTERFACE; a++){
+      oc_resource_bind_resource_interface(
+        res, convert_if_string(g_binaryswitch_AIRCON_RESOURCE_INTERFACE[a]));
+    }
+    oc_resource_set_discoverable(res, true);
+    oc_resource_set_periodic_observable(res, OBSERVE_PERIODIC);
+    oc_resource_set_request_handler(res, OC_GET, get_binaryswitchcb, NULL);
+    oc_resource_set_request_handler(res, OC_POST, post_binaryswitchcb, NULL);
+    bool add_res = oc_add_resource(res);
+    if(add_res == true){
+      PRINT("AirCon Binary Switch Resource created successfully\n");
+      g_isAirConDeviceCreated = true;
+    }else{
+      PRINT("Unable to create AirCon Binary Switch resource\n");
+    }
+  }else{
+    PRINT("Already Smart Home Air Conditioner Device Resource is created!!\n");
+  }
+}
+
+#ifdef OC_TCP
+static void
+pong_received_handler(oc_client_response_t *data){
+  if(data->code == OC_PING_TIMEOUT){
+    PRINT("PING timeout!\n");
+    ping_count++;
+    if(ping_count > PING_RETRY_COUNT){
+      PRINT("retry over. close connection.\n");
+      oc_connectivity_end_session(data->endpoint);
+    }else{
+      ping_timeout <<= 1;
+      PRINT("PING send again.[retry: %d, time: %u]\n", ping_count,
+            ping_timeout);
+      sendPingMessage(ping_timeout);
+    }
+  }else{
+    PRINT("PONG received:\n");
+    PRINTipaddr(*data->endpoint);
+    PRINT("\n");
+    ping_count = 0;
+  }
+}
+/* OC_TCP */
+
+static void
+sendPingMessage(uint16_t timeout_seconds){
+  (void)timeout_seconds;
+  if(ping_count == 255)
+    return;
+  printf("set remote address(ex. coap+tcp://xxx.xxx.xxx.xxx:yyyy): ");
+  if(RUN_MODE == MANUAL){
+     if(scanf("%s", address)){
+        printf("address: %s\n", address);
+        }
+    }
+  else{
+    strncpy(address,globalBuffer,OC_IPV6_ADDRSTRLEN + 8);
+  }
+  oc_string_t address_str;
+  oc_new_string(&address_str, address, strlen(address));
+
+  oc_string_to_endpoint(&address_str, &set_ep, NULL);
+  set_ep.version = OCF_VER_1_0_0;
+  oc_free_string(&address_str);
+#ifdef OC_TCP
+  if(set_ep.flags & TCP){
+    if(!oc_send_ping(0, &set_ep, timeout_seconds, pong_received_handler,
+                      NULL)){
+      PRINT("oc_send_ping failed\n");
+    }
+  }else
+#endif /* !OC_TCP */
+    {
+    PRINT("PING message is not supported\n");
+  }
+}
+#endif
+
+/*running the main poll inside the thread function*/
+static void *
+process_func(void *data){
+  (void)data;
+  oc_clock_time_t next_event;
+  while(quit != 1){
+    pthread_mutex_lock(&app_mutex);
+    next_event = oc_main_poll();
+    pthread_mutex_unlock(&app_mutex);
+    pthread_mutex_lock(&mutex);
+    if(next_event == 0){
+      fflush(stdout);
+      pthread_cond_wait(&cv, &mutex);
+    }else{
+      ts.tv_sec = (next_event / OC_CLOCK_SECOND);
+      ts.tv_nsec = (next_event % OC_CLOCK_SECOND) * 1.e09 / OC_CLOCK_SECOND;
+      pthread_cond_timedwait(&cv, &mutex, &ts);
+    }
+    pthread_mutex_unlock(&mutex);
+  }
+  pthread_exit(0);
+}
+
+#ifdef OC_SECURITY
+void
+random_pin_cb(const unsigned char *pin, size_t pin_len, void *data){
+  (void)data;
+  if(RUN_MODE == MANUAL){
+  PRINT("\n\nRandom PIN: %.*s\n\n", pin_len, pin);
+  }
+  else{
+      SendData((char*)pin);
+  }
+}
+#endif /* OC_SECURITY */
+
+#if defined(OC_SECURITY) && defined(OC_PKI)
+static int
+read_pem(const char *file_path, char *buffer, size_t *buffer_len)
+{
+  FILE *fp = fopen(file_path, "r");
+  if (fp == NULL) {
+    PRINT("ERROR: unable to read PEM\n");
+    return -1;
+  }
+  if (fseek(fp, 0, SEEK_END) != 0) {
+    PRINT("ERROR: unable to read PEM\n");
+    fclose(fp);
+    return -1;
+  }
+  long pem_len = ftell(fp);
+  if (pem_len < 0) {
+    PRINT("ERROR: could not obtain length of file\n");
+    fclose(fp);
+    return -1;
+  }
+  if (pem_len > (long)*buffer_len) {
+    PRINT("ERROR: buffer provided too small\n");
+    fclose(fp);
+    return -1;
+  }
+  if (fseek(fp, 0, SEEK_SET) != 0) {
+    PRINT("ERROR: unable to read PEM\n");
+    fclose(fp);
+    return -1;
+  }
+  if (fread(buffer, 1, pem_len, fp) < (size_t)pem_len) {
+    PRINT("ERROR: unable to read PEM\n");
+    fclose(fp);
+    return -1;
+  }
+  fclose(fp);
+  *buffer_len = (size_t)pem_len;
+  return 0;
+}
+#endif /* OC_SECURITY && OC_PKI */
+
+void
+factory_presets_cb(size_t device, void *data)
+{
+  (void)device;
+  (void)data;
+#if defined(OC_SECURITY) && defined(OC_PKI)
+  char cert[8192];
+  size_t cert_len = 8192;
+  if (read_pem("pki_certs/ee.pem", cert, &cert_len) < 0) {
+    PRINT("ERROR: unable to read certificates\n");
+    return;
+  }
+
+  char key[4096];
+  size_t key_len = 4096;
+  if (read_pem("pki_certs/key.pem", key, &key_len) < 0) {
+    PRINT("ERROR: unable to read private key");
+    return;
+  }
+
+  int ee_credid = oc_pki_add_mfg_cert(0, (const unsigned char *)cert, cert_len,
+                                      (const unsigned char *)key, key_len);
+
+  if (ee_credid < 0) {
+    PRINT("ERROR installing manufacturer EE cert\n");
+    return;
+  }
+
+  cert_len = 8192;
+  if (read_pem("pki_certs/subca1.pem", cert, &cert_len) < 0) {
+    PRINT("ERROR: unable to read certificates\n");
+    return;
+  }
+
+  int subca_credid = oc_pki_add_mfg_intermediate_cert(
+    0, ee_credid, (const unsigned char *)cert, cert_len);
+
+  if (subca_credid < 0) {
+    PRINT("ERROR installing intermediate CA cert\n");
+    return;
+  }
+
+  cert_len = 8192;
+  if (read_pem("pki_certs/rootca1.pem", cert, &cert_len) < 0) {
+    PRINT("ERROR: unable to read certificates\n");
+    return;
+  }
+
+  int rootca_credid =
+    oc_pki_add_mfg_trust_anchor(0, (const unsigned char *)cert, cert_len);
+  if (rootca_credid < 0) {
+    PRINT("ERROR installing root cert\n");
+    return;
+  }
+
+  oc_pki_set_security_profile(0, OC_SP_BLACK, OC_SP_BLACK, ee_credid);
+#endif /* OC_SECURITY && OC_PKI */
+}
+
+void getipaddress(oc_endpoint_t *ep, char *ipadd){
+        if ((*ep).flags & IPV4) {                                             \
+      sprintf(ipadd, "%d.%d.%d.%d:%d", ((*ep).addr.ipv4.address)[0],             \
+            ((*ep).addr.ipv4.address)[1],                                 \
+            ((*ep).addr.ipv4.address)[2],                                 \
+            ((*ep).addr.ipv4.address)[3],  (*ep).addr.ipv4.port);     \
+    } else {                                                                   \
+      sprintf(ipadd,                                                                    \
+        "%02x%02x::%02x%02x:%02x%02x:%02x%02x:%"    \
+        "02x%"                                                                 \
+        "02x:%d",                                                                 \
+        ((*ep).addr.ipv6.address)[0], ((*ep).addr.ipv6.address)[1],  \
+        ((*ep).addr.ipv6.address)[8], ((*ep).addr.ipv6.address)[9],  \
+        ((*ep).addr.ipv6.address)[10],                                    \
+        ((*ep).addr.ipv6.address)[11],                                    \
+        ((*ep).addr.ipv6.address)[12],                                    \
+        ((*ep).addr.ipv6.address)[13],                                    \
+        ((*ep).addr.ipv6.address)[14],                                    \
+        ((*ep).addr.ipv6.address)[15],   (*ep).addr.ipv6.port);                                   \
+    }
+}
+void printEndpointsList(){
+    int interfaceIndex;
+    int complete = 0;
+    oc_endpoint_t *ep;
+    ep = oc_connectivity_get_endpoints(0);
+    if(RUN_MODE == MANUAL){
+        printf("Please enter the Interface Index to get endpoint, then press Enter: ");
+        char inputBuff[64];
+        int interfaceIndex;
+        if(scanf("%s", inputBuff) >= 1){
+            sscanf(inputBuff,"%d",&interfaceIndex);
+            printf("Interface Index: %d\n",interfaceIndex);
+            complete = 1;
+        }
+    }
+    else{
+        sscanf(globalBuffer,"%d",&interfaceIndex);
+        complete = 1;
+        bufferUpdated = 0;
+  }
+  if(complete == 1){
+        int first = 0;
+        do {
+            if (ep != NULL){
+                if((ep->interface_index == interfaceIndex) && (first == 0)){
+                    printf("Endpoint CTT Discovery:");
+                    char ipstring[1024];
+                    getipaddress(ep,ipstring);
+                    SendData(ipstring);
+                    PRINTipaddr(*ep);
+                    PRINT("\n");
+                    first = 1;
+                    continue;
+                }
+                else{
+                    ep = ep->next;
+                }
+            }
+        }while(ep);
+    }
+    oc_free_endpoint(ep);
+}
+
+void SendData(char *cmd){
+int sockfd = 0;
+    struct sockaddr_in serv_addr;
+    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){
+        printf("\nCertApp_Error: Could not Create Socket \n");
+        return;
+    }
+    memset(&serv_addr, '0', sizeof(serv_addr));
+    serv_addr.sin_family = AF_INET;
+    serv_addr.sin_port = htons(5001);
+    if(inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr)<=0){
+        printf("\n inet_pton error occured\n");
+        return;
+    }
+    if( connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0){
+       printf("\nCertApp_Error: Connect Failed \n");
+       return;
+    }
+        printf("CertApp: Sending \"%s\" to TAFAgent\n", cmd);
+            if((send(sockfd,cmd, strlen(cmd),0))== -1){
+                fprintf(stderr, "Failure Sending Message\n");
+                close(sockfd);
+                return;
+        }
+       else{
+    }
+    close(sockfd);
+}
+int
+main(int argc, char *argv[]){
+    if( argc <= 4){
+        printf("Error: Wrong amount of arguments, should be:\n./CertificationApp QoS dummyIntVar security runMode\n\n");
+        goto exit;
+    }
+
+if(strcmp(argv[4], "manual") == 0)
+    RUN_MODE = MANUAL;
+else if(strcmp(argv[4], "auto") == 0)
+    RUN_MODE = AUTO;
+
+  struct sigaction sa;
+  sigfillset(&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_handler = handle_signal;
+  sigaction(SIGINT, &sa, NULL);
+  oc_set_con_res_announced(false);
+  oc_set_mtu_size(16384);
+  oc_set_max_app_data_size(16384);
+
+  int init;
+  static const oc_handler_t handler ={ .init = app_init,
+                                        .signal_event_loop = signal_event_loop
+#ifdef OC_CLIENT
+                                        ,
+                                        .requests_entry = 0
+#endif
+  };
+
+#ifdef OC_SECURITY
+  oc_storage_config("./CertificationApp_creds/");
+#endif /* OC_SECURITY */
+
+  oc_set_factory_presets_cb(factory_presets_cb, NULL);
+#ifdef OC_SECURITY
+  oc_set_random_pin_callback(random_pin_cb, NULL);
+#endif /* OC_SECURITY */
+    if(pthread_mutex_init(&mutex, NULL) < 0){
+        printf("pthread_mutex_init failed!\n");
+        return -1;
+    }
+    if(pthread_mutex_init(&app_mutex, NULL) < 0){
+        PRINT("pthread_mutex_init failed!\n");
+        pthread_mutex_destroy(&mutex);
+        return -1;
+    }
+
+  init = oc_main_init(&handler);
+  if(argc > 1){
+    int optionSelected = atoi(argv[1]);
+    if(optionSelected == 1){
+      PRINT("Using CON Server\n");
+      g_qos = HIGH_QOS;
+    }else if(optionSelected == 0){
+      PRINT("Using NON Server\n");
+    }else{
+      PRINT("Invalid input argument. Using default QoS: NON\n");
+    }
+  }else{
+    PRINT("No QoS supplied. Using default: NON\n");
+  }
+  if(argc > 2){
+    int optionSelected = atoi(argv[1]);
+    if(optionSelected == 2){
+      printf("option not implemented\n");
+    }
+  }
+#if defined(OC_SECURITY) && defined(OC_PKI)
+  if(argc > 3){
+    int optionSelected = atoi(argv[3]);
+    g_securityType = optionSelected % 10;
+
+    if(g_securityType == 3){
+      PRINT("Supported Security Mode: Manufacturing Certificate\n");
+      int credid =
+      oc_pki_add_mfg_cert(0, my_crt, sizeof(my_crt), my_key, sizeof(my_key));
+      oc_pki_add_mfg_intermediate_cert(0, credid, int_ca, sizeof(int_ca));
+      oc_pki_add_mfg_trust_anchor(0, root_ca, sizeof(root_ca));
+      oc_pki_set_security_profile(0, OC_SP_BLACK, OC_SP_BLACK, credid);
+    }
+  }
+
+#endif
+
+  if(init < 0)
+    return init;
+  pthread_t thread;
+  if(pthread_create(&thread, NULL, process_func, NULL) != 0){
+    PRINT("Failed to create main thread\n");
+    init = -1;
+    goto exit;
+  }
+
+if(RUN_MODE == MANUAL){
+  while(quit != 1){
+    showMenu(0, NULL);
+    /* Take the input from user and do the selected operation*/
+    handleMenu();
+  }
+}
+else{
+    int listenfd = 0, client_fd = 0;
+    struct sockaddr_in serv_addr;
+    struct sockaddr_in dest;
+    int num = 0;
+    char buffer[1025];
+    socklen_t size = 0;
+    int opt = 1;
+    listenfd = socket(AF_INET, SOCK_STREAM, 0);
+    setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR | SO_REUSEPORT,&opt,sizeof(opt));
+    memset(&serv_addr, '0', sizeof(serv_addr));
+    memset(buffer, '0', sizeof(buffer));
+    serv_addr.sin_family = AF_INET;
+    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
+    serv_addr.sin_port = htons(5000);
+    bind(listenfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
+    listen(listenfd, 10);
+    memset(globalBuffer,0,sizeof(globalBuffer));
+    printf("CertApp_Server: Started @ 5000\n");
+    while(quit != 1){
+        size = sizeof(struct sockaddr_in);
+        if((client_fd = accept(listenfd, (struct sockaddr *)&dest, &size))==-1 ){
+            perror("accept");
+            exit(1);
+        }
+
+        while(1){
+                 memset(buffer, '0', sizeof(buffer));
+                if((num = recv(client_fd, buffer, 1024,0))== -1){
+                        perror("recv");
+                        exit(1);
+                }
+                else if(num == 0){
+                        printf("CertApp_Server: Connection Closed\n");
+                        //So I can now wait for another client
+                        break;
+                }
+                buffer[num] = '\0';
+                memset(temp,0,sizeof(temp));
+                strncpy(temp,buffer,num);
+                printf("CertApp_Server: Command Received \"%s\" from TAFAgent\n", temp);
+                const char s[2] = ",";
+                char *token;
+                int first = 0;
+                /* get the first token */
+                token = strtok(temp, s);
+                /* walk through other tokens */
+                while( token != NULL ){
+                    //printf( "token: %s\n", token );
+                    if(first == 0){
+                        sscanf(token,"%d",&gChoiceInt);
+                        inChoice = 1;
+                        first = 1;
+                    }
+                else{
+                        strncpy(globalBuffer,token,strlen(token));
+                        //printf("globalBuffer:%s\n",globalBuffer);
+                    }
+                    token = strtok(NULL, s);
+                }
+                if(inChoice == 1){
+                    selectMenu(gChoiceInt);
+                    inChoice = 0;
+                 }
+                break;
+        } //End of Inner While...
+        close(client_fd);
+    } //Outer While
+
+   close(listenfd);
+}
+exit:
+  oc_free_string(&name);
+  free_all_buffer();
+  oc_collection_free(collectionPointer);
+  oc_main_shutdown();
+  pthread_mutex_destroy(&mutex);
+  pthread_mutex_destroy(&app_mutex);
+
+  return 0;
+}
+
+/*Entering option no  as choice to execute operation*/
+void
+handleMenu(){
+  char choice[10];
+  bool wrongchoice = false;
+  int decimal = 0;
+  int choiceInt = 0;
+  do{
+    do{
+      if(scanf("%s", choice)){
+        int choiceLength = strlen(choice);
+        for(int i = 0; i < choiceLength && (quit == 0); i++){
+          if(isdigit(choice[i])){
+            wrongchoice = false;
+            decimal = 10 * decimal + (choice[i] - '0');
+            choiceInt = decimal;
+          }else{
+            printf("Invalid Input. Please select the choice from selectMenu\n");
+            wrongchoice = true;
+            decimal = 0;
+            break;
+          }
+        }
+        decimal = 0;
+      }
+    }while(wrongchoice && (quit == 0));
+    if(!quit){
+      selectMenu(choiceInt);
+      showMenu(0, NULL);
+    }
+  }while(choiceInt && (quit == 0));
+}
diff --git a/apps/CertificationApp.json b/apps/CertificationApp.json
new file mode 100644
index 00000000..93a9065e
--- /dev/null
+++ b/apps/CertificationApp.json
@@ -0,0 +1,32 @@
+{
+    "device": "test1",
+    "company": "Open Connectivity Foundation",
+    "role": "Server",
+    "supportedVerticalProfile": [
+        "Smart Home"
+    ],
+    "supportedDeviceTypes": [
+        "None"
+    ],
+    "icv": "ocf.1.0.0",
+    "dmv": "ocf.res.1.3.0, ocf.sh.1.3.0",
+    "resources": [
+        "oic.r.csr",
+        "oic.r.crl",
+        "oic.r.roles",
+
+        "oic.r.switch.binary",
+
+        "oic.r.humidity"
+],
+    "jurisdictionSwitch": false,
+    "OTM": [
+        "oic.sec.doxm.jw"
+    ],
+    "contentFormatVersion": [ "1.0.0" ],
+    "acceptVersion": [ "1.0.0" ],
+
+    "multiValueQuerySupport": false,
+    "observableOICRES": false,
+    "persistentDeviceuuid": false
+}
\ No newline at end of file
diff --git a/apps/CertificationApp_Example.json b/apps/CertificationApp_Example.json
new file mode 100644
index 00000000..8881114a
--- /dev/null
+++ b/apps/CertificationApp_Example.json
@@ -0,0 +1,22 @@
+[
+
+    {
+      "path" : "/binaryswitch",
+      "rt"   : [ "oic.r.switch.binary" ],
+      "if"   : ["oic.if.a", "oic.if.baseline" ],
+      "remove_properties" : [ "range", "step" , "id", "precision" ]
+    },
+    {
+      "path" : "/oic/p",
+      "rt"   : [ "oic.wk.p" ],
+      "if"   : ["oic.if.baseline", "oic.if.r" ],
+      "remove_properties" : [ "n", "range", "value", "step", "precision", "vid"  ]
+    },
+    {
+      "path" : "/humidity",
+      "rt"   : [ "oic.r.humidity" ],
+      "if"   : ["oic.if.a", "oic.if.baseline" ],
+      "remove_properties" : [ "range", "step" , "id", "precision" ]
+    }
+
+]
\ No newline at end of file
diff --git a/apps/device_builder_server.c b/apps/device_builder_server.c
new file mode 100644
index 00000000..d9cc8a9c
--- /dev/null
+++ b/apps/device_builder_server.c
@@ -0,0 +1,1354 @@
+//******************************************************************
+//
+// Copyright 2017 Open Connectivity Foundation
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=/
+
+/* Application Design
+*
+* support functions:
+* app_init
+*  initializes the oic/p and oic/d values.
+* register_resources
+*  function that registers all endpoints, e.g. sets the RETRIEVE/UPDATE handlers for each end point
+*
+* main
+*  starts the stack, with the registered resources.
+*
+* Each endpoint has:
+*  global variables for:
+*    the property name
+*       naming convention: g_<path>_RESOURCE_PROPERTY_NAME_<propertyname>
+*    the actual value of the property, which is typed from the json data type
+*      naming convention: g_<path>_<propertyname>
+*    the path in a variable:
+*      naming convention: g_<path>_RESOURCE_ENDPOINT
+*    array of interfaces, where by the first will be set as default interface
+*      naming convention g_<path>_RESOURCE_INTERFACE
+*
+*  handlers for the implemented methods (get/post)
+*   get_<path>
+*     function that is being called when a RETRIEVE is called on <path>
+*     set the global variables in the output
+*   post_<path>
+*     function that is being called when a UPDATE is called on <path>
+*     checks the input data
+*     if input data is correct
+*       updates the global variables
+*
+*/
+/*
+ tool_version          : 20171123
+ input_file            : ../device_output/out_codegeneration_merged.swagger.json
+ version of input_file : v1.1.0-20160519
+ title of input_file   : Binary Switch
+*/
+
+#include "oc_api.h"
+#include "port/oc_clock.h"
+#include <signal.h>
+#include <stdint.h>
+
+#ifdef __linux__
+// linux specific code
+#include <pthread.h>
+
+#endif
+
+#ifdef WIN32
+// windows specific code
+#include <windows.h>
+static CONDITION_VARIABLE cv;   // event loop variable
+static CRITICAL_SECTION cs;     // event loop variable
+#endif
+
+#define MAX_STRING 65   // max size of the strings.
+volatile int quit = 0;  // stop variable, used by handle_signal
+pthread_mutex_t mutex;
+pthread_cond_t cv;
+struct timespec ts;
+
+// global variables for path: /binaryswitch
+static char g_binaryswitch_RESOURCE_PROPERTY_NAME_value[] = "value"; // the name for the attribute
+bool g_binaryswitch_value = false; // current value of property "value" Status of the switch
+
+// global variables for path: /humidity
+static char g_humidity_RESOURCE_PROPERTY_NAME_desiredHumidity[] = "desiredHumidity"; // the name for the attribute
+int g_humidity_desiredHumidity = 40; // current value of property "desiredHumidity" Desired value for Humidity
+
+static char g_humidity_RESOURCE_PROPERTY_NAME_humidity[] = "humidity"; // the name for the attribute
+int g_humidity_humidity = 40; // current value of property "humidity" Current sensed value for Humidity
+
+/*
+static char g_dimming_RESOURCE_PROPERTY_NAME_dimmingSetting[] = "dimmingSetting"; // the name for the attribute
+int g_dimming_dimmingSetting = 20; // current value of property "dimmingSetting" Current sensed value for Dimming
+*/
+
+// registration data variables for the resources
+static char g_binaryswitch_RESOURCE_ENDPOINT[] = "/binaryswitch";  // used path for this resource
+static char g_binaryswitch_RESOURCE_TYPE[][MAX_STRING] = {"oic.r.switch.binary"}; // rt value (as an array)
+int g_binaryswitch_nr_resource_types = 1;
+static char g_binaryswitch_RESOURCE_INTERFACE[][MAX_STRING] = {"oic.if.a","oic.if.baseline"}; // interface if (as an array)
+int g_binaryswitch_nr_resource_interfaces = 2;
+
+static char g_humidity_RESOURCE_ENDPOINT[] = "/humidity";  // used path for this resource
+static char g_humidity_RESOURCE_TYPE[][MAX_STRING] = {"oic.r.humidity"}; // rt value (as an array)
+int g_humidity_nr_resource_types = 1;
+static char g_humidity_RESOURCE_INTERFACE[][MAX_STRING] = {"oic.if.a","oic.if.baseline"}; // interface if (as an array)
+int g_humidity_nr_resource_interfaces = 2;
+
+/*
+static char g_dimming_RESOURCE_ENDPOINT[] = "/dimming";  // used path for this resource
+static char g_dimming_RESOURCE_TYPE[][MAX_STRING] = {"oic.r.light.dimming"}; // rt value (as an array)
+int g_dimming_nr_resource_types = 1;
+static char g_dimming_RESOURCE_INTERFACE[][MAX_STRING] = {"oic.if.a","oic.if.baseline"}; // interface if (as an array)
+int g_dimming_nr_resource_interfaces = 2;
+*/
+
+const char *mfg_persistent_uuid = "0ae59256-4e5e-4463-81b7-e1edcfb98287";
+
+#ifdef OC_IDD_API
+
+void oc_set_introspection_data(size_t, uint8_t*, size_t);
+
+#define introspection_data_size 7505  /* size of the CBOR */
+uint8_t introspection_data[] = {
+ 0xa8, 0x67, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x73, 0x81, 0x64, 0x68,
+ 0x74, 0x74, 0x70, 0x67, 0x73, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x63,
+ 0x32, 0x2e, 0x30, 0x65, 0x70, 0x61, 0x74, 0x68, 0x73, 0xa3, 0x71, 0x2f,
+ 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65,
+ 0x73, 0x55, 0x52, 0x49, 0xa1, 0x63, 0x67, 0x65, 0x74, 0xa3, 0x69, 0x72,
+ 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0xa1, 0x63, 0x32, 0x30,
+ 0x30, 0xa2, 0x66, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0xa1, 0x64, 0x24,
+ 0x72, 0x65, 0x66, 0x77, 0x23, 0x2f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69,
+ 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x73, 0x62, 0x61, 0x73, 0x65, 0x6c,
+ 0x69, 0x6e, 0x65, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65,
+ 0x74, 0x65, 0x72, 0x73, 0x81, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66, 0x78,
+ 0x1a, 0x23, 0x2f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
+ 0x73, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x2d,
+ 0x61, 0x6c, 0x6c, 0x6d, 0x2f, 0x62, 0x69, 0x6e, 0x61, 0x72, 0x79, 0x73,
+ 0x77, 0x69, 0x74, 0x63, 0x68, 0xa2, 0x64, 0x70, 0x6f, 0x73, 0x74, 0xa3,
+ 0x69, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0xa1, 0x63,
+ 0x32, 0x30, 0x30, 0xa2, 0x66, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0xa1,
+ 0x64, 0x24, 0x72, 0x65, 0x66, 0x78, 0x1a, 0x23, 0x2f, 0x64, 0x65, 0x66,
+ 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x42, 0x69, 0x6e,
+ 0x61, 0x72, 0x79, 0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x64,
+ 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a,
+ 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x82, 0xa1,
+ 0x64, 0x24, 0x72, 0x65, 0x66, 0x76, 0x23, 0x2f, 0x70, 0x61, 0x72, 0x61,
+ 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72,
+ 0x66, 0x61, 0x63, 0x65, 0xa4, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72,
+ 0x65, 0x64, 0xf5, 0x62, 0x69, 0x6e, 0x64, 0x62, 0x6f, 0x64, 0x79, 0x66,
+ 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66,
+ 0x78, 0x1a, 0x23, 0x2f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69,
+ 0x6f, 0x6e, 0x73, 0x2f, 0x42, 0x69, 0x6e, 0x61, 0x72, 0x79, 0x53, 0x77,
+ 0x69, 0x74, 0x63, 0x68, 0x64, 0x6e, 0x61, 0x6d, 0x65, 0x64, 0x62, 0x6f,
+ 0x64, 0x79, 0x63, 0x67, 0x65, 0x74, 0xa3, 0x69, 0x72, 0x65, 0x73, 0x70,
+ 0x6f, 0x6e, 0x73, 0x65, 0x73, 0xa1, 0x63, 0x32, 0x30, 0x30, 0xa2, 0x66,
+ 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66,
+ 0x78, 0x1a, 0x23, 0x2f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69,
+ 0x6f, 0x6e, 0x73, 0x2f, 0x42, 0x69, 0x6e, 0x61, 0x72, 0x79, 0x53, 0x77,
+ 0x69, 0x74, 0x63, 0x68, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70, 0x61, 0x72, 0x61, 0x6d,
+ 0x65, 0x74, 0x65, 0x72, 0x73, 0x81, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66,
+ 0x76, 0x23, 0x2f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
+ 0x73, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x69,
+ 0x2f, 0x68, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0xa2, 0x64, 0x70,
+ 0x6f, 0x73, 0x74, 0xa3, 0x69, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
+ 0x65, 0x73, 0xa1, 0x63, 0x32, 0x30, 0x30, 0xa2, 0x66, 0x73, 0x63, 0x68,
+ 0x65, 0x6d, 0x61, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66, 0x78, 0x1c, 0x23,
+ 0x2f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73,
+ 0x2f, 0x48, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x55, 0x70, 0x64,
+ 0x61, 0x74, 0x65, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65,
+ 0x74, 0x65, 0x72, 0x73, 0x82, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66, 0x76,
+ 0x23, 0x2f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73,
+ 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0xa4, 0x68,
+ 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0xf5, 0x62, 0x69, 0x6e,
+ 0x64, 0x62, 0x6f, 0x64, 0x79, 0x66, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61,
+ 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66, 0x78, 0x1c, 0x23, 0x2f, 0x64, 0x65,
+ 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x48, 0x75,
+ 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
+ 0x64, 0x6e, 0x61, 0x6d, 0x65, 0x64, 0x62, 0x6f, 0x64, 0x79, 0x63, 0x67,
+ 0x65, 0x74, 0xa3, 0x69, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
+ 0x73, 0xa1, 0x63, 0x32, 0x30, 0x30, 0xa2, 0x66, 0x73, 0x63, 0x68, 0x65,
+ 0x6d, 0x61, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66, 0x76, 0x23, 0x2f, 0x64,
+ 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x48,
+ 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x6b, 0x64, 0x65, 0x73, 0x63,
+ 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x64, 0x65, 0x73,
+ 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70, 0x61,
+ 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x81, 0xa1, 0x64, 0x24,
+ 0x72, 0x65, 0x66, 0x76, 0x23, 0x2f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65,
+ 0x74, 0x65, 0x72, 0x73, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61,
+ 0x63, 0x65, 0x6a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
+ 0x73, 0xa3, 0x6d, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65,
+ 0x2d, 0x61, 0x6c, 0x6c, 0xa4, 0x62, 0x69, 0x6e, 0x65, 0x71, 0x75, 0x65,
+ 0x72, 0x79, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69,
+ 0x6e, 0x67, 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x83, 0x69, 0x6f, 0x69, 0x63,
+ 0x2e, 0x69, 0x66, 0x2e, 0x6c, 0x6c, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69,
+ 0x66, 0x2e, 0x62, 0x6f, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62,
+ 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x64, 0x6e, 0x61, 0x6d, 0x65,
+ 0x62, 0x69, 0x66, 0x69, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63,
+ 0x65, 0xa4, 0x62, 0x69, 0x6e, 0x65, 0x71, 0x75, 0x65, 0x72, 0x79, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x64,
+ 0x65, 0x6e, 0x75, 0x6d, 0x82, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66,
+ 0x2e, 0x61, 0x6f, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x61,
+ 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x64, 0x6e, 0x61, 0x6d, 0x65, 0x62,
+ 0x69, 0x66, 0x70, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65,
+ 0x2d, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0xa4, 0x62, 0x69, 0x6e, 0x65,
+ 0x71, 0x75, 0x65, 0x72, 0x79, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73,
+ 0x74, 0x72, 0x69, 0x6e, 0x67, 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x83, 0x69,
+ 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x6c, 0x6c, 0x68, 0x6f, 0x69,
+ 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x6f, 0x6f, 0x69, 0x63, 0x2e, 0x69,
+ 0x66, 0x2e, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x64, 0x6e,
+ 0x61, 0x6d, 0x65, 0x62, 0x69, 0x66, 0x64, 0x69, 0x6e, 0x66, 0x6f, 0xa4,
+ 0x65, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x6d, 0x42, 0x69, 0x6e, 0x61, 0x72,
+ 0x79, 0x20, 0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 0x6e, 0x74, 0x65, 0x72,
+ 0x6d, 0x73, 0x4f, 0x66, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x78,
+ 0x3f, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x6f, 0x70, 0x65,
+ 0x6e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74,
+ 0x79, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
+ 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x69, 0x6f, 0x2f, 0x63, 0x6f,
+ 0x72, 0x65, 0x2f, 0x44, 0x49, 0x53, 0x43, 0x4c, 0x41, 0x49, 0x4d, 0x45,
+ 0x52, 0x2e, 0x6d, 0x64, 0x67, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65,
+ 0xa3, 0x63, 0x75, 0x72, 0x6c, 0x78, 0x6b, 0x68, 0x74, 0x74, 0x70, 0x73,
+ 0x3a, 0x2f, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f,
+ 0x6d, 0x2f, 0x6f, 0x70, 0x65, 0x6e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
+ 0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x61,
+ 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x62, 0x6c,
+ 0x6f, 0x62, 0x2f, 0x65, 0x32, 0x38, 0x61, 0x39, 0x65, 0x30, 0x61, 0x39,
+ 0x32, 0x65, 0x31, 0x37, 0x30, 0x34, 0x32, 0x62, 0x61, 0x33, 0x65, 0x38,
+ 0x33, 0x36, 0x36, 0x31, 0x65, 0x34, 0x63, 0x30, 0x66, 0x62, 0x63, 0x65,
+ 0x38, 0x62, 0x64, 0x63, 0x34, 0x62, 0x61, 0x2f, 0x4c, 0x49, 0x43, 0x45,
+ 0x4e, 0x53, 0x45, 0x2e, 0x6d, 0x64, 0x64, 0x6e, 0x61, 0x6d, 0x65, 0x76,
+ 0x4f, 0x43, 0x46, 0x20, 0x44, 0x61, 0x74, 0x61, 0x20, 0x4d, 0x6f, 0x64,
+ 0x65, 0x6c, 0x20, 0x4c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x6b, 0x78,
+ 0x2d, 0x63, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x78, 0x4b,
+ 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x32, 0x30,
+ 0x31, 0x38, 0x2d, 0x32, 0x30, 0x31, 0x39, 0x20, 0x4f, 0x70, 0x65, 0x6e,
+ 0x20, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74,
+ 0x79, 0x20, 0x46, 0x6f, 0x75, 0x6e, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e,
+ 0x2c, 0x20, 0x49, 0x6e, 0x63, 0x2e, 0x20, 0x41, 0x6c, 0x6c, 0x20, 0x72,
+ 0x69, 0x67, 0x68, 0x74, 0x73, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76,
+ 0x65, 0x64, 0x2e, 0x67, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x68,
+ 0x32, 0x30, 0x31, 0x39, 0x30, 0x32, 0x32, 0x32, 0x6b, 0x64, 0x65, 0x66,
+ 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0xaa, 0x6c, 0x42, 0x69,
+ 0x6e, 0x61, 0x72, 0x79, 0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 0xa3, 0x68,
+ 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x81, 0x65, 0x76, 0x61,
+ 0x6c, 0x75, 0x65, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69,
+ 0x65, 0x73, 0xa4, 0x62, 0x72, 0x74, 0xa7, 0x6b, 0x64, 0x65, 0x73, 0x63,
+ 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75, 0x6e, 0x69,
+ 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x65, 0x69, 0x74, 0x65,
+ 0x6d, 0x73, 0xa3, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74,
+ 0x68, 0x18, 0x40, 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x81, 0x73, 0x6f, 0x69,
+ 0x63, 0x2e, 0x72, 0x2e, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x2e, 0x62,
+ 0x69, 0x6e, 0x61, 0x72, 0x79, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73,
+ 0x74, 0x72, 0x69, 0x6e, 0x67, 0x67, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c,
+ 0x74, 0x81, 0x73, 0x6f, 0x69, 0x63, 0x2e, 0x72, 0x2e, 0x73, 0x77, 0x69,
+ 0x74, 0x63, 0x68, 0x2e, 0x62, 0x69, 0x6e, 0x61, 0x72, 0x79, 0x68, 0x72,
+ 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x68, 0x6d, 0x69, 0x6e,
+ 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x65, 0x76, 0x61, 0x6c, 0x75, 0x65,
+ 0xa2, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
+ 0x6e, 0x60, 0x64, 0x74, 0x79, 0x70, 0x65, 0x67, 0x62, 0x6f, 0x6f, 0x6c,
+ 0x65, 0x61, 0x6e, 0x61, 0x6e, 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
+ 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x69, 0x6d, 0x61, 0x78, 0x4c,
+ 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x68, 0x72, 0x65, 0x61, 0x64,
+ 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73,
+ 0x74, 0x72, 0x69, 0x6e, 0x67, 0x62, 0x69, 0x66, 0xa6, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75,
+ 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x65,
+ 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x82,
+ 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x61, 0x6f, 0x6f, 0x69,
+ 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e,
+ 0x65, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e,
+ 0x67, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x2, 0x68,
+ 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x72, 0x73, 0x62, 0x61,
+ 0x74, 0x63, 0x68, 0x2d, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x69,
+ 0x74, 0x65, 0x6d, 0xa5, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65,
+ 0x64, 0x82, 0x64, 0x68, 0x72, 0x65, 0x66, 0x63, 0x72, 0x65, 0x70, 0x74,
+ 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72,
+ 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xf5, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70,
+ 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xa2, 0x63, 0x72,
+ 0x65, 0x70, 0xa0, 0x64, 0x68, 0x72, 0x65, 0x66, 0xa4, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x66,
+ 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x63, 0x75, 0x72, 0x69, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d, 0x61,
+ 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x19, 0x1, 0x0, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x70, 0x73,
+ 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x2d, 0x75, 0x70, 0x64,
+ 0x61, 0x74, 0x65, 0xa0, 0x6f, 0x73, 0x62, 0x61, 0x74, 0x63, 0x68, 0x2d,
+ 0x72, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76, 0x65, 0xa3, 0x65, 0x69, 0x74,
+ 0x65, 0x6d, 0x73, 0xa4, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65,
+ 0x64, 0x82, 0x64, 0x68, 0x72, 0x65, 0x66, 0x63, 0x72, 0x65, 0x70, 0x74,
+ 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72,
+ 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xf5, 0x6a, 0x70, 0x72,
+ 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xa2, 0x63, 0x72, 0x65,
+ 0x70, 0xa0, 0x64, 0x68, 0x72, 0x65, 0x66, 0xa4, 0x6b, 0x64, 0x65, 0x73,
+ 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x66, 0x6f,
+ 0x72, 0x6d, 0x61, 0x74, 0x63, 0x75, 0x72, 0x69, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d, 0x61, 0x78,
+ 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x19, 0x1, 0x0, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x68, 0x6d, 0x69, 0x6e,
+ 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x6c, 0x6f, 0x69, 0x63, 0x2e, 0x6f,
+ 0x69, 0x63, 0x2d, 0x6c, 0x69, 0x6e, 0x6b, 0xa3, 0x68, 0x72, 0x65, 0x71,
+ 0x75, 0x69, 0x72, 0x65, 0x64, 0x81, 0x64, 0x68, 0x72, 0x65, 0x66, 0x6a,
+ 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xae, 0x61,
+ 0x70, 0xa4, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x81,
+ 0x62, 0x62, 0x6d, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74,
+ 0x69, 0x65, 0x73, 0xa1, 0x62, 0x62, 0x6d, 0xa2, 0x6b, 0x64, 0x65, 0x73,
+ 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x62, 0x64,
+ 0x69, 0xa3, 0x67, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x78, 0x4d,
+ 0x5e, 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d,
+ 0x7b, 0x38, 0x7d, 0x2d, 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30,
+ 0x2d, 0x39, 0x5d, 0x7b, 0x34, 0x7d, 0x2d, 0x5b, 0x61, 0x2d, 0x66, 0x41,
+ 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x34, 0x7d, 0x2d, 0x5b, 0x61,
+ 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x34, 0x7d,
+ 0x2d, 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d,
+ 0x7b, 0x31, 0x32, 0x7d, 0x24, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
+ 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6d, 0x74, 0x61, 0x67, 0x2d, 0x66,
+ 0x75, 0x6e, 0x63, 0x2d, 0x64, 0x65, 0x73, 0x63, 0xa3, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x72,
+ 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x66, 0x61, 0x6e, 0x63,
+ 0x68, 0x6f, 0x72, 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,
+ 0x63, 0x75, 0x72, 0x69, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74,
+ 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67,
+ 0x74, 0x68, 0x19, 0x1, 0x0, 0x62, 0x72, 0x74, 0xa6, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75,
+ 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x65,
+ 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65,
+ 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
+ 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74,
+ 0x65, 0x6d, 0x73, 0x1, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c,
+ 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61,
+ 0x79, 0x62, 0x69, 0x66, 0xa6, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75, 0x6e, 0x69, 0x71, 0x75,
+ 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x65, 0x69, 0x74, 0x65, 0x6d,
+ 0x73, 0xa3, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68,
+ 0x18, 0x40, 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x87, 0x6f, 0x6f, 0x69, 0x63,
+ 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65,
+ 0x69, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x6c, 0x6c, 0x68, 0x6f,
+ 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x69, 0x6f, 0x69, 0x63, 0x2e,
+ 0x69, 0x66, 0x2e, 0x72, 0x77, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66,
+ 0x2e, 0x72, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x61, 0x68,
+ 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x73, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x68, 0x6d, 0x69, 0x6e,
+ 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f,
+ 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72,
+ 0x72, 0x61, 0x79, 0x63, 0x72, 0x65, 0x6c, 0xa5, 0x65, 0x69, 0x74, 0x65,
+ 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74,
+ 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72,
+ 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d,
+ 0x73, 0x1, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61,
+ 0x79, 0x67, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x81, 0x65, 0x68,
+ 0x6f, 0x73, 0x74, 0x73, 0x64, 0x68, 0x72, 0x65, 0x66, 0xa4, 0x6b, 0x64,
+ 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66,
+ 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x63, 0x75, 0x72, 0x69, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d,
+ 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x19, 0x1, 0x0, 0x6c,
+ 0x74, 0x61, 0x67, 0x2d, 0x70, 0x6f, 0x73, 0x2d, 0x64, 0x65, 0x73, 0x63,
+ 0xa2, 0x65, 0x61, 0x6c, 0x6c, 0x4f, 0x66, 0x82, 0xa1, 0x64, 0x24, 0x72,
+ 0x65, 0x66, 0x78, 0x33, 0x6f, 0x69, 0x63, 0x2e, 0x74, 0x79, 0x70, 0x65,
+ 0x73, 0x2d, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x6a, 0x73, 0x6f,
+ 0x6e, 0x23, 0x2f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f,
+ 0x6e, 0x73, 0x2f, 0x70, 0x6f, 0x73, 0x2d, 0x64, 0x65, 0x73, 0x63, 0x72,
+ 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0xa1, 0x68, 0x72, 0x65, 0x61,
+ 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
+ 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x74, 0x61, 0x67, 0x2d,
+ 0x70, 0x6f, 0x73, 0x2d, 0x72, 0x65, 0x6c, 0xa6, 0x6b, 0x64, 0x65, 0x73,
+ 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x6d, 0x61,
+ 0x78, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x3, 0x65, 0x69, 0x74, 0x65, 0x6d,
+ 0x73, 0xa3, 0x67, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x1, 0x67,
+ 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x20, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x68, 0x72, 0x65, 0x61, 0x64,
+ 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65,
+ 0x6d, 0x73, 0x3, 0x65, 0x74, 0x69, 0x74, 0x6c, 0x65, 0xa3, 0x6b, 0x64,
+ 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x69,
+ 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0xa5, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2,
+ 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40,
+ 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
+ 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
+ 0x60, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x67, 0x64,
+ 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x78, 0x18, 0x61, 0x70, 0x70, 0x6c,
+ 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x76, 0x6e, 0x64, 0x2e,
+ 0x6f, 0x63, 0x66, 0x2b, 0x63, 0x62, 0x6f, 0x72, 0x63, 0x65, 0x70, 0x73,
+ 0xa3, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x6a, 0x70, 0x72, 0x6f,
+ 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xa2, 0x62, 0x65, 0x70, 0xa3,
+ 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
+ 0x60, 0x66, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x63, 0x75, 0x72, 0x69,
+ 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
+ 0x63, 0x70, 0x72, 0x69, 0xa3, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x67, 0x6d, 0x69, 0x6e, 0x69, 0x6d,
+ 0x75, 0x6d, 0x1, 0x64, 0x74, 0x79, 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74,
+ 0x65, 0x67, 0x65, 0x72, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62,
+ 0x6a, 0x65, 0x63, 0x74, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61,
+ 0x72, 0x72, 0x61, 0x79, 0x63, 0x69, 0x6e, 0x73, 0xa2, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x66,
+ 0x73, 0x6c, 0x69, 0x6e, 0x6b, 0x73, 0xa2, 0x65, 0x69, 0x74, 0x65, 0x6d,
+ 0x73, 0xa3, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x81,
+ 0x64, 0x68, 0x72, 0x65, 0x66, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72,
+ 0x74, 0x69, 0x65, 0x73, 0xae, 0x61, 0x70, 0xa4, 0x68, 0x72, 0x65, 0x71,
+ 0x75, 0x69, 0x72, 0x65, 0x64, 0x81, 0x62, 0x62, 0x6d, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70,
+ 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xa1, 0x62, 0x62,
+ 0x6d, 0xa2, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
+ 0x6f, 0x6e, 0x60, 0x64, 0x74, 0x79, 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74,
+ 0x65, 0x67, 0x65, 0x72, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62,
+ 0x6a, 0x65, 0x63, 0x74, 0x62, 0x64, 0x69, 0xa3, 0x67, 0x70, 0x61, 0x74,
+ 0x74, 0x65, 0x72, 0x6e, 0x78, 0x4d, 0x5e, 0x5b, 0x61, 0x2d, 0x66, 0x41,
+ 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x38, 0x7d, 0x2d, 0x5b, 0x61,
+ 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x34, 0x7d,
+ 0x2d, 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d,
+ 0x7b, 0x34, 0x7d, 0x2d, 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30,
+ 0x2d, 0x39, 0x5d, 0x7b, 0x34, 0x7d, 0x2d, 0x5b, 0x61, 0x2d, 0x66, 0x41,
+ 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x31, 0x32, 0x7d, 0x24, 0x6b,
+ 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60,
+ 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
+ 0x6d, 0x74, 0x61, 0x67, 0x2d, 0x66, 0x75, 0x6e, 0x63, 0x2d, 0x64, 0x65,
+ 0x73, 0x63, 0xa3, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c,
+ 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69,
+ 0x6e, 0x67, 0x66, 0x61, 0x6e, 0x63, 0x68, 0x6f, 0x72, 0xa4, 0x6b, 0x64,
+ 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66,
+ 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x63, 0x75, 0x72, 0x69, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d,
+ 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x19, 0x1, 0x0, 0x62,
+ 0x72, 0x74, 0xa6, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49,
+ 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2,
+ 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40,
+ 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
+ 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x68, 0x72,
+ 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x62, 0x69, 0x66, 0xa6, 0x6b,
+ 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60,
+ 0x6b, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73,
+ 0xf5, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa3, 0x69, 0x6d, 0x61, 0x78,
+ 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x65, 0x6e, 0x75,
+ 0x6d, 0x87, 0x6f, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x61,
+ 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x69, 0x6f, 0x69, 0x63, 0x2e, 0x69,
+ 0x66, 0x2e, 0x6c, 0x6c, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e,
+ 0x62, 0x69, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x72, 0x77, 0x68,
+ 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x72, 0x68, 0x6f, 0x69, 0x63,
+ 0x2e, 0x69, 0x66, 0x2e, 0x61, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66,
+ 0x2e, 0x73, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69,
+ 0x6e, 0x67, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1,
+ 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x63, 0x72, 0x65,
+ 0x6c, 0xa5, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61,
+ 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x6d,
+ 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x67, 0x64, 0x65, 0x66, 0x61,
+ 0x75, 0x6c, 0x74, 0x81, 0x65, 0x68, 0x6f, 0x73, 0x74, 0x73, 0x64, 0x68,
+ 0x72, 0x65, 0x66, 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,
+ 0x63, 0x75, 0x72, 0x69, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74,
+ 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67,
+ 0x74, 0x68, 0x19, 0x1, 0x0, 0x6c, 0x74, 0x61, 0x67, 0x2d, 0x70, 0x6f,
+ 0x73, 0x2d, 0x64, 0x65, 0x73, 0x63, 0xa2, 0x65, 0x61, 0x6c, 0x6c, 0x4f,
+ 0x66, 0x82, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66, 0x78, 0x33, 0x6f, 0x69,
+ 0x63, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2d, 0x73, 0x63, 0x68, 0x65,
+ 0x6d, 0x61, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x23, 0x2f, 0x64, 0x65, 0x66,
+ 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x70, 0x6f, 0x73,
+ 0x2d, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
+ 0x73, 0xa1, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5,
+ 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
+ 0x60, 0x6b, 0x74, 0x61, 0x67, 0x2d, 0x70, 0x6f, 0x73, 0x2d, 0x72, 0x65,
+ 0x6c, 0xa6, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
+ 0x6f, 0x6e, 0x60, 0x68, 0x6d, 0x61, 0x78, 0x49, 0x74, 0x65, 0x6d, 0x73,
+ 0x3, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa3, 0x67, 0x6d, 0x61, 0x78,
+ 0x69, 0x6d, 0x75, 0x6d, 0x1, 0x67, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75,
+ 0x6d, 0x20, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6e, 0x75, 0x6d, 0x62,
+ 0x65, 0x72, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61,
+ 0x79, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x68,
+ 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x3, 0x65, 0x74, 0x69,
+ 0x74, 0x6c, 0x65, 0xa3, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e,
+ 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73,
+ 0x74, 0x72, 0x69, 0x6e, 0x67, 0x64, 0x74, 0x79, 0x70, 0x65, 0xa5, 0x65,
+ 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65,
+ 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
+ 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
+ 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x6d, 0x69, 0x6e, 0x49,
+ 0x74, 0x65, 0x6d, 0x73, 0x1, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61,
+ 0x72, 0x72, 0x61, 0x79, 0x67, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74,
+ 0x78, 0x18, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f,
+ 0x6e, 0x2f, 0x76, 0x6e, 0x64, 0x2e, 0x6f, 0x63, 0x66, 0x2b, 0x63, 0x62,
+ 0x6f, 0x72, 0x63, 0x65, 0x70, 0x73, 0xa3, 0x65, 0x69, 0x74, 0x65, 0x6d,
+ 0x73, 0xa2, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65,
+ 0x73, 0xa2, 0x62, 0x65, 0x70, 0xa3, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
+ 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x66, 0x6f, 0x72, 0x6d,
+ 0x61, 0x74, 0x63, 0x75, 0x72, 0x69, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
+ 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x63, 0x70, 0x72, 0x69, 0xa3, 0x6b,
+ 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60,
+ 0x67, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x1, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x6b, 0x64,
+ 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x63, 0x69,
+ 0x6e, 0x73, 0xa2, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x64, 0x74, 0x79, 0x70, 0x65, 0x67, 0x69, 0x6e,
+ 0x74, 0x65, 0x67, 0x65, 0x72, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f,
+ 0x62, 0x6a, 0x65, 0x63, 0x74, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61,
+ 0x72, 0x72, 0x61, 0x79, 0x68, 0x48, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74,
+ 0x79, 0xa3, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x81,
+ 0x68, 0x68, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x6a, 0x70, 0x72,
+ 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xa5, 0x6f, 0x64, 0x65,
+ 0x73, 0x69, 0x72, 0x65, 0x64, 0x48, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74,
+ 0x79, 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
+ 0x6f, 0x6e, 0x60, 0x67, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x18,
+ 0x64, 0x67, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x0, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x62,
+ 0x72, 0x74, 0xa7, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49,
+ 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61,
+ 0x72, 0x72, 0x61, 0x79, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa3, 0x69,
+ 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64,
+ 0x65, 0x6e, 0x75, 0x6d, 0x81, 0x6e, 0x6f, 0x69, 0x63, 0x2e, 0x72, 0x2e,
+ 0x68, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x67, 0x64, 0x65, 0x66,
+ 0x61, 0x75, 0x6c, 0x74, 0x81, 0x6e, 0x6f, 0x69, 0x63, 0x2e, 0x72, 0x2e,
+ 0x68, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x68, 0x72, 0x65, 0x61,
+ 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74,
+ 0x65, 0x6d, 0x73, 0x1, 0x61, 0x6e, 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63,
+ 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x69, 0x6d, 0x61, 0x78,
+ 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x68, 0x72, 0x65, 0x61,
+ 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
+ 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x68, 0x68, 0x75, 0x6d, 0x69, 0x64,
+ 0x69, 0x74, 0x79, 0xa5, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64, 0x74, 0x79, 0x70, 0x65, 0x67, 0x69,
+ 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x67, 0x6d, 0x61, 0x78, 0x69, 0x6d,
+ 0x75, 0x6d, 0x18, 0x64, 0x67, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d,
+ 0x0, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x62,
+ 0x69, 0x66, 0xa6, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49,
+ 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2,
+ 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x82, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69,
+ 0x66, 0x2e, 0x61, 0x6f, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62,
+ 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x64, 0x74, 0x79, 0x70, 0x65,
+ 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x68, 0x6d, 0x69, 0x6e, 0x49,
+ 0x74, 0x65, 0x6d, 0x73, 0x2, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e,
+ 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72,
+ 0x61, 0x79, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65,
+ 0x63, 0x74, 0x6e, 0x48, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x55,
+ 0x70, 0x64, 0x61, 0x74, 0x65, 0xa3, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69,
+ 0x72, 0x65, 0x64, 0x81, 0x6f, 0x64, 0x65, 0x73, 0x69, 0x72, 0x65, 0x64,
+ 0x48, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x6a, 0x70, 0x72, 0x6f,
+ 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xa1, 0x6f, 0x64, 0x65, 0x73,
+ 0x69, 0x72, 0x65, 0x64, 0x48, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79,
+ 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
+ 0x6e, 0x60, 0x67, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x18, 0x64,
+ 0x67, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x0, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x6d, 0x73,
+ 0x62, 0x61, 0x74, 0x63, 0x68, 0x2d, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65,
+ 0xa4, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa5, 0x68, 0x72, 0x65, 0x71,
+ 0x75, 0x69, 0x72, 0x65, 0x64, 0x82, 0x64, 0x68, 0x72, 0x65, 0x66, 0x63,
+ 0x72, 0x65, 0x70, 0x74, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e,
+ 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73,
+ 0xf5, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
+ 0x6e, 0x60, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65,
+ 0x73, 0xa2, 0x63, 0x72, 0x65, 0x70, 0xa0, 0x64, 0x68, 0x72, 0x65, 0x66,
+ 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
+ 0x6e, 0x60, 0x66, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x63, 0x75, 0x72,
+ 0x69, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e,
+ 0x67, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x19,
+ 0x1, 0x0, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65,
+ 0x63, 0x74, 0x65, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x78, 0x1e, 0x43, 0x6f,
+ 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x42, 0x61, 0x74,
+ 0x63, 0x68, 0x20, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x46, 0x6f,
+ 0x72, 0x6d, 0x61, 0x74, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72,
+ 0x72, 0x61, 0x79, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73,
+ 0x1, 0x69, 0x73, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0xa4,
+ 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x83, 0x65, 0x6c,
+ 0x69, 0x6e, 0x6b, 0x73, 0x62, 0x72, 0x74, 0x62, 0x69, 0x66, 0x74, 0x61,
+ 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x6f,
+ 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xf5, 0x6a, 0x70, 0x72, 0x6f,
+ 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xa6, 0x65, 0x6c, 0x69, 0x6e,
+ 0x6b, 0x73, 0xa3, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa3, 0x68, 0x72,
+ 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x81, 0x64, 0x68, 0x72, 0x65,
+ 0x66, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73,
+ 0xad, 0x61, 0x70, 0xa4, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65,
+ 0x64, 0x81, 0x62, 0x62, 0x6d, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65,
+ 0x72, 0x74, 0x69, 0x65, 0x73, 0xa1, 0x62, 0x62, 0x6d, 0xa2, 0x6b, 0x64,
+ 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72,
+ 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74,
+ 0x62, 0x64, 0x69, 0xa3, 0x67, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e,
+ 0x78, 0x4d, 0x5e, 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d,
+ 0x39, 0x5d, 0x7b, 0x38, 0x7d, 0x2d, 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d,
+ 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x34, 0x7d, 0x2d, 0x5b, 0x61, 0x2d,
+ 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x34, 0x7d, 0x2d,
+ 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b,
+ 0x34, 0x7d, 0x2d, 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d,
+ 0x39, 0x5d, 0x7b, 0x31, 0x32, 0x7d, 0x24, 0x6b, 0x64, 0x65, 0x73, 0x63,
+ 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6d, 0x74, 0x61, 0x67,
+ 0x2d, 0x66, 0x75, 0x6e, 0x63, 0x2d, 0x64, 0x65, 0x73, 0x63, 0xa3, 0x6b,
+ 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60,
+ 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x66, 0x61,
+ 0x6e, 0x63, 0x68, 0x6f, 0x72, 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
+ 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x66, 0x6f, 0x72, 0x6d,
+ 0x61, 0x74, 0x63, 0x75, 0x72, 0x69, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
+ 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65,
+ 0x6e, 0x67, 0x74, 0x68, 0x19, 0x1, 0x0, 0x62, 0x72, 0x74, 0xa6, 0x6b,
+ 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60,
+ 0x6b, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73,
+ 0xf5, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61, 0x78,
+ 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x68, 0x6d, 0x69, 0x6e,
+ 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f,
+ 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72,
+ 0x72, 0x61, 0x79, 0x62, 0x69, 0x66, 0xa6, 0x6b, 0x64, 0x65, 0x73, 0x63,
+ 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75, 0x6e, 0x69,
+ 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x65, 0x69, 0x74,
+ 0x65, 0x6d, 0x73, 0xa3, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67,
+ 0x74, 0x68, 0x18, 0x40, 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x87, 0x6f, 0x6f,
+ 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69,
+ 0x6e, 0x65, 0x69, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x6c, 0x6c,
+ 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x69, 0x6f, 0x69,
+ 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x72, 0x77, 0x68, 0x6f, 0x69, 0x63, 0x2e,
+ 0x69, 0x66, 0x2e, 0x72, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e,
+ 0x61, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x73, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x68, 0x6d,
+ 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x68, 0x72, 0x65, 0x61,
+ 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65,
+ 0x61, 0x72, 0x72, 0x61, 0x79, 0x63, 0x72, 0x65, 0x6c, 0xa5, 0x65, 0x69,
+ 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e,
+ 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73,
+ 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74,
+ 0x65, 0x6d, 0x73, 0x1, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72,
+ 0x72, 0x61, 0x79, 0x67, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x81,
+ 0x65, 0x68, 0x6f, 0x73, 0x74, 0x73, 0x64, 0x74, 0x79, 0x70, 0x65, 0xa5,
+ 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61, 0x78, 0x4c,
+ 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70, 0x65,
+ 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65, 0x73, 0x63,
+ 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x6d, 0x69, 0x6e,
+ 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65,
+ 0x61, 0x72, 0x72, 0x61, 0x79, 0x67, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c,
+ 0x74, 0x78, 0x18, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69,
+ 0x6f, 0x6e, 0x2f, 0x76, 0x6e, 0x64, 0x2e, 0x6f, 0x63, 0x66, 0x2b, 0x63,
+ 0x62, 0x6f, 0x72, 0x6b, 0x74, 0x61, 0x67, 0x2d, 0x70, 0x6f, 0x73, 0x2d,
+ 0x72, 0x65, 0x6c, 0xa6, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x6d, 0x61, 0x78, 0x49, 0x74, 0x65,
+ 0x6d, 0x73, 0x3, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa3, 0x67, 0x6d,
+ 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x1, 0x67, 0x6d, 0x69, 0x6e, 0x69,
+ 0x6d, 0x75, 0x6d, 0x20, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6e, 0x75,
+ 0x6d, 0x62, 0x65, 0x72, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72,
+ 0x72, 0x61, 0x79, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79,
+ 0xf5, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x3, 0x65,
+ 0x74, 0x69, 0x74, 0x6c, 0x65, 0xa3, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
+ 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x69, 0x6d, 0x61, 0x78, 0x4c,
+ 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70, 0x65,
+ 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x63, 0x69, 0x6e, 0x73, 0xa2,
+ 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
+ 0x60, 0x64, 0x74, 0x79, 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74, 0x65, 0x67,
+ 0x65, 0x72, 0x63, 0x65, 0x70, 0x73, 0xa3, 0x65, 0x69, 0x74, 0x65, 0x6d,
+ 0x73, 0xa2, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65,
+ 0x73, 0xa2, 0x62, 0x65, 0x70, 0xa3, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
+ 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x66, 0x6f, 0x72, 0x6d,
+ 0x61, 0x74, 0x63, 0x75, 0x72, 0x69, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
+ 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x63, 0x70, 0x72, 0x69, 0xa3, 0x6b,
+ 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60,
+ 0x67, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x1, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x6b, 0x64,
+ 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x64, 0x68,
+ 0x72, 0x65, 0x66, 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,
+ 0x63, 0x75, 0x72, 0x69, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74,
+ 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67,
+ 0x74, 0x68, 0x19, 0x1, 0x0, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f,
+ 0x62, 0x6a, 0x65, 0x63, 0x74, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65,
+ 0x61, 0x72, 0x72, 0x61, 0x79, 0x62, 0x72, 0x74, 0xa7, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75,
+ 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x65, 0x69,
+ 0x74, 0x65, 0x6d, 0x73, 0xa3, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e,
+ 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x81, 0x6a,
+ 0x6f, 0x69, 0x63, 0x2e, 0x77, 0x6b, 0x2e, 0x63, 0x6f, 0x6c, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x67, 0x64,
+ 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x81, 0x6a, 0x6f, 0x69, 0x63, 0x2e,
+ 0x77, 0x6b, 0x2e, 0x63, 0x6f, 0x6c, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f,
+ 0x6e, 0x6c, 0x79, 0xf5, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d,
+ 0x73, 0x1, 0x61, 0x6e, 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65,
+ 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f,
+ 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74,
+ 0x72, 0x69, 0x6e, 0x67, 0x65, 0x72, 0x74, 0x73, 0x2d, 0x6d, 0xa6, 0x6b,
+ 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60,
+ 0x6b, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73,
+ 0xf5, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61, 0x78,
+ 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x68, 0x6d, 0x69, 0x6e,
+ 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f,
+ 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72,
+ 0x72, 0x61, 0x79, 0x63, 0x72, 0x74, 0x73, 0xa6, 0x6b, 0x64, 0x65, 0x73,
+ 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75, 0x6e,
+ 0x69, 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x65, 0x69,
+ 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e,
+ 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73,
+ 0x74, 0x72, 0x69, 0x6e, 0x67, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65,
+ 0x6d, 0x73, 0x1, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79,
+ 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79,
+ 0x62, 0x69, 0x66, 0xa7, 0x6b, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49,
+ 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x6d, 0x61, 0x78, 0x49, 0x74,
+ 0x65, 0x6d, 0x73, 0x4, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa3, 0x69,
+ 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64,
+ 0x65, 0x6e, 0x75, 0x6d, 0x83, 0x69, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66,
+ 0x2e, 0x6c, 0x6c, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62,
+ 0x6f, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x61, 0x73, 0x65,
+ 0x6c, 0x69, 0x6e, 0x65, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74,
+ 0x72, 0x69, 0x6e, 0x67, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72,
+ 0x72, 0x61, 0x79, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79,
+ 0xf5, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x2, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x68,
+ 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x73, 0x81, 0x70, 0x61, 0x70,
+ 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x6a, 0x73,
+ 0x6f, 0x6e, 0x68, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x73, 0x81,
+ 0x70, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,
+ 0x2f, 0x6a, 0x73, 0x6f,0x6e}; 
+ #endif /* OC_IDD_API */
+
+/**
+* function to set up the device.
+*
+*/
+int
+app_init(void)
+{
+  int ret = oc_init_platform("ocf", NULL, NULL);
+  ret |= oc_add_device(
+    "/oic/d", "oic.d.dehumidifier", "dehumidifier",
+    "ocf.2.0.5", // icv value
+    "ocf.res.1.3.0,ocf.sh.1.3.0", // dmv value
+    NULL, NULL);
+
+    if (ret >= 0) {
+    oc_uuid_t my_uuid;
+    oc_str_to_uuid(mfg_persistent_uuid, &my_uuid);
+    oc_set_immutable_device_identifier(0, &my_uuid);
+  }
+#ifdef OC_IDD_API
+  oc_set_introspection_data(0, introspection_data, introspection_data_size);
+#endif
+  return ret;
+}
+
+/**
+*  function to convert the interface string definition to the constant
+* @param interface the interface string e.g. "oic.if.a"
+*/
+int convert_if_string(char *interface_name)
+{
+  if (strcmp(interface_name, "oic.if.baseline") == 0) return OC_IF_BASELINE;
+  if (strcmp(interface_name, "oic.if.rw") == 0) return OC_IF_RW;
+  if (strcmp(interface_name, "oic.if.r" )== 0) return OC_IF_R;
+  if (strcmp(interface_name, "oic.if.s") == 0) return OC_IF_S;
+  if (strcmp(interface_name, "oic.if.a") == 0) return OC_IF_A;
+  if (strcmp(interface_name, "oic.if.b") == 0) return OC_IF_B;
+  //if strcmp(interface_name, "oic.if.lb") == 0) return OC_IF_LB;
+  if (strcmp(interface_name, "oic.if.ll") == 0) return OC_IF_LL;
+  return OC_IF_A;
+}
+
+/**
+* get method for "/binaryswitch" endpoint to intialize the returned values from the global values
+* This resource describes a binary switch (on/off).
+* The value is a boolean.
+* A value of 'true' means that the switch is on.
+* A value of 'false' means that the switch is off.
+* @param request the request representation.
+* @param interfaces the interface used for this call
+* @param user_data the user data.
+*/
+void
+get_binaryswitch(oc_request_t *request, oc_interface_mask_t interfaces, void *user_data)
+{
+  (void)user_data;  // not used
+
+  // TODO: SENSOR add here the code to talk to the HW if one implements a sensor.
+  // the calls needs to fill in the global variable before it is returned.
+  // alternative is to have a callback from the hardware that sets the global variables
+
+  // the current implementation always return everything that belongs to the resource.
+  // this kind of implementation is not optimal, but is correct and will pass CTT1.2.2
+
+  PRINT("get_binaryswitch: interface %d\n", interfaces);
+  oc_rep_start_root_object();
+  switch (interfaces) {
+  case OC_IF_BASELINE:
+    /* fall through */
+  case OC_IF_A:
+  PRINT("   Adding Baseline info\n" );
+    oc_process_baseline_interface(request->resource);
+    oc_rep_set_boolean(root, value, g_binaryswitch_value);
+    PRINT("   %s : %d\n", g_binaryswitch_RESOURCE_PROPERTY_NAME_value,  g_binaryswitch_value );
+    break;
+  default:
+    break;
+  }
+  oc_rep_end_root_object();
+  oc_send_response(request, OC_STATUS_OK);
+}
+
+/**
+* get method for "/humidity" endpoint to intialize the returned values from the global values
+* This resource describes a sensed or desired humidity.
+* The value humidity is an integer describing the percentage measured relative humidity.
+* The value desiredHumidity is an integer showing the desired target relative humidity.
+* Retrieves the current (relative) humidity level.
+* @param request the request representation.
+* @param interfaces the interface used for this call
+* @param user_data the user data.
+*/
+void
+get_humidity(oc_request_t *request, oc_interface_mask_t interfaces, void *user_data)
+{
+  (void)user_data;  // not used
+
+  // TODO: SENSOR add here the code to talk to the HW if one implements a sensor.
+  // the calls needs to fill in the global variable before it is returned.
+  // alternative is to have a callback from the hardware that sets the global variables
+
+  // the current implementation always return everything that belongs to the resource.
+  // this kind of implementation is not optimal, but is correct and will pass CTT1.2.2
+
+  PRINT("get_humidity: interface %d\n", interfaces);
+  oc_rep_start_root_object();
+  switch (interfaces) {
+  case OC_IF_BASELINE:
+    /* fall through */
+  case OC_IF_A:
+  PRINT("   Adding Baseline info\n" );
+    oc_process_baseline_interface(request->resource);
+    oc_rep_set_int(root, desiredHumidity, g_humidity_desiredHumidity );
+    PRINT("   %s : %d\n", g_humidity_RESOURCE_PROPERTY_NAME_desiredHumidity, g_humidity_desiredHumidity );
+
+    oc_rep_set_int(root, humidity, g_humidity_humidity );
+    PRINT("   %s : %d\n", g_humidity_RESOURCE_PROPERTY_NAME_humidity, g_humidity_humidity );
+    break;
+  default:
+    break;
+  }
+  oc_rep_end_root_object();
+  oc_send_response(request, OC_STATUS_OK);
+}
+
+/*
+void
+get_dimming(oc_request_t *request, oc_interface_mask_t interfaces, void *user_data)
+{
+  (void)user_data;  // not used
+
+  // TODO: SENSOR add here the code to talk to the HW if one implements a sensor.
+  // the calls needs to fill in the global variable before it is returned.
+  // alternative is to have a callback from the hardware that sets the global variables
+
+  // the current implementation always return everything that belongs to the resource.
+  // this kind of implementation is not optimal, but is correct and will pass CTT1.2.2
+
+  PRINT("get_dimming(), interfaces are: %d\n", interfaces);
+  oc_rep_start_root_object();
+  switch (interfaces) {
+  case OC_IF_BASELINE:
+    // fall through
+  case OC_IF_A:
+  PRINT("   Adding Baseline info\n" );
+    oc_process_baseline_interface(request->resource);
+    oc_rep_set_int(root, dimmingSetting, g_dimming_dimmingSetting );
+    PRINT("   %s : %d\n", g_dimming_RESOURCE_PROPERTY_NAME_dimmingSetting, g_dimming_dimmingSetting );
+    break;
+  default:
+    break;
+  }
+  oc_rep_end_root_object();
+  oc_send_response(request, OC_STATUS_OK);
+}
+*/
+
+/**
+* post method for "/binaryswitch" endpoint to assign the returned values to the global values.
+
+* @param requestRep the request representation.
+*/
+void
+post_binaryswitch(oc_request_t *request, oc_interface_mask_t interfaces, void *user_data)
+{
+  (void)interfaces;
+  (void)user_data;
+  bool error_state = false;
+  PRINT("post_binaryswitch:\n");
+  oc_rep_t *rep = request->request_payload;
+  while (rep != NULL) {
+    PRINT("key: (check) %s ", oc_string(rep->name));if (strcmp ( oc_string(rep->name), g_binaryswitch_RESOURCE_PROPERTY_NAME_value) == 0)
+    {
+      // value exist in payload
+      if (rep->type != OC_REP_BOOL)
+      {
+        error_state = true;
+        PRINT ("   property 'value' is not of type bool %d \n", rep->type);
+      }
+    }
+    rep = rep->next;
+  }
+  if (error_state == false)
+  {
+    oc_rep_t *rep = request->request_payload;
+    while (rep != NULL) {
+      PRINT("key: (assign) %s ", oc_string(rep->name));
+      // no error: assign the variables
+      if (strcmp ( oc_string(rep->name), g_binaryswitch_RESOURCE_PROPERTY_NAME_value)== 0)
+      {
+        // assign value
+        g_binaryswitch_value = rep->value.boolean;
+      }
+      rep = rep->next;
+    }
+    // set the response
+    oc_rep_start_root_object();
+    //oc_process_baseline_interface(request->resource);
+    oc_rep_set_boolean(root, value, g_binaryswitch_value);
+    oc_rep_end_root_object();
+
+    // TODO: ACTUATOR add here the code to talk to the HW if one implements an actuator.
+    // one can use the global variables as input to those calls
+    // the global values have been updated already with the data from the request
+
+    oc_send_response(request, OC_STATUS_CHANGED);
+  }
+  else
+  {
+    // TODO: add error response, if any
+    /*CTT expects error message from IUT when test cases CT1.2.3 and CT1.2.13 are run.
+    So OC_STATUS_NOT_MODIFIED has been changed to OC_STATUS_BAD_REQUEST below */
+    oc_send_response(request, OC_STATUS_BAD_REQUEST);
+  }
+}
+
+/**
+* post method for "/humidity" endpoint to assign the returned values to the global values.
+* Sets the desired relative humidity level.
+* @param requestRep the request representation.
+*/
+void
+post_humidity(oc_request_t *request, oc_interface_mask_t interfaces, void *user_data)
+{
+  (void)interfaces;
+  (void)user_data;
+  bool error_state = false;
+  PRINT("post_humidity:\n");
+  oc_rep_t *rep = request->request_payload;
+  while (rep != NULL) {
+    PRINT("key: (check) %s ", oc_string(rep->name));
+    if (strcmp ( oc_string(rep->name), g_humidity_RESOURCE_PROPERTY_NAME_desiredHumidity) == 0)
+    {
+      int value = rep->value.integer;
+      // value exist in payload
+
+      if (rep->type != OC_REP_INT)
+      {
+        error_state = true;
+        PRINT ("   property 'desiredHumidity' is not of type int %d \n", rep->type);
+      }
+
+      if ( value > 100 )
+      {
+        // check the maximum range
+        PRINT ("   property 'desiredHumidity' value exceed max : 0 >  value: %d \n", value);
+        error_state = true;
+      }
+    }
+
+    if (strcmp ( oc_string(rep->name), g_humidity_RESOURCE_PROPERTY_NAME_humidity) == 0)
+    {
+      int value = rep->value.integer;
+      // value exist in payload
+
+      // check if "humidity" is read only
+      error_state = true;
+      PRINT ("   property 'humidity' is readOnly \n");
+      if (rep->type != OC_REP_INT)
+      {
+        error_state = true;
+        PRINT ("   property 'humidity' is not of type int %d \n", rep->type);
+      }
+      if ( value > 100 )
+      {
+        // check the maximum range
+        PRINT ("   property 'humidity' value exceed max : 0 >  value: %d \n", value);
+        error_state = true;
+      }
+    }
+
+    rep = rep->next;
+  }
+  if (error_state == false)
+  {
+    oc_rep_t *rep = request->request_payload;
+    while (rep != NULL) {
+      PRINT("key: (assign) %s ", oc_string(rep->name));
+      // no error: assign the variables
+      if (strcmp ( oc_string(rep->name), g_humidity_RESOURCE_PROPERTY_NAME_desiredHumidity) == 0)
+      {
+        // assign desiredHumidity
+        g_humidity_desiredHumidity = rep->value.integer;
+      }if (strcmp ( oc_string(rep->name), g_humidity_RESOURCE_PROPERTY_NAME_humidity) == 0)
+      {
+        // assign humidity
+        g_humidity_humidity = rep->value.integer;
+      }
+      rep = rep->next;
+    }
+    // set the response
+    oc_rep_start_root_object();
+    //oc_process_baseline_interface(request->resource);
+    oc_rep_set_int(root, desiredHumidity, g_humidity_desiredHumidity );
+
+    oc_rep_set_int(root, humidity, g_humidity_humidity );
+    oc_rep_end_root_object();
+
+    // TODO: ACTUATOR add here the code to talk to the HW if one implements an actuator.
+    // one can use the global variables as input to those calls
+    // the global values have been updated already with the data from the request
+
+    oc_send_response(request, OC_STATUS_CHANGED);
+  }
+  else
+  {
+    // TODO: add error response, if any
+    /*CTT expects error message from IUT when test cases CT1.2.3 and CT1.2.13 are run.
+    So OC_STATUS_NOT_MODIFIED has been changed to OC_STATUS_BAD_REQUEST below */
+    oc_send_response(request, OC_STATUS_BAD_REQUEST);
+  }
+}
+
+/*
+void
+post_dimming(oc_request_t *request, oc_interface_mask_t interfaces, void *user_data)
+{
+  (void)interfaces;
+  (void)user_data;
+  bool error_state = false;
+  PRINT("post_dimming:\n");
+  oc_rep_t *rep = request->request_payload;
+  while (rep != NULL) {
+    PRINT("key: (check) %s ", oc_string(rep->name));
+    if (strcmp ( oc_string(rep->name), g_dimming_RESOURCE_PROPERTY_NAME_dimmingSetting) == 0)
+    {
+      int value = rep->value.integer;
+      // value exist in payload
+
+      if (rep->type != OC_REP_INT)
+      {
+        error_state = true;
+        PRINT ("   property 'dimmingSetting' is not of type int %d \n", rep->type);
+      }
+
+      if ( value > 100 )
+      {
+        // check the maximum range
+        PRINT ("   < property 'dimmingSetting' value exceeds max : 100 >  dimmingSetting: %d \n", value);
+        error_state = true;
+      }
+    }
+
+    rep = rep->next;
+  }
+  if (error_state == false)
+  {
+    oc_rep_t *rep = request->request_payload;
+    while (rep != NULL) {
+      PRINT("key: (assign) %s ", oc_string(rep->name));
+      // no error: assign the variables
+      if (strcmp ( oc_string(rep->name), g_dimming_RESOURCE_PROPERTY_NAME_dimmingSetting) == 0)
+      {
+        // assign dimmingSetting
+        g_dimming_dimmingSetting = rep->value.integer;
+      }
+      rep = rep->next;
+    }
+    // set the response
+    oc_rep_start_root_object();
+    //oc_process_baseline_interface(request->resource);
+    oc_rep_set_int(root, dimmingSetting, g_dimming_dimmingSetting );
+
+    oc_rep_end_root_object();
+
+    // TODO: ACTUATOR add here the code to talk to the HW if one implements an actuator.
+    // one can use the global variables as input to those calls
+    // the global values have been updated already with the data from the request
+
+    oc_send_response(request, OC_STATUS_CHANGED);
+  }
+  else
+  {
+    // TODO: add error response, if any
+    //CTT expects error message from IUT when test cases CT1.2.3 and CT1.2.13 are run.
+    //So OC_STATUS_NOT_MODIFIED has been changed to OC_STATUS_BAD_REQUEST below
+    oc_send_response(request, OC_STATUS_BAD_REQUEST);
+  }
+}
+*/
+
+/**
+*  register all the resources
+*/
+void register_resources(void)
+{
+PRINT("register resource with path /binaryswitch\n");
+  oc_resource_t *res_binaryswitch = oc_new_resource("NULL", g_binaryswitch_RESOURCE_ENDPOINT, g_binaryswitch_nr_resource_types, 0);
+  PRINT("     number of resource types: %d\n", g_binaryswitch_nr_resource_types);
+  for( int a = 0; a < g_binaryswitch_nr_resource_types; a++ )
+  {
+    PRINT("     resource type: %s\n", g_binaryswitch_RESOURCE_TYPE[a]);
+    oc_resource_bind_resource_type(res_binaryswitch,g_binaryswitch_RESOURCE_TYPE[a]);
+  }
+ for( int a = 0; a < g_binaryswitch_nr_resource_interfaces; a++ )
+  {
+    oc_resource_bind_resource_interface(res_binaryswitch, convert_if_string(g_binaryswitch_RESOURCE_INTERFACE[a]));
+  }
+  oc_resource_set_default_interface(res_binaryswitch, convert_if_string(g_binaryswitch_RESOURCE_INTERFACE[0]));
+  PRINT("     default interface: %d (%s)\n", convert_if_string(g_binaryswitch_RESOURCE_INTERFACE[0]), g_binaryswitch_RESOURCE_INTERFACE[0]);
+  oc_resource_set_discoverable(res_binaryswitch, true);
+  //oc_resource_set_periodic_observable(res_binaryswitch, 1);
+
+  oc_resource_set_request_handler(res_binaryswitch, OC_GET, get_binaryswitch, NULL);
+
+  oc_resource_set_request_handler(res_binaryswitch, OC_POST, post_binaryswitch, NULL);
+  oc_add_resource(res_binaryswitch);
+
+  PRINT("register resource with path /humidity\n");
+  oc_resource_t *res_humidity = oc_new_resource("NULL", g_humidity_RESOURCE_ENDPOINT, g_humidity_nr_resource_types, 0);
+  PRINT("     number of resource types: %d\n", g_humidity_nr_resource_types);
+  for( int a = 0; a < g_humidity_nr_resource_types; a++ )
+  {
+    PRINT("     resource type: %s\n", g_humidity_RESOURCE_TYPE[a]);
+    oc_resource_bind_resource_type(res_humidity,g_humidity_RESOURCE_TYPE[a]);
+  }
+  for( int a = 0; a < g_humidity_nr_resource_interfaces; a++ )
+  {
+    oc_resource_bind_resource_interface(res_humidity, convert_if_string(g_humidity_RESOURCE_INTERFACE[a]));
+  }
+  oc_resource_set_default_interface(res_humidity, convert_if_string(g_humidity_RESOURCE_INTERFACE[0]));
+  PRINT("     default interface: %d (%s)\n", convert_if_string(g_humidity_RESOURCE_INTERFACE[0]), g_humidity_RESOURCE_INTERFACE[0]);
+  oc_resource_set_discoverable(res_humidity, true);
+  //oc_resource_set_periodic_observable(res_humidity, 1);
+
+  oc_resource_set_request_handler(res_humidity, OC_GET, get_humidity, NULL);
+
+  oc_resource_set_request_handler(res_humidity, OC_POST, post_humidity, NULL);
+  oc_add_resource(res_humidity);
+
+  /*
+  PRINT("register resource with path /dimming\n");
+  oc_resource_t *res_dimming = oc_new_resource("NULL", g_dimming_RESOURCE_ENDPOINT, g_dimming_nr_resource_types, 0);
+  PRINT("     number of resource types: %d\n", g_dimming_nr_resource_types);
+  for( int a = 0; a < g_humidity_nr_resource_types; a++ )
+  {
+    PRINT("     resource type: %s\n", g_dimming_RESOURCE_TYPE[a]);
+    oc_resource_bind_resource_type(res_dimming,g_dimming_RESOURCE_TYPE[a]);
+  }
+  for( int a = 0; a < g_dimming_nr_resource_interfaces; a++ )
+  {
+    oc_resource_bind_resource_interface(res_dimming, convert_if_string(g_dimming_RESOURCE_INTERFACE[a]));
+  }
+  oc_resource_set_default_interface(res_dimming, convert_if_string(g_dimming_RESOURCE_INTERFACE[0]));
+  PRINT("     default interface: %d (%s)\n", convert_if_string(g_dimming_RESOURCE_INTERFACE[0]), g_dimming_RESOURCE_INTERFACE[0]);
+  oc_resource_set_discoverable(res_dimming, true);
+  //oc_resource_set_periodic_observable(res_dimming, 1);
+
+  oc_resource_set_request_handler(res_dimming, OC_GET, get_dimming, NULL);
+
+  oc_resource_set_request_handler(res_dimming, OC_POST, post_dimming, NULL);
+  oc_add_resource(res_dimming);
+  */
+}
+
+#ifdef WIN32
+/**
+* signal the event loop
+*/
+void
+signal_event_loop(void)
+{
+  WakeConditionVariable(&cv);
+}
+#endif
+#ifdef __linux__
+/**
+* signal the event loop
+*/
+void
+signal_event_loop(void)
+{
+  pthread_mutex_lock(&mutex);
+  pthread_cond_signal(&cv);
+  pthread_mutex_unlock(&mutex);
+}
+#endif
+
+/**
+* handle Ctrl-C
+* @param signal the captured signal
+*/
+void
+handle_signal(int signal)
+{
+  (void)signal;
+  signal_event_loop();
+  quit = 1;
+}
+
+/**
+* main application.
+* intializes the global variables
+* registers and starts the handler
+* handles (in a loop) the next event.
+* shuts down the stack
+*/
+/*int
+main(void)
+{
+int init;
+
+#ifdef WIN32
+  // windows specific
+  InitializeCriticalSection(&cs);
+  InitializeConditionVariable(&cv);
+  // install Ctrl-C
+  signal(SIGINT, handle_signal);
+#endif
+#ifdef __linux__
+  // linux specific
+  struct sigaction sa;
+  sigfillset(&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_handler = handle_signal;
+  // install Ctrl-C
+  sigaction(SIGINT, &sa, NULL);
+#endif
+  // initialize global variables for endpoint "/3D Printer"
+  g_3DPrinter_memorysize = 120.5; // current value of property "memorysize"  This value represents the total memory size of the printer. The unit is MB(Mega Bytes)
+  g_3DPrinter_wanconnected = false; // current value of property "wanconnected" This value indicates the connectivity capability of the 3D printer. If the value is false, the printer does not have network facility to Wide Area Network such as internet and GSM. If the value is true, the printer has network connectivity
+  g_3DPrinter_printsizex = 300.0; // current value of property "printsizex"  This represents the maximum size of printing object in the direction of X-axis. The unit is mm.
+  strcpy(g_3DPrinter_3dprinttype,"Digital Light Processing");  // current value of property "3dprinttype" The type of 3D printing technology.
+  g_3DPrinter_printsizez = 250.75; // current value of property "printsizez"  This represents the maximum size of printing object in the direction of Z-axis. The unit is mm.
+  g_3DPrinter_printsizey = 200.5; // current value of property "printsizey"  This represents the maximum size of printing object in the direction of Y-axis. The unit is mm.
+
+  // initialize global variables for endpoint "/Audio Controls"
+  g_AudioControls_mute = false; // current value of property "mute" Mute setting of an audio rendering device
+  g_AudioControls_volume = 50; // current value of property "volume" Volume setting of an audio rendering device.
+
+  // initialize global variables for endpoint "/binaryswitch"
+  g_binaryswitch_value = false; // current value of property "value" Status of the switch
+
+  // initialize global variables for endpoint "/humidity"
+  g_humidity_desiredHumidity = 40; // current value of property "desiredHumidity" Desired value for Humidity
+  g_humidity_humidity = 40; // current value of property "humidity" Current sensed value for Humidity
+
+  // no oic/con resource.
+  oc_set_con_res_announced(false);
+
+  // initializes the handlers structure
+  static const oc_handler_t handler = {.init = app_init,
+                                       .signal_event_loop = signal_event_loop,
+                                       .register_resources = register_resources
+#ifdef OC_CLIENT
+                                       ,
+                                       .requests_entry = 0
+#endif
+                                       };
+  oc_clock_time_t next_event;
+
+  PRINT("file : ../device_output/out_codegeneration_merged.swagger.json\n");
+  PRINT("title: Binary Switch\n");
+
+#ifdef OC_SECURITY
+  PRINT("intialize secure resources\n");
+  oc_storage_config("./device_builder_server_creds/");
+#endif*/ /* OC_SECURITY */
+
+  // start the stack
+  /*init = oc_main_init(&handler);
+  if (init < 0)
+    return init;
+
+#ifdef WIN32
+  // windows specific loop
+  while (quit != 1) {
+    next_event = oc_main_poll();
+    if (next_event == 0) {
+      SleepConditionVariableCS(&cv, &cs, INFINITE);
+    } else {
+      SleepConditionVariableCS(&cv, &cs,
+                               (DWORD)(next_event / (1000 * OC_CLOCK_SECOND)));
+    }
+  }
+#endif
+
+#ifdef __linux__
+  // linux specific loop
+  while (quit != 1) {
+    next_event = oc_main_poll();
+    pthread_mutex_lock(&mutex);
+    if (next_event == 0) {
+      pthread_cond_wait(&cv, &mutex);
+    } else {
+      ts.tv_sec = (next_event / OC_CLOCK_SECOND);
+      ts.tv_nsec = (next_event % OC_CLOCK_SECOND) * 1.e09 / OC_CLOCK_SECOND;
+      pthread_cond_timedwait(&cv, &mutex, &ts);
+    }
+    pthread_mutex_unlock(&mutex);
+  }
+#endif
+
+  // shut down the stack
+  oc_main_shutdown();
+  return 0;
+}*/
\ No newline at end of file
diff --git a/apps/discover_device.c b/apps/discover_device.c
new file mode 100644
index 00000000..fe496579
--- /dev/null
+++ b/apps/discover_device.c
@@ -0,0 +1,181 @@
+/*
+// Copyright (c) 2016 Intel Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#include "oc_api.h"
+#include "port/oc_clock.h"
+#include <pthread.h>
+#include <signal.h>
+#include <stdio.h>
+
+#define PRINTport(endpoint)                                                   \
+  do {                                                                         \
+    if ((endpoint).flags & IPV4) {                                             \
+      PRINT("%d",             \
+             (endpoint).addr.ipv4.port);     \
+    } else {                                                                   \
+      PRINT(                                                                   \
+        "%d",                                                             \
+         (endpoint).addr.ipv6.port);        \
+    }                                                                          \
+} while(0)
+
+#define PRINTIPaddr(endpoint)                                                  \
+  do {                                                                         \
+    if ((endpoint).flags & IPV4) {                                             \
+      PRINT("%d.%d.%d.%d", ((endpoint).addr.ipv4.address)[0],             \
+            ((endpoint).addr.ipv4.address)[1],                                 \
+            ((endpoint).addr.ipv4.address)[2],                                 \
+            ((endpoint).addr.ipv4.address)[3]);     \
+    } else {                                                                   \
+      PRINT(                                                                   \
+        "%02x%02x::%02x%02x:%02x%02x:%02x%02x:%"    \
+        "02x%"                                                                 \
+        "02x",                                                                 \
+        ((endpoint).addr.ipv6.address)[0], ((endpoint).addr.ipv6.address)[1],  \
+        ((endpoint).addr.ipv6.address)[8], ((endpoint).addr.ipv6.address)[9],  \
+        ((endpoint).addr.ipv6.address)[10],                                    \
+        ((endpoint).addr.ipv6.address)[11],                                    \
+        ((endpoint).addr.ipv6.address)[12],                                    \
+        ((endpoint).addr.ipv6.address)[13],                                    \
+        ((endpoint).addr.ipv6.address)[14],                                    \
+        ((endpoint).addr.ipv6.address)[15]);                                   \
+    }                                                                          \
+} while(0)
+pthread_mutex_t mutex;
+pthread_cond_t cv;
+struct timespec ts;
+
+int quit = 0;
+
+static int
+app_init(void)
+{
+  int ret = oc_init_platform("TAFAgent", NULL, NULL);
+  ret |= oc_add_device("/oic/d", "oic.d.phone", "Kishen's IPhone", "ocf.1.0.0",
+                       "ocf.res.1.0.0", NULL, NULL);
+  return ret;
+}
+
+#define MAX_URI_LENGTH (30)
+static char a_light[MAX_URI_LENGTH];
+static oc_endpoint_t *light_server;
+static oc_string_t name;
+static void
+signal_event_loop(void)
+{
+  pthread_mutex_lock(&mutex);
+  pthread_cond_signal(&cv);
+  pthread_mutex_unlock(&mutex);
+}
+static oc_discovery_flags_t
+discovery(const char *anchor, const char *uri, oc_string_array_t types,
+          oc_interface_mask_t interfaces, oc_endpoint_t *endpoint,
+          oc_resource_properties_t bm, void *user_data)
+{
+  (void)anchor;
+  (void)user_data;
+  (void)interfaces;
+  (void)bm;
+  int i;
+  int uri_len = strlen(uri);
+  uri_len = (uri_len >= MAX_URI_LENGTH) ? MAX_URI_LENGTH - 1 : uri_len;
+  for (i = 0; i < (int)oc_string_array_get_allocated_size(types); i++) {
+    char *t = oc_string_array_get_item(types, i);
+    if (strlen(t) == 8 && strncmp(t, "oic.wk.d", 8) == 0) {
+      light_server = endpoint;
+      strncpy(a_light, uri, uri_len);
+      a_light[uri_len] = '\0';
+
+      PRINT("Resource %s hosted at endpoints:\n", a_light);
+      oc_endpoint_t *ep = endpoint;
+      while (ep != NULL) {
+        PRINTIPaddr(*ep);
+        PRINT("\n");
+        PRINTport(*ep);
+        PRINT("\n");
+        ep = ep->next;
+      }
+
+  signal_event_loop();
+  quit = 1;
+      return OC_STOP_DISCOVERY;
+    }
+  }
+  oc_free_server_endpoints(endpoint);
+  return OC_CONTINUE_DISCOVERY;
+}
+
+static void
+issue_requests(void)
+{
+
+  oc_do_ip_discovery("oic.wk.d", &discovery, NULL);
+
+}
+
+
+void
+handle_signal(int signal)
+{
+  (void)signal;
+  signal_event_loop();
+  quit = 1;
+}
+
+int
+main(void)
+{
+  int init;
+  struct sigaction sa;
+  sigfillset(&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_handler = handle_signal;
+  sigaction(SIGINT, &sa, NULL);
+
+  static const oc_handler_t handler = {.init = app_init,
+                                       .signal_event_loop = signal_event_loop,
+                                       .requests_entry = issue_requests };
+
+  oc_clock_time_t next_event;
+
+#ifdef OC_SECURITY
+  oc_storage_config("./discover_device_creds");
+#endif               /* OC_SECURITY */
+
+  init = oc_main_init(&handler);
+  if (init < 0)
+    return init;
+
+  while (quit != 1) {
+    next_event = oc_main_poll();
+    if (quit ==1)
+      goto exit;
+    pthread_mutex_lock(&mutex);
+    if (next_event == 0) {
+      pthread_cond_wait(&cv, &mutex);
+    } else {
+      ts.tv_sec = (next_event / OC_CLOCK_SECOND);
+      ts.tv_nsec = (next_event % OC_CLOCK_SECOND) * 1.e09 / OC_CLOCK_SECOND;
+      pthread_cond_timedwait(&cv, &mutex, &ts);
+    }
+    pthread_mutex_unlock(&mutex);
+  }
+  exit:
+  oc_free_server_endpoints(light_server);
+  oc_free_string(&name);
+  oc_main_shutdown();
+  return 0;
+}
diff --git a/include/server_introspection.dat.h b/include/server_introspection.dat.h
index a410bf03..49e76e0d 100644
--- a/include/server_introspection.dat.h
+++ b/include/server_introspection.dat.h
@@ -9,259 +9,636 @@
 
 #include <stdint.h>
 
-#define introspection_data_size 3019  /* size of the CBOR */
+#ifndef OC_IDD_API
+
+#define introspection_data_size 7505  /* size of the CBOR */
 uint8_t introspection_data[] = {
- 0xa8, 0x64, 0x69, 0x6e, 0x66, 0x6f, 0xa3, 0x67, 0x6c, 0x69, 0x63, 0x65,
- 0x6e, 0x73, 0x65, 0xa1, 0x64, 0x6e, 0x61, 0x6d, 0x65, 0x78, 0x4b, 0x63,
- 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x32, 0x30, 0x31,
- 0x36, 0x2d, 0x32, 0x30, 0x31, 0x37, 0x20, 0x4f, 0x70, 0x65, 0x6e, 0x20,
- 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79,
- 0x20, 0x46, 0x6f, 0x75, 0x6e, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2c,
- 0x20, 0x49, 0x6e, 0x63, 0x2e, 0x20, 0x41, 0x6c, 0x6c, 0x20, 0x72, 0x69,
- 0x67, 0x68, 0x74, 0x73, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65,
- 0x64, 0x2e, 0x65, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x6d, 0x42, 0x69, 0x6e,
- 0x61, 0x72, 0x79, 0x20, 0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 0x67, 0x76,
- 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x6f, 0x76, 0x31, 0x2e, 0x31, 0x2e,
- 0x30, 0x2d, 0x32, 0x30, 0x31, 0x36, 0x30, 0x35, 0x31, 0x39, 0x68, 0x63,
- 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x73, 0x81, 0x70, 0x61, 0x70, 0x70,
- 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x6a, 0x73, 0x6f,
- 0x6e, 0x68, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x73, 0x81, 0x70,
- 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f,
- 0x6a, 0x73, 0x6f, 0x6e, 0x67, 0x73, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72,
- 0x63, 0x32, 0x2e, 0x30, 0x65, 0x70, 0x61, 0x74, 0x68, 0x73, 0xa3, 0x68,
- 0x2f, 0x64, 0x69, 0x6d, 0x6d, 0x69, 0x6e, 0x67, 0xa2, 0x63, 0x67, 0x65,
- 0x74, 0xa3, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
- 0x6f, 0x6e, 0x60, 0x6a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
- 0x72, 0x73, 0x81, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66, 0x76, 0x23, 0x2f,
- 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x2f, 0x69,
- 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x69, 0x72, 0x65, 0x73,
- 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0xa1, 0x63, 0x32, 0x30, 0x30, 0xa2,
- 0x66, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0xa1, 0x64, 0x24, 0x72, 0x65,
- 0x66, 0x75, 0x23, 0x2f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69,
- 0x6f, 0x6e, 0x73, 0x2f, 0x44, 0x69, 0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x6b,
- 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60,
- 0x64, 0x70, 0x6f, 0x73, 0x74, 0xa3, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
- 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70, 0x61, 0x72, 0x61,
- 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x82, 0xa1, 0x64, 0x24, 0x72, 0x65,
- 0x66, 0x76, 0x23, 0x2f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
- 0x72, 0x73, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65,
- 0xa4, 0x62, 0x69, 0x6e, 0x64, 0x62, 0x6f, 0x64, 0x79, 0x66, 0x73, 0x63,
- 0x68, 0x65, 0x6d, 0x61, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66, 0x75, 0x23,
- 0x2f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73,
- 0x2f, 0x44, 0x69, 0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x68, 0x72, 0x65, 0x71,
- 0x75, 0x69, 0x72, 0x65, 0x64, 0xf5, 0x64, 0x6e, 0x61, 0x6d, 0x65, 0x64,
- 0x62, 0x6f, 0x64, 0x79, 0x69, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
- 0x65, 0x73, 0xa2, 0x63, 0x32, 0x30, 0x30, 0xa2, 0x66, 0x73, 0x63, 0x68,
- 0x65, 0x6d, 0x61, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66, 0x75, 0x23, 0x2f,
- 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f,
- 0x44, 0x69, 0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65, 0x73, 0x63,
- 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x63, 0x34, 0x30, 0x33,
- 0xa2, 0x66, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0xa1, 0x64, 0x24, 0x72,
- 0x65, 0x66, 0x75, 0x23, 0x2f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74,
- 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x44, 0x69, 0x6d, 0x6d, 0x69, 0x6e, 0x67,
- 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
- 0x60, 0x6d, 0x2f, 0x62, 0x69, 0x6e, 0x61, 0x72, 0x79, 0x73, 0x77, 0x69,
- 0x74, 0x63, 0x68, 0xa2, 0x63, 0x67, 0x65, 0x74, 0xa3, 0x6b, 0x64, 0x65,
- 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70,
- 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x81, 0xa1, 0x64,
- 0x24, 0x72, 0x65, 0x66, 0x76, 0x23, 0x2f, 0x70, 0x61, 0x72, 0x61, 0x6d,
- 0x65, 0x74, 0x65, 0x72, 0x73, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66,
- 0x61, 0x63, 0x65, 0x69, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
- 0x73, 0xa1, 0x63, 0x32, 0x30, 0x30, 0xa2, 0x66, 0x73, 0x63, 0x68, 0x65,
- 0x6d, 0x61, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66, 0x78, 0x1a, 0x23, 0x2f,
- 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f,
- 0x42, 0x69, 0x6e, 0x61, 0x72, 0x79, 0x53, 0x77, 0x69, 0x74, 0x63, 0x68,
- 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
- 0x60, 0x64, 0x70, 0x6f, 0x73, 0x74, 0xa3, 0x6b, 0x64, 0x65, 0x73, 0x63,
- 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70, 0x61, 0x72,
- 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x82, 0xa1, 0x64, 0x24, 0x72,
- 0x65, 0x66, 0x76, 0x23, 0x2f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
- 0x65, 0x72, 0x73, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63,
- 0x65, 0xa4, 0x62, 0x69, 0x6e, 0x64, 0x62, 0x6f, 0x64, 0x79, 0x66, 0x73,
- 0x63, 0x68, 0x65, 0x6d, 0x61, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66, 0x78,
- 0x1a, 0x23, 0x2f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f,
- 0x6e, 0x73, 0x2f, 0x42, 0x69, 0x6e, 0x61, 0x72, 0x79, 0x53, 0x77, 0x69,
- 0x74, 0x63, 0x68, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64,
- 0xf5, 0x64, 0x6e, 0x61, 0x6d, 0x65, 0x64, 0x62, 0x6f, 0x64, 0x79, 0x69,
- 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0xa1, 0x63, 0x32,
- 0x30, 0x30, 0xa2, 0x66, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0xa1, 0x64,
- 0x24, 0x72, 0x65, 0x66, 0x78, 0x1a, 0x23, 0x2f, 0x64, 0x65, 0x66, 0x69,
- 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x42, 0x69, 0x6e, 0x61,
- 0x72, 0x79, 0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 0x6b, 0x64, 0x65, 0x73,
- 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x2f, 0x6f,
- 0x69, 0x63, 0x2f, 0x70, 0xa1, 0x63, 0x67, 0x65, 0x74, 0xa3, 0x6b, 0x64,
+ 0xa8, 0x67, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x73, 0x81, 0x64, 0x68,
+ 0x74, 0x74, 0x70, 0x67, 0x73, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x63,
+ 0x32, 0x2e, 0x30, 0x65, 0x70, 0x61, 0x74, 0x68, 0x73, 0xa3, 0x71, 0x2f,
+ 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65,
+ 0x73, 0x55, 0x52, 0x49, 0xa1, 0x63, 0x67, 0x65, 0x74, 0xa3, 0x69, 0x72,
+ 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0xa1, 0x63, 0x32, 0x30,
+ 0x30, 0xa2, 0x66, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0xa1, 0x64, 0x24,
+ 0x72, 0x65, 0x66, 0x77, 0x23, 0x2f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69,
+ 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x73, 0x62, 0x61, 0x73, 0x65, 0x6c,
+ 0x69, 0x6e, 0x65, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65,
+ 0x74, 0x65, 0x72, 0x73, 0x81, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66, 0x78,
+ 0x1a, 0x23, 0x2f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
+ 0x73, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x2d,
+ 0x61, 0x6c, 0x6c, 0x6d, 0x2f, 0x62, 0x69, 0x6e, 0x61, 0x72, 0x79, 0x73,
+ 0x77, 0x69, 0x74, 0x63, 0x68, 0xa2, 0x64, 0x70, 0x6f, 0x73, 0x74, 0xa3,
+ 0x69, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0xa1, 0x63,
+ 0x32, 0x30, 0x30, 0xa2, 0x66, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0xa1,
+ 0x64, 0x24, 0x72, 0x65, 0x66, 0x78, 0x1a, 0x23, 0x2f, 0x64, 0x65, 0x66,
+ 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x42, 0x69, 0x6e,
+ 0x61, 0x72, 0x79, 0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x64,
  0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a,
- 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x81, 0xa1,
- 0x64, 0x24, 0x72, 0x65, 0x66, 0x78, 0x18, 0x23, 0x2f, 0x70, 0x61, 0x72,
- 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x2f, 0x69, 0x6e, 0x74, 0x65,
- 0x72, 0x66, 0x61, 0x63, 0x65, 0x32, 0x30, 0x69, 0x72, 0x65, 0x73, 0x70,
+ 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x82, 0xa1,
+ 0x64, 0x24, 0x72, 0x65, 0x66, 0x76, 0x23, 0x2f, 0x70, 0x61, 0x72, 0x61,
+ 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72,
+ 0x66, 0x61, 0x63, 0x65, 0xa4, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72,
+ 0x65, 0x64, 0xf5, 0x62, 0x69, 0x6e, 0x64, 0x62, 0x6f, 0x64, 0x79, 0x66,
+ 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66,
+ 0x78, 0x1a, 0x23, 0x2f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69,
+ 0x6f, 0x6e, 0x73, 0x2f, 0x42, 0x69, 0x6e, 0x61, 0x72, 0x79, 0x53, 0x77,
+ 0x69, 0x74, 0x63, 0x68, 0x64, 0x6e, 0x61, 0x6d, 0x65, 0x64, 0x62, 0x6f,
+ 0x64, 0x79, 0x63, 0x67, 0x65, 0x74, 0xa3, 0x69, 0x72, 0x65, 0x73, 0x70,
  0x6f, 0x6e, 0x73, 0x65, 0x73, 0xa1, 0x63, 0x32, 0x30, 0x30, 0xa2, 0x66,
  0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66,
- 0x76, 0x23, 0x2f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f,
- 0x6e, 0x73, 0x2f, 0x50, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x6b,
- 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60,
- 0x67, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x73, 0x81, 0x64, 0x68, 0x74,
- 0x74, 0x70, 0x6a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
- 0x73, 0xa2, 0x6b, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65,
- 0x32, 0x30, 0xa4, 0x62, 0x69, 0x6e, 0x65, 0x71, 0x75, 0x65, 0x72, 0x79,
- 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
- 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x82, 0x6f, 0x6f, 0x69, 0x63, 0x2e, 0x69,
- 0x66, 0x2e, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x68, 0x6f,
- 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x72, 0x64, 0x6e, 0x61, 0x6d, 0x65,
+ 0x78, 0x1a, 0x23, 0x2f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69,
+ 0x6f, 0x6e, 0x73, 0x2f, 0x42, 0x69, 0x6e, 0x61, 0x72, 0x79, 0x53, 0x77,
+ 0x69, 0x74, 0x63, 0x68, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70, 0x61, 0x72, 0x61, 0x6d,
+ 0x65, 0x74, 0x65, 0x72, 0x73, 0x81, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66,
+ 0x76, 0x23, 0x2f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
+ 0x73, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x69,
+ 0x2f, 0x68, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0xa2, 0x64, 0x70,
+ 0x6f, 0x73, 0x74, 0xa3, 0x69, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
+ 0x65, 0x73, 0xa1, 0x63, 0x32, 0x30, 0x30, 0xa2, 0x66, 0x73, 0x63, 0x68,
+ 0x65, 0x6d, 0x61, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66, 0x78, 0x1c, 0x23,
+ 0x2f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73,
+ 0x2f, 0x48, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x55, 0x70, 0x64,
+ 0x61, 0x74, 0x65, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65,
+ 0x74, 0x65, 0x72, 0x73, 0x82, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66, 0x76,
+ 0x23, 0x2f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73,
+ 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0xa4, 0x68,
+ 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0xf5, 0x62, 0x69, 0x6e,
+ 0x64, 0x62, 0x6f, 0x64, 0x79, 0x66, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61,
+ 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66, 0x78, 0x1c, 0x23, 0x2f, 0x64, 0x65,
+ 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x48, 0x75,
+ 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
+ 0x64, 0x6e, 0x61, 0x6d, 0x65, 0x64, 0x62, 0x6f, 0x64, 0x79, 0x63, 0x67,
+ 0x65, 0x74, 0xa3, 0x69, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
+ 0x73, 0xa1, 0x63, 0x32, 0x30, 0x30, 0xa2, 0x66, 0x73, 0x63, 0x68, 0x65,
+ 0x6d, 0x61, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66, 0x76, 0x23, 0x2f, 0x64,
+ 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x48,
+ 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x6b, 0x64, 0x65, 0x73, 0x63,
+ 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x64, 0x65, 0x73,
+ 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70, 0x61,
+ 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x81, 0xa1, 0x64, 0x24,
+ 0x72, 0x65, 0x66, 0x76, 0x23, 0x2f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65,
+ 0x74, 0x65, 0x72, 0x73, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61,
+ 0x63, 0x65, 0x6a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
+ 0x73, 0xa3, 0x6d, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65,
+ 0x2d, 0x61, 0x6c, 0x6c, 0xa4, 0x62, 0x69, 0x6e, 0x65, 0x71, 0x75, 0x65,
+ 0x72, 0x79, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69,
+ 0x6e, 0x67, 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x83, 0x69, 0x6f, 0x69, 0x63,
+ 0x2e, 0x69, 0x66, 0x2e, 0x6c, 0x6c, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69,
+ 0x66, 0x2e, 0x62, 0x6f, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62,
+ 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x64, 0x6e, 0x61, 0x6d, 0x65,
  0x62, 0x69, 0x66, 0x69, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63,
  0x65, 0xa4, 0x62, 0x69, 0x6e, 0x65, 0x71, 0x75, 0x65, 0x72, 0x79, 0x64,
  0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x64,
- 0x65, 0x6e, 0x75, 0x6d, 0x82, 0x6f, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66,
- 0x2e, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x68, 0x6f, 0x69,
- 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x61, 0x64, 0x6e, 0x61, 0x6d, 0x65, 0x62,
- 0x69, 0x66, 0x6b, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f,
- 0x6e, 0x73, 0xa3, 0x6c, 0x42, 0x69, 0x6e, 0x61, 0x72, 0x79, 0x53, 0x77,
- 0x69, 0x74, 0x63, 0x68, 0xa3, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f,
- 0x62, 0x6a, 0x65, 0x63, 0x74, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72,
- 0x74, 0x69, 0x65, 0x73, 0xa4, 0x62, 0x72, 0x74, 0xa6, 0x65, 0x69, 0x74,
- 0x65, 0x6d, 0x73, 0xa2, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74,
- 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67,
- 0x74, 0x68, 0x18, 0x40, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d,
- 0x73, 0x1, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
- 0x6f, 0x6e, 0x60, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79,
- 0xf5, 0x67, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x81, 0x73, 0x6f,
- 0x69, 0x63, 0x2e, 0x72, 0x2e, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x2e,
- 0x62, 0x69, 0x6e, 0x61, 0x72, 0x79, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65,
- 0x61, 0x72, 0x72, 0x61, 0x79, 0x61, 0x6e, 0xa4, 0x68, 0x72, 0x65, 0x61,
- 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
- 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
+ 0x65, 0x6e, 0x75, 0x6d, 0x82, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66,
+ 0x2e, 0x61, 0x6f, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x61,
+ 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x64, 0x6e, 0x61, 0x6d, 0x65, 0x62,
+ 0x69, 0x66, 0x70, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65,
+ 0x2d, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0xa4, 0x62, 0x69, 0x6e, 0x65,
+ 0x71, 0x75, 0x65, 0x72, 0x79, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73,
+ 0x74, 0x72, 0x69, 0x6e, 0x67, 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x83, 0x69,
+ 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x6c, 0x6c, 0x68, 0x6f, 0x69,
+ 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x6f, 0x6f, 0x69, 0x63, 0x2e, 0x69,
+ 0x66, 0x2e, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x64, 0x6e,
+ 0x61, 0x6d, 0x65, 0x62, 0x69, 0x66, 0x64, 0x69, 0x6e, 0x66, 0x6f, 0xa4,
+ 0x65, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x6d, 0x42, 0x69, 0x6e, 0x61, 0x72,
+ 0x79, 0x20, 0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 0x6e, 0x74, 0x65, 0x72,
+ 0x6d, 0x73, 0x4f, 0x66, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x78,
+ 0x3f, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x6f, 0x70, 0x65,
+ 0x6e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74,
+ 0x79, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
+ 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x69, 0x6f, 0x2f, 0x63, 0x6f,
+ 0x72, 0x65, 0x2f, 0x44, 0x49, 0x53, 0x43, 0x4c, 0x41, 0x49, 0x4d, 0x45,
+ 0x52, 0x2e, 0x6d, 0x64, 0x67, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65,
+ 0xa3, 0x63, 0x75, 0x72, 0x6c, 0x78, 0x6b, 0x68, 0x74, 0x74, 0x70, 0x73,
+ 0x3a, 0x2f, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f,
+ 0x6d, 0x2f, 0x6f, 0x70, 0x65, 0x6e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
+ 0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x61,
+ 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x62, 0x6c,
+ 0x6f, 0x62, 0x2f, 0x65, 0x32, 0x38, 0x61, 0x39, 0x65, 0x30, 0x61, 0x39,
+ 0x32, 0x65, 0x31, 0x37, 0x30, 0x34, 0x32, 0x62, 0x61, 0x33, 0x65, 0x38,
+ 0x33, 0x36, 0x36, 0x31, 0x65, 0x34, 0x63, 0x30, 0x66, 0x62, 0x63, 0x65,
+ 0x38, 0x62, 0x64, 0x63, 0x34, 0x62, 0x61, 0x2f, 0x4c, 0x49, 0x43, 0x45,
+ 0x4e, 0x53, 0x45, 0x2e, 0x6d, 0x64, 0x64, 0x6e, 0x61, 0x6d, 0x65, 0x76,
+ 0x4f, 0x43, 0x46, 0x20, 0x44, 0x61, 0x74, 0x61, 0x20, 0x4d, 0x6f, 0x64,
+ 0x65, 0x6c, 0x20, 0x4c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x6b, 0x78,
+ 0x2d, 0x63, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x78, 0x4b,
+ 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x32, 0x30,
+ 0x31, 0x38, 0x2d, 0x32, 0x30, 0x31, 0x39, 0x20, 0x4f, 0x70, 0x65, 0x6e,
+ 0x20, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74,
+ 0x79, 0x20, 0x46, 0x6f, 0x75, 0x6e, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e,
+ 0x2c, 0x20, 0x49, 0x6e, 0x63, 0x2e, 0x20, 0x41, 0x6c, 0x6c, 0x20, 0x72,
+ 0x69, 0x67, 0x68, 0x74, 0x73, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76,
+ 0x65, 0x64, 0x2e, 0x67, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x68,
+ 0x32, 0x30, 0x31, 0x39, 0x30, 0x32, 0x32, 0x32, 0x6b, 0x64, 0x65, 0x66,
+ 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0xaa, 0x6c, 0x42, 0x69,
+ 0x6e, 0x61, 0x72, 0x79, 0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 0xa3, 0x68,
+ 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x81, 0x65, 0x76, 0x61,
+ 0x6c, 0x75, 0x65, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69,
+ 0x65, 0x73, 0xa4, 0x62, 0x72, 0x74, 0xa7, 0x6b, 0x64, 0x65, 0x73, 0x63,
+ 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75, 0x6e, 0x69,
+ 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x65, 0x69, 0x74, 0x65,
+ 0x6d, 0x73, 0xa3, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74,
+ 0x68, 0x18, 0x40, 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x81, 0x73, 0x6f, 0x69,
+ 0x63, 0x2e, 0x72, 0x2e, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x2e, 0x62,
+ 0x69, 0x6e, 0x61, 0x72, 0x79, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73,
+ 0x74, 0x72, 0x69, 0x6e, 0x67, 0x67, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c,
+ 0x74, 0x81, 0x73, 0x6f, 0x69, 0x63, 0x2e, 0x72, 0x2e, 0x73, 0x77, 0x69,
+ 0x74, 0x63, 0x68, 0x2e, 0x62, 0x69, 0x6e, 0x61, 0x72, 0x79, 0x68, 0x72,
+ 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x68, 0x6d, 0x69, 0x6e,
+ 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x65, 0x76, 0x61, 0x6c, 0x75, 0x65,
+ 0xa2, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
+ 0x6e, 0x60, 0x64, 0x74, 0x79, 0x70, 0x65, 0x67, 0x62, 0x6f, 0x6f, 0x6c,
+ 0x65, 0x61, 0x6e, 0x61, 0x6e, 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
  0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x69, 0x6d, 0x61, 0x78, 0x4c,
- 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x65, 0x76, 0x61, 0x6c, 0x75,
- 0x65, 0xa2, 0x64, 0x74, 0x79, 0x70, 0x65, 0x67, 0x62, 0x6f, 0x6f, 0x6c,
- 0x65, 0x61, 0x6e, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
- 0x69, 0x6f, 0x6e, 0x60, 0x62, 0x69, 0x66, 0xa5, 0x65, 0x69, 0x74, 0x65,
- 0x6d, 0x73, 0xa2, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72,
- 0x69, 0x6e, 0x67, 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x82, 0x6f, 0x6f, 0x69,
+ 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x68, 0x72, 0x65, 0x61, 0x64,
+ 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73,
+ 0x74, 0x72, 0x69, 0x6e, 0x67, 0x62, 0x69, 0x66, 0xa6, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75,
+ 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x65,
+ 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x82,
+ 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x61, 0x6f, 0x6f, 0x69,
  0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e,
- 0x65, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x61, 0x68, 0x6d,
- 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x64, 0x74, 0x79, 0x70,
- 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x6b, 0x64, 0x65, 0x73, 0x63,
- 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x72, 0x65, 0x61,
- 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69,
- 0x72, 0x65, 0x64, 0x81, 0x65, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x67, 0x44,
- 0x69, 0x6d, 0x6d, 0x69, 0x6e, 0x67, 0xa3, 0x64, 0x74, 0x79, 0x70, 0x65,
- 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x6a, 0x70, 0x72, 0x6f, 0x70,
- 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xa4, 0x6e, 0x64, 0x69, 0x6d, 0x6d,
- 0x69, 0x6e, 0x67, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0xa2, 0x64,
- 0x74, 0x79, 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72,
+ 0x65, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e,
+ 0x67, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x2, 0x68,
+ 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x72, 0x73, 0x62, 0x61,
+ 0x74, 0x63, 0x68, 0x2d, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x69,
+ 0x74, 0x65, 0x6d, 0xa5, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65,
+ 0x64, 0x82, 0x64, 0x68, 0x72, 0x65, 0x66, 0x63, 0x72, 0x65, 0x70, 0x74,
+ 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72,
+ 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xf5, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70,
+ 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xa2, 0x63, 0x72,
+ 0x65, 0x70, 0xa0, 0x64, 0x68, 0x72, 0x65, 0x66, 0xa4, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x66,
+ 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x63, 0x75, 0x72, 0x69, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d, 0x61,
+ 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x19, 0x1, 0x0, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x70, 0x73,
+ 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x2d, 0x75, 0x70, 0x64,
+ 0x61, 0x74, 0x65, 0xa0, 0x6f, 0x73, 0x62, 0x61, 0x74, 0x63, 0x68, 0x2d,
+ 0x72, 0x65, 0x74, 0x72, 0x69, 0x65, 0x76, 0x65, 0xa3, 0x65, 0x69, 0x74,
+ 0x65, 0x6d, 0x73, 0xa4, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65,
+ 0x64, 0x82, 0x64, 0x68, 0x72, 0x65, 0x66, 0x63, 0x72, 0x65, 0x70, 0x74,
+ 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72,
+ 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xf5, 0x6a, 0x70, 0x72,
+ 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xa2, 0x63, 0x72, 0x65,
+ 0x70, 0xa0, 0x64, 0x68, 0x72, 0x65, 0x66, 0xa4, 0x6b, 0x64, 0x65, 0x73,
+ 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x66, 0x6f,
+ 0x72, 0x6d, 0x61, 0x74, 0x63, 0x75, 0x72, 0x69, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d, 0x61, 0x78,
+ 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x19, 0x1, 0x0, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x68, 0x6d, 0x69, 0x6e,
+ 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x6c, 0x6f, 0x69, 0x63, 0x2e, 0x6f,
+ 0x69, 0x63, 0x2d, 0x6c, 0x69, 0x6e, 0x6b, 0xa3, 0x68, 0x72, 0x65, 0x71,
+ 0x75, 0x69, 0x72, 0x65, 0x64, 0x81, 0x64, 0x68, 0x72, 0x65, 0x66, 0x6a,
+ 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xae, 0x61,
+ 0x70, 0xa4, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x81,
+ 0x62, 0x62, 0x6d, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74,
+ 0x69, 0x65, 0x73, 0xa1, 0x62, 0x62, 0x6d, 0xa2, 0x6b, 0x64, 0x65, 0x73,
+ 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x62, 0x64,
+ 0x69, 0xa3, 0x67, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x78, 0x4d,
+ 0x5e, 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d,
+ 0x7b, 0x38, 0x7d, 0x2d, 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30,
+ 0x2d, 0x39, 0x5d, 0x7b, 0x34, 0x7d, 0x2d, 0x5b, 0x61, 0x2d, 0x66, 0x41,
+ 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x34, 0x7d, 0x2d, 0x5b, 0x61,
+ 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x34, 0x7d,
+ 0x2d, 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d,
+ 0x7b, 0x31, 0x32, 0x7d, 0x24, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
+ 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6d, 0x74, 0x61, 0x67, 0x2d, 0x66,
+ 0x75, 0x6e, 0x63, 0x2d, 0x64, 0x65, 0x73, 0x63, 0xa3, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x72,
+ 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x66, 0x61, 0x6e, 0x63,
+ 0x68, 0x6f, 0x72, 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,
+ 0x63, 0x75, 0x72, 0x69, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74,
+ 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67,
+ 0x74, 0x68, 0x19, 0x1, 0x0, 0x62, 0x72, 0x74, 0xa6, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75,
+ 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x65,
+ 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65,
+ 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
+ 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74,
+ 0x65, 0x6d, 0x73, 0x1, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c,
+ 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61,
+ 0x79, 0x62, 0x69, 0x66, 0xa6, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75, 0x6e, 0x69, 0x71, 0x75,
+ 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x65, 0x69, 0x74, 0x65, 0x6d,
+ 0x73, 0xa3, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68,
+ 0x18, 0x40, 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x87, 0x6f, 0x6f, 0x69, 0x63,
+ 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65,
+ 0x69, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x6c, 0x6c, 0x68, 0x6f,
+ 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x69, 0x6f, 0x69, 0x63, 0x2e,
+ 0x69, 0x66, 0x2e, 0x72, 0x77, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66,
+ 0x2e, 0x72, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x61, 0x68,
+ 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x73, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x68, 0x6d, 0x69, 0x6e,
+ 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f,
+ 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72,
+ 0x72, 0x61, 0x79, 0x63, 0x72, 0x65, 0x6c, 0xa5, 0x65, 0x69, 0x74, 0x65,
+ 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74,
+ 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72,
+ 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d,
+ 0x73, 0x1, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61,
+ 0x79, 0x67, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x81, 0x65, 0x68,
+ 0x6f, 0x73, 0x74, 0x73, 0x64, 0x68, 0x72, 0x65, 0x66, 0xa4, 0x6b, 0x64,
+ 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66,
+ 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x63, 0x75, 0x72, 0x69, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d,
+ 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x19, 0x1, 0x0, 0x6c,
+ 0x74, 0x61, 0x67, 0x2d, 0x70, 0x6f, 0x73, 0x2d, 0x64, 0x65, 0x73, 0x63,
+ 0xa2, 0x65, 0x61, 0x6c, 0x6c, 0x4f, 0x66, 0x82, 0xa1, 0x64, 0x24, 0x72,
+ 0x65, 0x66, 0x78, 0x33, 0x6f, 0x69, 0x63, 0x2e, 0x74, 0x79, 0x70, 0x65,
+ 0x73, 0x2d, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x6a, 0x73, 0x6f,
+ 0x6e, 0x23, 0x2f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f,
+ 0x6e, 0x73, 0x2f, 0x70, 0x6f, 0x73, 0x2d, 0x64, 0x65, 0x73, 0x63, 0x72,
+ 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0xa1, 0x68, 0x72, 0x65, 0x61,
+ 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
+ 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x74, 0x61, 0x67, 0x2d,
+ 0x70, 0x6f, 0x73, 0x2d, 0x72, 0x65, 0x6c, 0xa6, 0x6b, 0x64, 0x65, 0x73,
+ 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x6d, 0x61,
+ 0x78, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x3, 0x65, 0x69, 0x74, 0x65, 0x6d,
+ 0x73, 0xa3, 0x67, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x1, 0x67,
+ 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x20, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x68, 0x72, 0x65, 0x61, 0x64,
+ 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65,
+ 0x6d, 0x73, 0x3, 0x65, 0x74, 0x69, 0x74, 0x6c, 0x65, 0xa3, 0x6b, 0x64,
+ 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x69,
+ 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0xa5, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2,
+ 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40,
+ 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
  0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
- 0x60, 0x61, 0x6e, 0xa4, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c,
- 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69,
- 0x6e, 0x67, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
- 0x6f, 0x6e, 0x60, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74,
- 0x68, 0x18, 0x40, 0x62, 0x72, 0x74, 0xa6, 0x65, 0x69, 0x74, 0x65, 0x6d,
- 0x73, 0xa2, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69,
- 0x6e, 0x67, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68,
- 0x18, 0x40, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1,
+ 0x60, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x67, 0x64,
+ 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x78, 0x18, 0x61, 0x70, 0x70, 0x6c,
+ 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x76, 0x6e, 0x64, 0x2e,
+ 0x6f, 0x63, 0x66, 0x2b, 0x63, 0x62, 0x6f, 0x72, 0x63, 0x65, 0x70, 0x73,
+ 0xa3, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x6a, 0x70, 0x72, 0x6f,
+ 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xa2, 0x62, 0x65, 0x70, 0xa3,
  0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
- 0x60, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x67,
- 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x81, 0x73, 0x6f, 0x69, 0x63,
- 0x2e, 0x72, 0x2e, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x2e, 0x64, 0x69, 0x6d,
- 0x6d, 0x69, 0x6e, 0x67, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72,
- 0x72, 0x61, 0x79, 0x62, 0x69, 0x66, 0xa5, 0x65, 0x69, 0x74, 0x65, 0x6d,
- 0x73, 0xa2, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69,
- 0x6e, 0x67, 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x82, 0x6f, 0x6f, 0x69, 0x63,
- 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65,
- 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x61, 0x68, 0x6d, 0x69,
- 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x64, 0x74, 0x79, 0x70, 0x65,
- 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
- 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x72, 0x65, 0x61, 0x64,
- 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72,
- 0x65, 0x64, 0x81, 0x6e, 0x64, 0x69, 0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x53,
- 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x68, 0x50, 0x6c, 0x61, 0x74, 0x66,
- 0x6f, 0x72, 0x6d, 0xa2, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74,
- 0x69, 0x65, 0x73, 0xae, 0x64, 0x6d, 0x6e, 0x6d, 0x6c, 0xa5, 0x68, 0x72,
- 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70,
- 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65, 0x73,
- 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x69, 0x6d, 0x61,
- 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x19, 0x1, 0x0, 0x66, 0x66,
- 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x63, 0x75, 0x72, 0x69, 0x64, 0x6d, 0x6e,
- 0x66, 0x76, 0xa4, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79,
- 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e,
- 0x67, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
- 0x6e, 0x60, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68,
- 0x18, 0x40, 0x64, 0x6d, 0x6e, 0x6f, 0x73, 0xa4, 0x68, 0x72, 0x65, 0x61,
- 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
- 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
- 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x69, 0x6d, 0x61, 0x78, 0x4c,
- 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x62, 0x69, 0x64, 0xa4, 0x68,
- 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79,
- 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65,
- 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x69, 0x6d,
- 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x62, 0x70,
- 0x69, 0xa1, 0x65, 0x61, 0x6c, 0x6c, 0x4f, 0x66, 0x82, 0xa3, 0x64, 0x74,
- 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6b, 0x64,
- 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x67,
- 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x78, 0x4d, 0x5e, 0x5b, 0x61,
- 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x38, 0x7d,
+ 0x60, 0x66, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x63, 0x75, 0x72, 0x69,
+ 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
+ 0x63, 0x70, 0x72, 0x69, 0xa3, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x67, 0x6d, 0x69, 0x6e, 0x69, 0x6d,
+ 0x75, 0x6d, 0x1, 0x64, 0x74, 0x79, 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74,
+ 0x65, 0x67, 0x65, 0x72, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62,
+ 0x6a, 0x65, 0x63, 0x74, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61,
+ 0x72, 0x72, 0x61, 0x79, 0x63, 0x69, 0x6e, 0x73, 0xa2, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x66,
+ 0x73, 0x6c, 0x69, 0x6e, 0x6b, 0x73, 0xa2, 0x65, 0x69, 0x74, 0x65, 0x6d,
+ 0x73, 0xa3, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x81,
+ 0x64, 0x68, 0x72, 0x65, 0x66, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72,
+ 0x74, 0x69, 0x65, 0x73, 0xae, 0x61, 0x70, 0xa4, 0x68, 0x72, 0x65, 0x71,
+ 0x75, 0x69, 0x72, 0x65, 0x64, 0x81, 0x62, 0x62, 0x6d, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70,
+ 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xa1, 0x62, 0x62,
+ 0x6d, 0xa2, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
+ 0x6f, 0x6e, 0x60, 0x64, 0x74, 0x79, 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74,
+ 0x65, 0x67, 0x65, 0x72, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62,
+ 0x6a, 0x65, 0x63, 0x74, 0x62, 0x64, 0x69, 0xa3, 0x67, 0x70, 0x61, 0x74,
+ 0x74, 0x65, 0x72, 0x6e, 0x78, 0x4d, 0x5e, 0x5b, 0x61, 0x2d, 0x66, 0x41,
+ 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x38, 0x7d, 0x2d, 0x5b, 0x61,
+ 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x34, 0x7d,
  0x2d, 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d,
  0x7b, 0x34, 0x7d, 0x2d, 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30,
  0x2d, 0x39, 0x5d, 0x7b, 0x34, 0x7d, 0x2d, 0x5b, 0x61, 0x2d, 0x66, 0x41,
- 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x34, 0x7d, 0x2d, 0x5b, 0x61,
- 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x31, 0x32,
- 0x7d, 0x24, 0xa2, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79,
- 0xf5, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
- 0x6e, 0x60, 0x64, 0x6d, 0x6e, 0x6d, 0x6f, 0xa4, 0x68, 0x72, 0x65, 0x61,
- 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
- 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
- 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x69, 0x6d, 0x61, 0x78, 0x4c,
- 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x62, 0x69, 0x66, 0xa5, 0x65,
- 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
- 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x82,
- 0x6f, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x61, 0x73, 0x65,
- 0x6c, 0x69, 0x6e, 0x65, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e,
- 0x72, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x64,
- 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x6b, 0x64,
- 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68,
- 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x6d, 0x6e,
- 0x70, 0x76, 0xa4, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79,
- 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e,
- 0x67, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
- 0x6e, 0x60, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68,
- 0x18, 0x40, 0x64, 0x6d, 0x6e, 0x68, 0x77, 0xa4, 0x68, 0x72, 0x65, 0x61,
- 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
- 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
- 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x69, 0x6d, 0x61, 0x78, 0x4c,
- 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x62, 0x73, 0x74, 0xa4, 0x68,
- 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79,
+ 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x31, 0x32, 0x7d, 0x24, 0x6b,
+ 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60,
+ 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
+ 0x6d, 0x74, 0x61, 0x67, 0x2d, 0x66, 0x75, 0x6e, 0x63, 0x2d, 0x64, 0x65,
+ 0x73, 0x63, 0xa3, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c,
+ 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69,
+ 0x6e, 0x67, 0x66, 0x61, 0x6e, 0x63, 0x68, 0x6f, 0x72, 0xa4, 0x6b, 0x64,
+ 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66,
+ 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x63, 0x75, 0x72, 0x69, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d,
+ 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x19, 0x1, 0x0, 0x62,
+ 0x72, 0x74, 0xa6, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49,
+ 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2,
+ 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40,
+ 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
+ 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x68, 0x72,
+ 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x62, 0x69, 0x66, 0xa6, 0x6b,
+ 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60,
+ 0x6b, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73,
+ 0xf5, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa3, 0x69, 0x6d, 0x61, 0x78,
+ 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x65, 0x6e, 0x75,
+ 0x6d, 0x87, 0x6f, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x61,
+ 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x69, 0x6f, 0x69, 0x63, 0x2e, 0x69,
+ 0x66, 0x2e, 0x6c, 0x6c, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e,
+ 0x62, 0x69, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x72, 0x77, 0x68,
+ 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x72, 0x68, 0x6f, 0x69, 0x63,
+ 0x2e, 0x69, 0x66, 0x2e, 0x61, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66,
+ 0x2e, 0x73, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69,
+ 0x6e, 0x67, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1,
+ 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x63, 0x72, 0x65,
+ 0x6c, 0xa5, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61,
+ 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79,
  0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65,
- 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x66,
- 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2d, 0x74,
- 0x69, 0x6d, 0x65, 0x64, 0x6d, 0x6e, 0x6d, 0x6e, 0xa4, 0x68, 0x72, 0x65,
- 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65,
- 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65, 0x73, 0x63,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x6d,
+ 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x67, 0x64, 0x65, 0x66, 0x61,
+ 0x75, 0x6c, 0x74, 0x81, 0x65, 0x68, 0x6f, 0x73, 0x74, 0x73, 0x64, 0x68,
+ 0x72, 0x65, 0x66, 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,
+ 0x63, 0x75, 0x72, 0x69, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74,
+ 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67,
+ 0x74, 0x68, 0x19, 0x1, 0x0, 0x6c, 0x74, 0x61, 0x67, 0x2d, 0x70, 0x6f,
+ 0x73, 0x2d, 0x64, 0x65, 0x73, 0x63, 0xa2, 0x65, 0x61, 0x6c, 0x6c, 0x4f,
+ 0x66, 0x82, 0xa1, 0x64, 0x24, 0x72, 0x65, 0x66, 0x78, 0x33, 0x6f, 0x69,
+ 0x63, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2d, 0x73, 0x63, 0x68, 0x65,
+ 0x6d, 0x61, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x23, 0x2f, 0x64, 0x65, 0x66,
+ 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x70, 0x6f, 0x73,
+ 0x2d, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
+ 0x73, 0xa1, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5,
+ 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
+ 0x60, 0x6b, 0x74, 0x61, 0x67, 0x2d, 0x70, 0x6f, 0x73, 0x2d, 0x72, 0x65,
+ 0x6c, 0xa6, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
+ 0x6f, 0x6e, 0x60, 0x68, 0x6d, 0x61, 0x78, 0x49, 0x74, 0x65, 0x6d, 0x73,
+ 0x3, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa3, 0x67, 0x6d, 0x61, 0x78,
+ 0x69, 0x6d, 0x75, 0x6d, 0x1, 0x67, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75,
+ 0x6d, 0x20, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6e, 0x75, 0x6d, 0x62,
+ 0x65, 0x72, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61,
+ 0x79, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x68,
+ 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x3, 0x65, 0x74, 0x69,
+ 0x74, 0x6c, 0x65, 0xa3, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e,
+ 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73,
+ 0x74, 0x72, 0x69, 0x6e, 0x67, 0x64, 0x74, 0x79, 0x70, 0x65, 0xa5, 0x65,
+ 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65,
+ 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
+ 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
+ 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x6d, 0x69, 0x6e, 0x49,
+ 0x74, 0x65, 0x6d, 0x73, 0x1, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61,
+ 0x72, 0x72, 0x61, 0x79, 0x67, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74,
+ 0x78, 0x18, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f,
+ 0x6e, 0x2f, 0x76, 0x6e, 0x64, 0x2e, 0x6f, 0x63, 0x66, 0x2b, 0x63, 0x62,
+ 0x6f, 0x72, 0x63, 0x65, 0x70, 0x73, 0xa3, 0x65, 0x69, 0x74, 0x65, 0x6d,
+ 0x73, 0xa2, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65,
+ 0x73, 0xa2, 0x62, 0x65, 0x70, 0xa3, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
+ 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x66, 0x6f, 0x72, 0x6d,
+ 0x61, 0x74, 0x63, 0x75, 0x72, 0x69, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
+ 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x63, 0x70, 0x72, 0x69, 0xa3, 0x6b,
+ 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60,
+ 0x67, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x1, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x6b, 0x64,
+ 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x63, 0x69,
+ 0x6e, 0x73, 0xa2, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x64, 0x74, 0x79, 0x70, 0x65, 0x67, 0x69, 0x6e,
+ 0x74, 0x65, 0x67, 0x65, 0x72, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f,
+ 0x62, 0x6a, 0x65, 0x63, 0x74, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61,
+ 0x72, 0x72, 0x61, 0x79, 0x68, 0x48, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74,
+ 0x79, 0xa3, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x81,
+ 0x68, 0x68, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x6a, 0x70, 0x72,
+ 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xa5, 0x6f, 0x64, 0x65,
+ 0x73, 0x69, 0x72, 0x65, 0x64, 0x48, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74,
+ 0x79, 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
+ 0x6f, 0x6e, 0x60, 0x67, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x18,
+ 0x64, 0x67, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x0, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x62,
+ 0x72, 0x74, 0xa7, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49,
+ 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61,
+ 0x72, 0x72, 0x61, 0x79, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa3, 0x69,
+ 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64,
+ 0x65, 0x6e, 0x75, 0x6d, 0x81, 0x6e, 0x6f, 0x69, 0x63, 0x2e, 0x72, 0x2e,
+ 0x68, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x67, 0x64, 0x65, 0x66,
+ 0x61, 0x75, 0x6c, 0x74, 0x81, 0x6e, 0x6f, 0x69, 0x63, 0x2e, 0x72, 0x2e,
+ 0x68, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x68, 0x72, 0x65, 0x61,
+ 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74,
+ 0x65, 0x6d, 0x73, 0x1, 0x61, 0x6e, 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63,
  0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x69, 0x6d, 0x61, 0x78,
- 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x62, 0x72, 0x74, 0xa6,
- 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x64, 0x74, 0x79, 0x70, 0x65,
- 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d, 0x61, 0x78, 0x4c,
- 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x68, 0x6d, 0x69, 0x6e, 0x49,
- 0x74, 0x65, 0x6d, 0x73, 0x1, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
- 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f,
- 0x6e, 0x6c, 0x79, 0xf5, 0x67, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74,
- 0x81, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x77, 0x6b, 0x2e, 0x70, 0x64, 0x74,
- 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x64, 0x6d, 0x6e,
- 0x64, 0x74, 0xa1, 0x65, 0x61, 0x6c, 0x6c, 0x4f, 0x66, 0x82, 0xa3, 0x64,
- 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6b,
+ 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x68, 0x72, 0x65, 0x61,
+ 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
+ 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x68, 0x68, 0x75, 0x6d, 0x69, 0x64,
+ 0x69, 0x74, 0x79, 0xa5, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64, 0x74, 0x79, 0x70, 0x65, 0x67, 0x69,
+ 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x67, 0x6d, 0x61, 0x78, 0x69, 0x6d,
+ 0x75, 0x6d, 0x18, 0x64, 0x67, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d,
+ 0x0, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x62,
+ 0x69, 0x66, 0xa6, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
+ 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49,
+ 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2,
+ 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x82, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69,
+ 0x66, 0x2e, 0x61, 0x6f, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62,
+ 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x64, 0x74, 0x79, 0x70, 0x65,
+ 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x68, 0x6d, 0x69, 0x6e, 0x49,
+ 0x74, 0x65, 0x6d, 0x73, 0x2, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e,
+ 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72,
+ 0x61, 0x79, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65,
+ 0x63, 0x74, 0x6e, 0x48, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x55,
+ 0x70, 0x64, 0x61, 0x74, 0x65, 0xa3, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69,
+ 0x72, 0x65, 0x64, 0x81, 0x6f, 0x64, 0x65, 0x73, 0x69, 0x72, 0x65, 0x64,
+ 0x48, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x6a, 0x70, 0x72, 0x6f,
+ 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xa1, 0x6f, 0x64, 0x65, 0x73,
+ 0x69, 0x72, 0x65, 0x64, 0x48, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79,
+ 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
+ 0x6e, 0x60, 0x67, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x18, 0x64,
+ 0x67, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x0, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x6d, 0x73,
+ 0x62, 0x61, 0x74, 0x63, 0x68, 0x2d, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65,
+ 0xa4, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa5, 0x68, 0x72, 0x65, 0x71,
+ 0x75, 0x69, 0x72, 0x65, 0x64, 0x82, 0x64, 0x68, 0x72, 0x65, 0x66, 0x63,
+ 0x72, 0x65, 0x70, 0x74, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e,
+ 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73,
+ 0xf5, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
+ 0x6e, 0x60, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65,
+ 0x73, 0xa2, 0x63, 0x72, 0x65, 0x70, 0xa0, 0x64, 0x68, 0x72, 0x65, 0x66,
+ 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
+ 0x6e, 0x60, 0x66, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x63, 0x75, 0x72,
+ 0x69, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e,
+ 0x67, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x19,
+ 0x1, 0x0, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65,
+ 0x63, 0x74, 0x65, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x78, 0x1e, 0x43, 0x6f,
+ 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x42, 0x61, 0x74,
+ 0x63, 0x68, 0x20, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x46, 0x6f,
+ 0x72, 0x6d, 0x61, 0x74, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72,
+ 0x72, 0x61, 0x79, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73,
+ 0x1, 0x69, 0x73, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0xa4,
+ 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x83, 0x65, 0x6c,
+ 0x69, 0x6e, 0x6b, 0x73, 0x62, 0x72, 0x74, 0x62, 0x69, 0x66, 0x74, 0x61,
+ 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x6f,
+ 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xf5, 0x6a, 0x70, 0x72, 0x6f,
+ 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xa6, 0x65, 0x6c, 0x69, 0x6e,
+ 0x6b, 0x73, 0xa3, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa3, 0x68, 0x72,
+ 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x81, 0x64, 0x68, 0x72, 0x65,
+ 0x66, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73,
+ 0xad, 0x61, 0x70, 0xa4, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65,
+ 0x64, 0x81, 0x62, 0x62, 0x6d, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65,
+ 0x72, 0x74, 0x69, 0x65, 0x73, 0xa1, 0x62, 0x62, 0x6d, 0xa2, 0x6b, 0x64,
+ 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72,
+ 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74,
+ 0x62, 0x64, 0x69, 0xa3, 0x67, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e,
+ 0x78, 0x4d, 0x5e, 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d,
+ 0x39, 0x5d, 0x7b, 0x38, 0x7d, 0x2d, 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d,
+ 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x34, 0x7d, 0x2d, 0x5b, 0x61, 0x2d,
+ 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x34, 0x7d, 0x2d,
+ 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d, 0x39, 0x5d, 0x7b,
+ 0x34, 0x7d, 0x2d, 0x5b, 0x61, 0x2d, 0x66, 0x41, 0x2d, 0x46, 0x30, 0x2d,
+ 0x39, 0x5d, 0x7b, 0x31, 0x32, 0x7d, 0x24, 0x6b, 0x64, 0x65, 0x73, 0x63,
+ 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6d, 0x74, 0x61, 0x67,
+ 0x2d, 0x66, 0x75, 0x6e, 0x63, 0x2d, 0x64, 0x65, 0x73, 0x63, 0xa3, 0x6b,
  0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60,
- 0x67, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x78, 0x3a, 0x5e, 0x28,
- 0x5b, 0x30, 0x2d, 0x39, 0x5d, 0x7b, 0x34, 0x7d, 0x29, 0x2d, 0x28, 0x31,
- 0x5b, 0x30, 0x2d, 0x32, 0x5d, 0x7c, 0x30, 0x5b, 0x31, 0x2d, 0x39, 0x5d,
- 0x29, 0x2d, 0x28, 0x33, 0x5b, 0x30, 0x2d, 0x31, 0x5d, 0x7c, 0x32, 0x5b,
- 0x30, 0x2d, 0x39, 0x5d, 0x7c, 0x31, 0x5b, 0x30, 0x2d, 0x39, 0x5d, 0x7c,
- 0x30, 0x5b, 0x31, 0x2d, 0x39, 0x5d, 0x29, 0x24, 0xa2, 0x68, 0x72, 0x65,
- 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x6b, 0x64, 0x65, 0x73, 0x63,
- 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64, 0x6d, 0x6e, 0x73,
- 0x6c, 0xa5, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5,
- 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
+ 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x66, 0x61,
+ 0x6e, 0x63, 0x68, 0x6f, 0x72, 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
+ 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x66, 0x6f, 0x72, 0x6d,
+ 0x61, 0x74, 0x63, 0x75, 0x72, 0x69, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
+ 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65,
+ 0x6e, 0x67, 0x74, 0x68, 0x19, 0x1, 0x0, 0x62, 0x72, 0x74, 0xa6, 0x6b,
+ 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60,
+ 0x6b, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73,
+ 0xf5, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61, 0x78,
+ 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x68, 0x6d, 0x69, 0x6e,
+ 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f,
+ 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72,
+ 0x72, 0x61, 0x79, 0x62, 0x69, 0x66, 0xa6, 0x6b, 0x64, 0x65, 0x73, 0x63,
+ 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75, 0x6e, 0x69,
+ 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x65, 0x69, 0x74,
+ 0x65, 0x6d, 0x73, 0xa3, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67,
+ 0x74, 0x68, 0x18, 0x40, 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x87, 0x6f, 0x6f,
+ 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x61, 0x73, 0x65, 0x6c, 0x69,
+ 0x6e, 0x65, 0x69, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x6c, 0x6c,
+ 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x69, 0x6f, 0x69,
+ 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x72, 0x77, 0x68, 0x6f, 0x69, 0x63, 0x2e,
+ 0x69, 0x66, 0x2e, 0x72, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e,
+ 0x61, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x73, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x68, 0x6d,
+ 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x68, 0x72, 0x65, 0x61,
+ 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65,
+ 0x61, 0x72, 0x72, 0x61, 0x79, 0x63, 0x72, 0x65, 0x6c, 0xa5, 0x65, 0x69,
+ 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e,
+ 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73,
+ 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74,
+ 0x65, 0x6d, 0x73, 0x1, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72,
+ 0x72, 0x61, 0x79, 0x67, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x81,
+ 0x65, 0x68, 0x6f, 0x73, 0x74, 0x73, 0x64, 0x74, 0x79, 0x70, 0x65, 0xa5,
+ 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61, 0x78, 0x4c,
+ 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70, 0x65,
+ 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x6b, 0x64, 0x65, 0x73, 0x63,
+ 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x6d, 0x69, 0x6e,
+ 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65,
+ 0x61, 0x72, 0x72, 0x61, 0x79, 0x67, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c,
+ 0x74, 0x78, 0x18, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69,
+ 0x6f, 0x6e, 0x2f, 0x76, 0x6e, 0x64, 0x2e, 0x6f, 0x63, 0x66, 0x2b, 0x63,
+ 0x62, 0x6f, 0x72, 0x6b, 0x74, 0x61, 0x67, 0x2d, 0x70, 0x6f, 0x73, 0x2d,
+ 0x72, 0x65, 0x6c, 0xa6, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x6d, 0x61, 0x78, 0x49, 0x74, 0x65,
+ 0x6d, 0x73, 0x3, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa3, 0x67, 0x6d,
+ 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x1, 0x67, 0x6d, 0x69, 0x6e, 0x69,
+ 0x6d, 0x75, 0x6d, 0x20, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6e, 0x75,
+ 0x6d, 0x62, 0x65, 0x72, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72,
+ 0x72, 0x61, 0x79, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79,
+ 0xf5, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x3, 0x65,
+ 0x74, 0x69, 0x74, 0x6c, 0x65, 0xa3, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
+ 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x69, 0x6d, 0x61, 0x78, 0x4c,
+ 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70, 0x65,
+ 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x63, 0x69, 0x6e, 0x73, 0xa2,
  0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
- 0x60, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x19,
- 0x1, 0x0, 0x66, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x63, 0x75, 0x72,
- 0x69, 0x68, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x82, 0x62,
- 0x70, 0x69, 0x64, 0x6d, 0x6e, 0x6d,0x6e};
+ 0x60, 0x64, 0x74, 0x79, 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74, 0x65, 0x67,
+ 0x65, 0x72, 0x63, 0x65, 0x70, 0x73, 0xa3, 0x65, 0x69, 0x74, 0x65, 0x6d,
+ 0x73, 0xa2, 0x6a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65,
+ 0x73, 0xa2, 0x62, 0x65, 0x70, 0xa3, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72,
+ 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x66, 0x6f, 0x72, 0x6d,
+ 0x61, 0x74, 0x63, 0x75, 0x72, 0x69, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66,
+ 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x63, 0x70, 0x72, 0x69, 0xa3, 0x6b,
+ 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60,
+ 0x67, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x1, 0x64, 0x74, 0x79,
+ 0x70, 0x65, 0x67, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x6b, 0x64,
+ 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x64, 0x68,
+ 0x72, 0x65, 0x66, 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
+ 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x66, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,
+ 0x63, 0x75, 0x72, 0x69, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74,
+ 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67,
+ 0x74, 0x68, 0x19, 0x1, 0x0, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f,
+ 0x62, 0x6a, 0x65, 0x63, 0x74, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65,
+ 0x61, 0x72, 0x72, 0x61, 0x79, 0x62, 0x72, 0x74, 0xa7, 0x6b, 0x64, 0x65,
+ 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75,
+ 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79, 0x65, 0x69,
+ 0x74, 0x65, 0x6d, 0x73, 0xa3, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e,
+ 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x65, 0x6e, 0x75, 0x6d, 0x81, 0x6a,
+ 0x6f, 0x69, 0x63, 0x2e, 0x77, 0x6b, 0x2e, 0x63, 0x6f, 0x6c, 0x64, 0x74,
+ 0x79, 0x70, 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x67, 0x64,
+ 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x81, 0x6a, 0x6f, 0x69, 0x63, 0x2e,
+ 0x77, 0x6b, 0x2e, 0x63, 0x6f, 0x6c, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f,
+ 0x6e, 0x6c, 0x79, 0xf5, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d,
+ 0x73, 0x1, 0x61, 0x6e, 0xa4, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65,
+ 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f,
+ 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74,
+ 0x72, 0x69, 0x6e, 0x67, 0x65, 0x72, 0x74, 0x73, 0x2d, 0x6d, 0xa6, 0x6b,
+ 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60,
+ 0x6b, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73,
+ 0xf5, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61, 0x78,
+ 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70,
+ 0x65, 0x66, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x68, 0x6d, 0x69, 0x6e,
+ 0x49, 0x74, 0x65, 0x6d, 0x73, 0x1, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f,
+ 0x6e, 0x6c, 0x79, 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72,
+ 0x72, 0x61, 0x79, 0x63, 0x72, 0x74, 0x73, 0xa6, 0x6b, 0x64, 0x65, 0x73,
+ 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x6b, 0x75, 0x6e,
+ 0x69, 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x65, 0x69,
+ 0x74, 0x65, 0x6d, 0x73, 0xa2, 0x69, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e,
+ 0x67, 0x74, 0x68, 0x18, 0x40, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73,
+ 0x74, 0x72, 0x69, 0x6e, 0x67, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65,
+ 0x6d, 0x73, 0x1, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79,
+ 0xf5, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72, 0x72, 0x61, 0x79,
+ 0x62, 0x69, 0x66, 0xa7, 0x6b, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49,
+ 0x74, 0x65, 0x6d, 0x73, 0xf5, 0x6b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
+ 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x60, 0x68, 0x6d, 0x61, 0x78, 0x49, 0x74,
+ 0x65, 0x6d, 0x73, 0x4, 0x65, 0x69, 0x74, 0x65, 0x6d, 0x73, 0xa3, 0x69,
+ 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x40, 0x64,
+ 0x65, 0x6e, 0x75, 0x6d, 0x83, 0x69, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66,
+ 0x2e, 0x6c, 0x6c, 0x68, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62,
+ 0x6f, 0x6f, 0x69, 0x63, 0x2e, 0x69, 0x66, 0x2e, 0x62, 0x61, 0x73, 0x65,
+ 0x6c, 0x69, 0x6e, 0x65, 0x64, 0x74, 0x79, 0x70, 0x65, 0x66, 0x73, 0x74,
+ 0x72, 0x69, 0x6e, 0x67, 0x64, 0x74, 0x79, 0x70, 0x65, 0x65, 0x61, 0x72,
+ 0x72, 0x61, 0x79, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79,
+ 0xf5, 0x68, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x2, 0x64,
+ 0x74, 0x79, 0x70, 0x65, 0x66, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x68,
+ 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x73, 0x81, 0x70, 0x61, 0x70,
+ 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x6a, 0x73,
+ 0x6f, 0x6e, 0x68, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x73, 0x81,
+ 0x70, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,
+ 0x2f, 0x6a, 0x73, 0x6f,0x6e};
+#endif /* OC_IDD_API */
 
 #endif /* INTROSPECTION_INCLUDE_H */
diff --git a/port/linux/Makefile b/port/linux/Makefile
index 2f05434a..a9d6dee1 100644
--- a/port/linux/Makefile
+++ b/port/linux/Makefile
@@ -92,6 +92,7 @@ SRC=$(wildcard ../../messaging/coap/*.c ../../api/*.c ../../port/linux/*.c)
 SRC_CLOUD=$(wildcard ../../api/cloud/*.c)
 
 HEADERS = $(wildcard ../../include/*.h)
+HEADERS += ../../apps/Certification.h
 HEADERS += ../../port/linux/oc_config.h
 
 HEADERS_COAP = $(wildcard ../../messaging/coap/*.h)
@@ -111,7 +112,7 @@ OBJ_CLIENT_SERVER=$(addprefix obj/client_server/,$(notdir $(SRC:.c=.o)))
 VPATH=../../messaging/coap/:../../util/:../../api/:../../deps/tinycbor/src/:../../deps/mbedtls/library:../../api/c-timestamp:../../service/cloud/src/:../../service/resource-directory/client/src/:
 LIBS?= -lm -pthread -lrt
 
-SAMPLES = server client temp_sensor simpleserver simpleserver_pki simpleclient client_collections_linux \
+SAMPLES = CertificationApp discover_device server client temp_sensor simpleserver simpleserver_pki simpleclient client_collections_linux \
 	  server_collections_linux server_block_linux client_block_linux smart_home_server_linux multi_device_server multi_device_client smart_lock server_multithread_linux client_multithread_linux
 
 ifeq ($(CREATE),1)
@@ -138,6 +139,10 @@ endif
 
 OBT = onboarding_tool
 
+ifeq ($(IDD),1)
+	CFLAGS += -DOC_IDD_API
+endif
+
 ifeq ($(DEBUG),1)
 	EXTRA_CFLAGS += -DOC_DEBUG -g -O0
 ifeq ($(DEBUG_TLS),1)
@@ -378,6 +383,14 @@ client_multithread_linux: libiotivity-lite-client.a $(ROOT_DIR)/apps/client_mult
 	@mkdir -p $@_creds
 	${CC} -o $@ ../../apps/client_multithread_linux.c libiotivity-lite-client.a -DOC_CLIENT ${CFLAGS}  ${LIBS}
 
+CertificationApp: libiotivity-lite-client-server.a $(ROOT_DIR)/apps/CertificationApp.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/device_builder_server.c ../../apps/CertificationApp.c libiotivity-lite-client-server.a -DOC_CLIENT -DOC_SERVER  ${CFLAGS} ${CFLAGS_CLOUD} ${LIBS}
+
+discover_device: libiotivity-lite-client.a $(ROOT_DIR)/apps/discover_device.c
+	@mkdir -p $@_creds
+	${CC} -o $@ ../../apps/discover_device.c libiotivity-lite-client.a -DOC_CLIENT ${CFLAGS}  ${LIBS}
+
 iotivity-lite-server.pc: iotivity-lite-server.pc.in
 	$(SED) > $@ < $< \
 		-e 's,@prefix@,$(prefix),' \
diff --git a/tests/automation/ctt/Makefile b/tests/automation/ctt/Makefile
new file mode 100644
index 00000000..efd6d573
--- /dev/null
+++ b/tests/automation/ctt/Makefile
@@ -0,0 +1,3 @@
+        #include system configured UV lib path
+tafagent: src/ResourceMap.c src/TAFAgent.c src/MiniHttpServer.c src/DUTController.c
+		gcc -o tafagent src/ResourceMap.c src/TAFAgent.c src/MiniHttpServer.c src/DUTController.c -luv -lxml2 -lm -I ./include -I /usr/include/libxml2 -I /usr/include -I /usr/local/include/uv -L /usr/local/lib/ -lpthread
\ No newline at end of file
diff --git a/tests/automation/ctt/README.rst b/tests/automation/ctt/README.rst
new file mode 100644
index 00000000..41b14223
--- /dev/null
+++ b/tests/automation/ctt/README.rst
@@ -0,0 +1,86 @@
+Getting Started
+---------------
+
+- Grab source and dependencies using:
+  ``git clone https://gerrit.iotivity.org/gerrit/iotivity-lite``
+  and setup source tree.
+  For more information, please refer `this <https://github.com/iotivity/iotivity-lite/blob/master/README.rst>`_ README.
+
+- Please go `here <https://gerrit.iotivity.org/gerrit/#/c/29300/>`_ and click on ``Download``
+  (present on the top right-hand side of the web-page when using old UI OR above all the files on the RHS when using new UI). 
+  Copy to clipboard, the ``git pull`` command with the ``https://`` URL.
+
+- Move to iotivity-lite folder on the terminal and run the ``git pull`` command with the URL copied in the previous step so as to pull the patch
+  having source codes of CertificationApp, tafagent etc.,
+
+Contents
+--------
+
+- `Building CertificationApp and other sample applications on Linux`_
+- `Steps to be followed to Run TAF Agent along with CTT`_
+
+Building CertificationApp and other sample applications on Linux
+----------------------------------------------------------------
+
+- Move to the ``iotivity-lite/port/linux`` folder on the terminal.
+
+- Generate CertificationApp.exe and other object files by running the below command
+  ``make TCP=1 CLOUD=1 IDD=1 CREATE=1``
+
+Steps to be followed to Run TAF Agent along with CTT
+----------------------------------------------------
+
+- Move to ``iotivity-lite/tests/automation/ctt`` folder on the terminal.
+
+- In "TAFAgent.h" present in "include" folder, set the char variable "globalIPv6_firstHextet[5]" to have the first hextet of the
+  global IPv6 address of the machine on which "tafagent" and "CertificationApp" would be run.
+
+- In the configuration file i.e., ``server_config.txt`` or ``client_config.txt`` file, please mention all test case numbers of test cases on CTT(e.g., CT1.1.1, CT1.2.10 etc.,) that need to be run.
+  Configuration file should also have relevant PICS details.
+
+- 'run_taf_agent.sh' has required commands to build CertificationApp.c, discover_device.c etc., present in ``iotivity-lite/port/linux`` folder.
+  It has ``make`` command to build TAFAgent.c and generate the executable ``tafgent``. Further, it also has the command to run ``tafgent``.
+
+- The command in 'run_taf_agent.sh' to run TAFAgent executable is as follows:
+  ``./tafgent configurationFile QoS_arg IPversion_arg Security_arg OCFVersion_arg LocalMachineIPv4Addr_arg IUTInterfaceIndex_arg CTTScopeID TAF_mode CertAppInput1 CertAppInput2``
+  E.g.: ``./tafagent server_config.txt 1 6 13 2.0.2 192.168.3.66 2 10 server 1 6``
+
+- Arguments passed in the above line are
+      i.    tafgent - TAFAgent.c executable
+      ii.   configurationFile - "server_config.txt" to run server testcases or "client_config.txt" to run client testcases
+      iii.  QoS_arg - Quality of Service Argument; sets the QoS
+      iv.   IPversion_arg - IP version argument (4 or 6)
+      v.    Security_arg - Argument that specifies security type(e.g. 13 - manufacturing certificate, 12 - random pin and 11 - Just Works)
+      vi.   OCFVersion_arg - Argument that specifies OCF version(e.g. 2.0.2, 2.0.0, 1.3.0 etc.,)
+      vii.  LocalMachineIPv4Addr_arg - Specifies the IPv4 address of the machine on which TAFAgent and CertificationApp run.
+      viii. IUTInterfaceIndex_arg - Specifies the interface index of the interface on which TAFAgent and CertificationApp run.
+      ix.   CTTScopeID - Specifies the scope ID of the interface on which CTT runs
+      x.    TAFmode - Should be "server" or "client" depending on what the IUT should run as
+      xi.   CertAppInput1 - An input to CertificationApp (e.g. 1 - to create a resource)
+      xii.  CertAppInput2 - Another input to CertificationApp (e.g. 6 - to create a Group resource)
+
+- Run ``./run_taf_agent.sh``. This generates following executables: CertificationApp, discover_device and tafgent (It also installs required packages).
+
+- Please ensure that the appropriate ``libuv`` path is mentioned in the ``Makefile`` present in ``iotivity-lite/tests/automation/ctt``.
+  (Note: libuv-v1.24.0 has been found to work fine. Some other versions *may* work fine as well).
+
+- After running TAFAgent, please wait till a message saying "Entering TAF Agent main loop..." appears on terminal and then open CTT, click on ``Test Run``and then on ``Automation``
+
+- Set the appropriate ``NetworkInterface``
+
+- Set the following port values
+
+  - ``Basic API port`` as: 32000
+
+  - ``Extended API port`` as: 32001
+
+  - ``Setup API port`` as: 32002
+
+- Set ``Remote IP address`` to be the IP address of Linux machine that runs the tafagent.
+
+- Then select ``Basic API`` and ``Setup API`` by clicking on corresponding check boxes.
+  (*Check box corresponding to ``Extended API`` is to be left unchecked*)
+
+- Then click on ``Connect``.
+
+- CTT then connects to TAF agent, following which TAF agent would communicate with CertificationApp.
diff --git a/tests/automation/ctt/client_config.txt b/tests/automation/ctt/client_config.txt
new file mode 100644
index 00000000..137c8d3c
--- /dev/null
+++ b/tests/automation/ctt/client_config.txt
@@ -0,0 +1,131 @@
+<configuration>
+  <endpoint>
+    <ip>%IP%</ip>
+    <port>%PORT%</port>
+  </endpoint>
+  <deviceClass>OCFClient</deviceClass>
+  <profiles>
+    <profile>Client</profile>
+  </profiles>
+  <testCases>
+    <testCase>CT1.1.1</testCase>
+    <testCase>CT1.1.2</testCase>
+    <testCase>CT1.1.3</testCase>
+    <testCase>CT1.1.4</testCase>
+    <testCase>CT1.1.5</testCase>
+    <testCase>CT1.1.6</testCase>
+    <testCase>CT1.1.7</testCase>
+    <testCase>CT1.1.8</testCase>
+    <testCase>CT1.2.2</testCase>
+    <testCase>CT1.2.3</testCase>
+    <testCase>CT1.2.4</testCase>
+    <testCase>CT1.2.6</testCase>
+    <testCase>CT1.2.25</testCase>
+    <testCase>CT1.2.27</testCase>
+    <testCase>CT1.3.1</testCase>
+    <testCase>CT1.3.2.1</testCase>
+    <testCase>CT1.3.2.2</testCase>
+    <testCase>CT1.3.8</testCase>
+    <testCase>CT1.3.9</testCase>
+    <testCase>CT1.3.9_BZ_3143</testCase>
+    <testCase>CT1.3.10</testCase>
+    <testCase>CT1.3.11</testCase>
+    <testCase>CT1.3.12</testCase>
+    <testCase>CT1.3.13</testCase>
+    <testCase>CT1.3.16</testCase>
+    <testCase>CT1.7.2.1.2</testCase>
+    <testCase>CT1.7.2.1.2_BZ_3052</testCase>
+    <testCase>CT1.7.2.2.2</testCase>
+    <testCase>CT1.7.2.2.2_BZ_3052</testCase>
+    <testCase>CT1.7.2.3.2</testCase>
+    <testCase>CT1.7.2.3.3</testCase>
+    <testCase>CT1.7.2.3.3_BZ_3052</testCase>
+    <testCase>CT1.7.2.3.3_BZ_3067</testCase>
+    <testCase>CT1.7.3.2</testCase>
+    <testCase>CT1.7.4.1</testCase>
+    <testCase>CT1.7.4.2</testCase>
+    <testCase>CT1.7.4.3</testCase>
+    <testCase>CT1.7.4.4</testCase>
+    <testCase>CT1.7.4.5</testCase>
+    <testCase>CT1.7.4.5_BZ_3069</testCase>
+    <testCase>CT1.7.4.7</testCase>
+    <testCase>CT1.7.5.1</testCase>
+    <testCase>CT1.7.5.2</testCase>
+    <testCase>CT1.7.7.1</testCase>
+    <testCase>CT1.7.8.1</testCase>
+    <testCase>CT1.7.8.2</testCase>
+    <testCase>CT1.7.8.3</testCase>
+    <testCase>CT1.7.8.4</testCase>
+    <testCase>CT1.7.8.4_BZ_3144</testCase>
+    <testCase>CT1.7.8.5</testCase>
+    <testCase>CT1.7.8.7</testCase>
+    <testCase>CT1.7.8.9</testCase>
+    <testCase>CT1.7.8.11</testCase>
+    <testCase>CT1.7.8.12</testCase>
+    <testCase>CT1.7.8.13</testCase>
+    <testCase>CT1.7.8.13_BZ_3144</testCase>
+    <testCase>CT1.7.8.14</testCase>
+    <testCase>CT1.7.8.15</testCase>
+    <testCase>CT1.7.9.1</testCase>
+    <testCase>CT1.7.9.2</testCase>
+    <testCase>CT1.7.9.3</testCase>
+    <testCase>CT1.7.9.4</testCase>
+    <testCase>CT1.7.9.5</testCase>
+    <testCase>CT1.7.9.6.1</testCase>
+    <testCase>CT1.7.9.6.2</testCase>
+    <testCase>CT1.7.9.6.3</testCase>
+    <testCase>CT1.7.9.7</testCase>
+    <testCase>CT1.7.10.3</testCase>
+    <testCase>CT1.7.10.4</testCase>
+    <testCase>CT1.7.10.5</testCase>
+    <testCase>CT1.7.10.6</testCase>
+    <testCase>CT1.7.10.7</testCase>
+    <testCase>CT1.7.11.1</testCase>
+    <testCase>CT1.7.11.2</testCase>
+    <testCase>CT1.7.11.3</testCase>
+    <testCase>CT1.7.12.1</testCase>
+    <testCase>CT1.7.12.1_BZ_3145</testCase>
+    <testCase>CT1.7.12.2</testCase>
+    <testCase>CT1.7.12.3</testCase>
+    <testCase>CT1.7.12.4</testCase>
+    <testCase>CT1.7.12.5</testCase>
+    <testCase>CT2.1.1</testCase>
+    <testCase>CT2.1.2</testCase>
+    <testCase>CT2.1.3</testCase>
+    <testCase>CT2.1.4</testCase>
+    <testCase>CT2.1.5</testCase>
+    <testCase>CT2.1.6</testCase>
+    <testCase>CT2.2.2</testCase>
+    <testCase>CT2.2.2</testCase>
+    <testCase>CT2.2.3</testCase>
+    <testCase>CT2.2.6</testCase>
+    <testCase>CT2.2.7</testCase>
+    <testCase>CT2.3.1</testCase>
+    <testCase>CT2.3.2</testCase>
+    <testCase>CT2.3.3</testCase>
+   </testCases>
+  <pics>{
+    "company": "GRL",
+    "device": "IoTLite-CertAppAsClient",
+    "role": "Client",
+    "supportedVerticalProfile": ["Smart Home"],
+    "supportedDeviceTypes": ["oic.d.dehumidifier"],
+    "icv": "ocf.2.0.5",
+    "dmv": "ocf.res.1.3.0, ocf.sh.1.3.0",
+    "resources": [ "oic.r.switch.binary", "oic.r.humidity", "oic.wk.col", "oic.r.coapcloudconf", "oic.r.csr", "oic.r.roles", "oic.r.sp"],
+    "jurisdictionSwitch": false,
+    "OTM":["oic.sec.doxm.mfgcert", "oic.sec.doxm.jw", "oic.sec.doxm.rdp"],
+    "contentFormatVersion": [ "1.0.0" ],
+    "acceptVersion": [ "1.0.0" ],
+    "multiValueQuerySupport":true,
+    "sct": 9,
+    "observableOICRES":true,
+    "persistentDeviceuuid": false,
+    "batchInterface": true,
+    "supportsCoAPoverTCP": true,
+    "supportedSecurityProfiles":[
+       "sp-baseline-v0",
+        "sp-black-v0"
+    ]
+}</pics>
+</configuration>
\ No newline at end of file
diff --git a/tests/automation/ctt/include/DUTController.h b/tests/automation/ctt/include/DUTController.h
new file mode 100755
index 00000000..173bf1f2
--- /dev/null
+++ b/tests/automation/ctt/include/DUTController.h
@@ -0,0 +1,49 @@
+/******************************************************************
+ *
+ * Copyright 2016 Granite River Labs All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+#ifndef __DUTLIBC_H__
+#define __DUTLIBC_H__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <libxml/tree.h>
+#include <ResourceMap.h>
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+void initDutControllers();
+void addRouteBasic(const char* method, const char* path, resourceCB onResource, afterResourceCB onAfterResource);
+void addRouteSetup(const char* method, const char* path, resourceCB onResource, afterResourceCB onAfterResource);
+void addRouteExtended(const char* method, const char* path, resourceCB onResource, afterResourceCB onAfterResource);
+void startDutControllerBasic(const char* ip, int port);
+void startDutControllerSetup(const char* ip, int port);
+void startDutControllerExtended(const char* ip, int port);
+void stopDutControllers();
+void disposeDutControllers();
+xmlDocPtr stringToDoc(const char* str);
+char* docToString(xmlDocPtr doc);
+
+#ifdef __cplusplus
+}
+#endif
+#endif //__DUTLIBC_H__
diff --git a/tests/automation/ctt/include/MiniHttpServer.h b/tests/automation/ctt/include/MiniHttpServer.h
new file mode 100755
index 00000000..02aa44af
--- /dev/null
+++ b/tests/automation/ctt/include/MiniHttpServer.h
@@ -0,0 +1,41 @@
+/******************************************************************
+ *
+ * Copyright 2016 Granite River Labs All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+#ifndef __MINI_HTTP_SERVER__
+#define __MINI_HTTP_SERVER__
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+typedef char* (*httpRequestCB)(const char* method, const char* url, const char* body);
+typedef void (*afterHttpRequestCB)(char* rspBody);
+void startMiniHttpServerBasic(const char* addr, int port, httpRequestCB onHttpRequest, afterHttpRequestCB onAfterHttpRequest);
+void startMiniHttpServerSetup(const char* addr, int port, httpRequestCB onHttpRequest, afterHttpRequestCB onAfterHttpRequest);
+void startMiniHttpServerExtended(const char* addr, int port, httpRequestCB onHttpRequest, afterHttpRequestCB onAfterHttpRequest);
+void stopMiniHttpServerBasic();
+void stopMiniHttpServerSetup();
+void stopMiniHttpServerExtended();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //__MINI_HTTP_SERVER__
diff --git a/tests/automation/ctt/include/ResourceMap.h b/tests/automation/ctt/include/ResourceMap.h
new file mode 100755
index 00000000..2d9211f5
--- /dev/null
+++ b/tests/automation/ctt/include/ResourceMap.h
@@ -0,0 +1,59 @@
+/******************************************************************
+ *
+ * Copyright 2016 Granite River Labs All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+#ifndef __RESOURCE_MAP_H__
+#define __RESOURCE_MAP_H__
+
+#include <libxml/parser.h>
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+typedef xmlDocPtr (*resourceCB)(xmlDocPtr);
+typedef void (*afterResourceCB)(xmlDocPtr);
+#define MAX_METHOD 32
+#define MAX_PATH 256
+typedef struct
+{
+    resourceCB onResource;
+    afterResourceCB onAfterResource;
+} ResourceCBS;
+typedef struct
+{
+    char method[MAX_METHOD + 1];
+    char path[MAX_PATH + 1];
+    ResourceCBS resourceCBS;
+    struct Resource* next;
+}Resource;
+
+typedef struct
+{
+    Resource* head;
+}ResourceMap;
+
+
+ResourceMap* createResourceMap();
+void addResourceCBS(ResourceMap* self, const char* method, const char* path, resourceCB onResource, afterResourceCB onAfterResource);
+ResourceCBS getResourceCBS(ResourceMap* self, const char* method, const char* path);
+void deleteResourceMap(ResourceMap* self);
+#ifdef __cplusplus
+}
+#endif
+#endif //__RESOURCE_MAP_H__
diff --git a/tests/automation/ctt/include/TAFAgent.h b/tests/automation/ctt/include/TAFAgent.h
new file mode 100644
index 00000000..6194680a
--- /dev/null
+++ b/tests/automation/ctt/include/TAFAgent.h
@@ -0,0 +1,122 @@
+/******************************************************************
+ *
+ * Copyright 2016 Granite River Labs All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+//Includes
+#include <unistd.h>
+#include <stdio.h>
+#include <stddef.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/wait.h>
+#include <sys/types.h>
+#include <signal.h>
+#include <ctype.h>
+#include <stdbool.h>
+#include <time.h>
+#include <DUTController.h>
+#include <ifaddrs.h>
+#include <arpa/inet.h>
+#include <pthread.h>
+#include <errno.h>
+
+//Definations
+#define TAFServerPort	5001
+#define CertAppServerPort	5000
+#define TAG                  "OCF_TAF_AGENT"
+#define DEFAULT_CONTEXT_VALUE 0x99
+#define QOS_NON               0
+#define QOS_CON               1
+#define IPv4                  4
+#define IPv6                  6
+#define SLEEP_TIME            2
+#define JUSTWORKS             1
+#define RANDOMPIN             2
+#define MFG_CERT              3
+#define FRESH_CLIENT          1
+#define REUSE_CLIENT          3
+#define FRESH_SERVER          2
+#define REUSE_SERVER          4
+
+//Global Variables//
+char gCertificationApp[24] = "CertificationApp";
+int gIPDiscovered = 0;
+int gInsideMainLoop = 0;
+pid_t gPid;
+int gQuitFlag = 0;
+int gRestartFlag = 0;
+int gReuseIUT = 0;
+char *gConfigPath = NULL;
+char *gConfigFilename = NULL;
+char *gConfigFileContent = NULL;
+char gIp[30];
+char globalBuffer[1025];
+char gLocalIp[50];
+char gPort[25];
+char gUuid[50];
+char gPinValue[9];
+char gCommandsArray[10][255];
+char *globalIPv6_firstHextet = "fe80";
+static int quit = 0;
+static pthread_mutex_t mutex;
+static pthread_cond_t cv;
+static struct timespec ts;
+char GIP[30];
+//macros//
+#define FREE(x)           if(x){free(x);x=NULL;}
+
+/////////////////////////////////////////////////////CTT Messages/////////////////////////////////////////////////////////
+#define CTTmsg1 "Waiting for CoAP response"
+#define CTTmsg2 "Please send a CoAP Ping message to the CTT"
+#define CTTmsg3 "If the device uses an OCF Rooted Certificate Chain"
+#define CTTmsg4	"Please enter PIN:"
+#define CTTmsg5	"Please initiate IUT to revert to \"ready for OTM\" state"
+#define CTTmsg6	"Please cycle power on the IUT"
+#define CTTmsg7	"Please revert IUT to RFOTM / reset the device"
+#define CTTmsg8 "Did IUT receive response:"
+#define CTTmsg9 "Was device discovered sucessfully?"
+#define CTTmsg10 "Did IUT received NOTIFY:"
+#define CTTmsg11 "Please send a multicast discovery request message"
+#define CTTmsg12 "Please initiate the Endpoint discovery process."
+#define CTTmsg13 "Please have the IUT establish a TCP connection"
+#define CTTmsg14 "send a unicast RETRIEVE request"
+#define CTTmsg15 "send a unicast partial UPDATE request"
+#define CTTmsg16 "send a unicast request message"
+#define CTTmsg17 "Does IUT have the possibility to display received properties values?"
+#define CTTmsg18 "Does IUT has discovered a device (i.e. the CTT) with the expected Resource Types?"
+#define CTTmsg19 "Does IUT presents following properties values?"
+#define CTTmsg20 "Please initiate the Resource discovery process."
+#define CTTmsg21 "Please trigger the IUT to register with the CTT Cloud"
+#define CTTmsg22 "Please trigger the IUT to log into the CTT Cloud"
+#define CTTmsg23 "Please trigger the IUT to log out of the CTT Cloud"
+#define CTTmsg24 "Please trigger the IUT to deregister from the CTT Cloud"
+#define CTTmsg25 "Please trigger the IUT to trigger the IUT to refresh the Access Token with the CTT Cloud."
+#define CTTmsg26 "Please change some value in /CoapCloudConfResURI resource or press Skip if unable to change"
+#define CTTmsg27 "Please RETRIEVE the properties of the 'oic.r.temperature' resource of CTT Server 1"
+#define CTTmsg28 "Please RETRIEVE the properties of the 'oic.r.humidity' resource of CTT Server 2"
+#define CTTmsg29 "Please change some value in /CoapCloudConfResURI resource and press OK"
+#define CTTmsg30 "Please send a RETRIEVE request message to the /oic/res resource of the OCF Server oic.d.dehumidifier"
+#define CTTmsg31 "Please configure the IUT to use the DNS server"
+#define CTTmsg32 "Does IUT present following property values?"
+
+//////////////////////////////////////////////////////////CTT Action/////////////////////////////////////////////////////////////////////////////////
+#define CTTAction1 "<actionResult><userDialogResponse><answer>Skip</answer></userDialogResponse></actionResult>"
+#define CTTAction2 "<actionResult><userDialogResponse><answer>Set_Value</answer><data>%s</data></userDialogResponse></actionResult>"
+#define CTTAction3 "<actionResult><userDialogResponse><answer>OK</answer></userDialogResponse></actionResult>"
+#define CTTAction4 "<actionResult><userDialogResponse><answer>Yes</answer></userDialogResponse></actionResult>"
diff --git a/tests/automation/ctt/run_taf_agent.sh b/tests/automation/ctt/run_taf_agent.sh
new file mode 100755
index 00000000..2b692839
--- /dev/null
+++ b/tests/automation/ctt/run_taf_agent.sh
@@ -0,0 +1,31 @@
+#!/bin/bash
+sudo apt-get update
+sudo apt-get update --fix-missing
+sudo apt-get install libuv1.dev
+sudo apt-get install libxml2-dev
+
+fuser -k 5000/tcp
+fuser -k 5001/tcp
+killall -9 tafagent
+killall -9 CertificationApp
+
+cd ../../../port/linux
+make cleanall
+make TCP=1 CLOUD=1 IDD=1 CREATE=1
+cd -
+cp ../../../port/linux/discover_device .
+cp ../../../port/linux/CertificationApp .
+
+rm -rf pki_certs
+mkdir pki_certs
+cd pki_certs
+cp ../../../../port/linux/pki_certs/* .
+cd -
+
+rm -rf CertificationApp_creds
+mkdir CertificationApp_creds
+#include system configured UV lib path
+export LD_LIBRARY_PATH=/usr/local/lib
+rm -rf tafagent
+make
+./tafagent server_config.txt 1 6 13 2.0.5 192.168.3.227 2 7 server 1 6
diff --git a/tests/automation/ctt/server_config.txt b/tests/automation/ctt/server_config.txt
new file mode 100644
index 00000000..74530b55
--- /dev/null
+++ b/tests/automation/ctt/server_config.txt
@@ -0,0 +1,146 @@
+<configuration>
+  <endpoint>
+    <ip>%IP%</ip>
+    <port>%PORT%</port>
+  </endpoint>
+  <deviceClass>OCFServer</deviceClass>
+  <profiles>
+    <profile>Server</profile>
+  </profiles>
+  <testCases>
+    <testCase>CT1.1.1</testCase>
+    <testCase>CT1.1.2</testCase>
+    <testCase>CT1.1.3</testCase>
+    <testCase>CT1.1.4</testCase>
+    <testCase>CT1.1.5</testCase>
+    <testCase>CT1.1.6</testCase>
+    <testCase>CT1.1.7</testCase>
+    <testCase>CT1.1.8</testCase>
+    <testCase>CT1.2.2</testCase>
+    <testCase>CT1.2.3</testCase>
+    <testCase>CT1.2.4</testCase>
+    <testCase>CT1.2.6</testCase>
+    <testCase>CT1.2.7</testCase>
+    <testCase>CT1.2.8</testCase>
+    <testCase>CT1.2.9</testCase>
+    <testCase>CT1.2.10</testCase>
+    <testCase>CT1.2.11</testCase>
+    <testCase>CT1.2.12</testCase>
+    <testCase>CT1.2.13</testCase>
+    <testCase>CT1.2.14</testCase>
+    <testCase>CT1.2.15</testCase>
+    <testCase>CT1.2.16</testCase>
+    <testCase>CT1.2.17</testCase>
+    <testCase>CT1.2.18</testCase>
+    <testCase>CT1.2.19</testCase>
+    <testCase>CT1.2.20</testCase>
+    <testCase>CT1.2.21</testCase>
+    <testCase>CT1.2.22</testCase>
+    <testCase>CT1.2.23</testCase>
+    <testCase>CT1.2.25</testCase>
+    <testCase>CT1.2.27</testCase>
+    <testCase>CT1.3.1</testCase>
+    <testCase>CT1.3.2.1</testCase>
+    <testCase>CT1.3.2.2</testCase>
+    <testCase>CT1.3.3.1</testCase>
+    <testCase>CT1.3.3.2</testCase>
+    <testCase>CT1.3.3.3</testCase>
+    <testCase>CT1.3.8</testCase>
+    <testCase>CT1.3.9</testCase>
+    <testCase>CT1.3.9_BZ_3243</testCase>
+    <testCase>CT1.3.10</testCase>
+    <testCase>CT1.3.11</testCase>
+    <testCase>CT1.3.12</testCase>
+    <testCase>CT1.3.13</testCase>
+    <testCase>CT1.3.16</testCase>
+    <testCase>CT1.4.1</testCase>
+    <testCase>CT1.4.2</testCase>
+    <testCase>CT1.4.3</testCase>
+    <testCase>CT1.4.4</testCase>
+    <testCase>CT1.4.5</testCase>
+    <testCase>CT1.4.5_BZ_2982</testCase>
+    <testCase>CT1.4.6</testCase>
+    <testCase>CT1.4.7</testCase>
+    <testCase>CT1.4.8</testCase>
+    <testCase>CT1.7.2.1.2</testCase>
+    <testCase>CT1.7.2.1.2_BZ_3052</testCase>
+    <testCase>CT1.7.2.2.2</testCase>
+    <testCase>CT1.7.2.2.2_BZ_3052</testCase>
+    <testCase>CT1.7.2.3.2</testCase>
+    <testCase>CT1.7.2.3.3</testCase>
+    <testCase>CT1.7.2.3.3_BZ_3052</testCase>
+    <testCase>CT1.7.2.3.3_BZ_3067</testCase>
+    <testCase>CT1.7.3.2</testCase>
+    <testCase>CT1.7.4.1</testCase>
+    <testCase>CT1.7.4.2</testCase>
+    <testCase>CT1.7.4.3</testCase>
+    <testCase>CT1.7.4.4</testCase>
+    <testCase>CT1.7.4.5</testCase>
+    <testCase>CT1.7.4.5_BZ_3069</testCase>
+    <testCase>CT1.7.4.7</testCase>
+    <testCase>CT1.7.5.1</testCase>
+    <testCase>CT1.7.5.2</testCase>
+    <testCase>CT1.7.7.1</testCase>
+    <testCase>CT1.7.8.1</testCase>
+    <testCase>CT1.7.8.2</testCase>
+    <testCase>CT1.7.8.3</testCase>
+    <testCase>CT1.7.8.4</testCase>
+    <testCase>CT1.7.8.4_BZ_3144</testCase>
+    <testCase>CT1.7.8.5</testCase>
+    <testCase>CT1.7.8.7</testCase>
+    <testCase>CT1.7.8.9</testCase>
+    <testCase>CT1.7.8.11</testCase>
+    <testCase>CT1.7.8.12</testCase>
+    <testCase>CT1.7.8.13</testCase>
+    <testCase>CT1.7.8.13_BZ_3144</testCase>
+    <testCase>CT1.7.8.14</testCase>
+    <testCase>CT1.7.8.15</testCase>
+    <testCase>CT1.7.9.1</testCase>
+    <testCase>CT1.7.9.2</testCase>
+    <testCase>CT1.7.9.3</testCase>
+    <testCase>CT1.7.9.4</testCase>
+    <testCase>CT1.7.9.5</testCase>
+    <testCase>CT1.7.9.6.1</testCase>
+    <testCase>CT1.7.9.6.2</testCase>
+    <testCase>CT1.7.9.6.3</testCase>
+    <testCase>CT1.7.9.7</testCase>
+    <testCase>CT1.7.10.3</testCase>
+    <testCase>CT1.7.10.4</testCase>
+    <testCase>CT1.7.10.5</testCase>
+    <testCase>CT1.7.10.6</testCase>
+    <testCase>CT1.7.10.7</testCase>
+    <testCase>CT1.7.11.1</testCase>
+    <testCase>CT1.7.11.2</testCase>
+    <testCase>CT1.7.11.3</testCase>
+    <testCase>CT1.7.12.1</testCase>
+    <testCase>CT1.7.12.1_BZ_3145</testCase>
+    <testCase>CT1.7.12.2</testCase>
+    <testCase>CT1.7.12.3</testCase>
+    <testCase>CT1.7.12.4</testCase>
+    <testCase>CT1.7.12.5</testCase>
+   </testCases>
+  <pics>{
+    "device": "IoTLite-CertAppAsServer",
+    "company": "Granite River Labs",
+    "role": "Server",
+    "supportedVerticalProfile": ["Smart Home"],
+    "supportedDeviceTypes": ["oic.d.dehumidifier"],
+    "icv": "ocf.2.0.5",
+    "dmv": "ocf.res.1.3.0, ocf.sh.1.3.0",
+    "resources": [ "oic.r.switch.binary", "oic.r.humidity", "oic.wk.col", "oic.r.coapcloudconf", "oic.r.csr", "oic.r.roles", "oic.r.sp"],
+    "jurisdictionSwitch": false,
+    "optionalFeatures": ["batchInterface"],
+    "OTM":["oic.sec.doxm.mfgcert", "oic.sec.doxm.jw", "oic.sec.doxm.rdp"],
+    "contentFormatVersion": [ "1.0.0" ],
+    "acceptVersion": [ "1.0.0" ],
+    "multiValueQuerySupport":true,
+    "sct": 9,
+    "observableOICRES":false,
+    "persistentDeviceuuid": false,
+    "supportsCoAPoverTCP": true,
+    "supportedSecurityProfiles":[
+       "sp-baseline-v0",
+        "sp-black-v0"
+    ]
+}</pics>
+</configuration>
\ No newline at end of file
diff --git a/tests/automation/ctt/src/DUTController.c b/tests/automation/ctt/src/DUTController.c
new file mode 100755
index 00000000..c04b8e12
--- /dev/null
+++ b/tests/automation/ctt/src/DUTController.c
@@ -0,0 +1,262 @@
+/******************************************************************
+ *
+ * Copyright 2016 Granite River Labs All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+#include <DUTController.h>
+#include <MiniHttpServer.h>
+#include <uv.h>
+
+/*Static resources Start*/
+static ResourceMap* s_resourceMapBasic = 0;
+static ResourceMap* s_resourceMapExtended = 0;
+static ResourceMap* s_resourceMapSetup = 0;
+static uv_thread_t s_serverID;
+/*Static resource End*/
+
+/*Doc to string conversion*/
+char* docToString(xmlDocPtr doc)
+{
+    char* ret = 0;
+
+    if (doc != 0)
+    {
+        xmlChar* xmlbuff;
+        int buffersize;
+        xmlDocDumpFormatMemory(doc, &xmlbuff, &buffersize, 1);
+        ret = (char*)xmlbuff;
+    }
+
+    return ret;
+}
+
+/*String to Doc conversion*/
+xmlDocPtr stringToDoc(const char* str)
+{
+    return xmlParseMemory(str, strlen(str));
+}
+
+/*Callback Function to be invoked for Basic HTTP request*/
+char* onHttpRequestBasic(const char* method, const char* url, const char* body)
+{
+    xmlDocPtr reqDoc = 0;
+    xmlDocPtr rspDoc = 0;
+    char* ret = 0;
+    ResourceCBS resourceCBS;
+
+    if (body != 0)
+    {
+        reqDoc = stringToDoc(body);
+
+        if (reqDoc == 0) goto error;
+    }
+
+    resourceCBS = getResourceCBS(s_resourceMapBasic, method, url);
+
+    if (resourceCBS.onResource)
+    {
+        rspDoc = resourceCBS.onResource(reqDoc);
+        ret = docToString(rspDoc);
+    }
+
+    if (resourceCBS.onAfterResource)
+    {
+        resourceCBS.onAfterResource(rspDoc);
+    }
+
+    goto cleanup;
+
+error:
+    printf("Error for %s %s\n", method, url);
+
+cleanup:
+    if (reqDoc != 0)
+    {
+        xmlFreeDoc(reqDoc);
+    }
+
+    return ret;
+}
+
+/*Callback Function to be invoked after executing Basic HTTP request*/
+void onAfterHttpRequestBasic(char* rspBody)
+{
+    free(rspBody);
+}
+
+
+/*Callback Function to be invoked for Setup HTTP request*/
+char* onHttpRequestSetup(const char* method, const char* url, const char* body)
+{
+    xmlDocPtr reqDoc = 0;
+    xmlDocPtr rspDoc = 0;
+    char* ret = 0;
+    ResourceCBS resourceCBS;
+
+    if (body != 0)
+    {
+        reqDoc = stringToDoc(body);
+
+        if (reqDoc == 0) goto error;
+    }
+
+    resourceCBS = getResourceCBS(s_resourceMapSetup, method, url);
+
+    if (resourceCBS.onResource)
+    {
+        rspDoc = resourceCBS.onResource(reqDoc);
+        ret = docToString(rspDoc);
+    }
+
+    if (resourceCBS.onAfterResource)
+    {
+        resourceCBS.onAfterResource(rspDoc);
+
+    }
+
+    goto cleanup;
+
+error:
+    printf("Error for %s %s\n", method, url);
+
+cleanup:
+    if (reqDoc != 0)
+    {
+        xmlFreeDoc(reqDoc);
+    }
+
+    return ret;
+}
+
+
+/*Callback Function to be invoked after executing Setup HTTP request*/
+void onAfterHttpRequestSetup(char* rspBody)
+{
+    free(rspBody);
+}
+
+
+/*Callback Function to be invoked for Extended HTTP request*/
+char* onHttpRequestExtended(const char* method, const char* url, const char* body)
+{
+    xmlDocPtr reqDoc = 0;
+    xmlDocPtr rspDoc = 0;
+    char* ret = 0;
+    ResourceCBS resourceCBS;
+
+    if (body != 0)
+    {
+        reqDoc = stringToDoc(body);
+
+        if (reqDoc == 0) goto error;
+    }
+
+    resourceCBS = getResourceCBS(s_resourceMapExtended, method, url);
+
+    if (resourceCBS.onResource)
+    {
+        rspDoc = resourceCBS.onResource(reqDoc);
+        ret = docToString(rspDoc);
+    }
+
+    if (resourceCBS.onAfterResource)
+    {
+        resourceCBS.onAfterResource(rspDoc);
+    }
+
+    goto cleanup;
+
+error:
+    printf("Error for %s %s\n", method, url);
+
+cleanup:
+    if (reqDoc != 0)
+    {
+        xmlFreeDoc(reqDoc);
+    }
+
+    return ret;
+}
+
+
+/*Callback Function to be invoked after executing Extended HTTP request*/
+void onAfterHttpRequestExtended(char* rspBody)
+{
+    free(rspBody);
+}
+
+
+/*Init DUT Controllers related to Basic,Setup and Extended*/
+void initDutControllers()
+{
+    s_resourceMapBasic = createResourceMap();
+    s_resourceMapSetup = createResourceMap();
+    s_resourceMapExtended = createResourceMap();
+}
+
+/*Dispose DUT Controllers related to Basic,Setup and Extended*/
+void disposeDutControllers()
+{
+    deleteResourceMap(s_resourceMapBasic);
+    deleteResourceMap(s_resourceMapSetup);
+    deleteResourceMap(s_resourceMapExtended);
+}
+
+/*Add Route for Basic HTTP request*/
+void addRouteBasic(const char* method, const char* path, resourceCB onResource, afterResourceCB onAfterResource)
+{
+    addResourceCBS(s_resourceMapBasic, method, path, onResource, onAfterResource);
+}
+
+/*Add Route for Setup HTTP request*/
+void addRouteSetup(const char* method, const char* path, resourceCB onResource, afterResourceCB onAfterResource)
+{
+    addResourceCBS(s_resourceMapSetup, method, path, onResource, onAfterResource);
+}
+
+/*Add Route for Extended HTTP request*/
+void addRouteExtended(const char* method, const char* path, resourceCB onResource, afterResourceCB onAfterResource)
+{
+    addResourceCBS(s_resourceMapExtended, method, path, onResource, onAfterResource);
+}
+
+/*Start DUT controller Basic*/
+void startDutControllerBasic(const char* ip, int port)
+{
+    startMiniHttpServerBasic(ip, port, onHttpRequestBasic, onAfterHttpRequestBasic);
+}
+
+/*Start DUT controller Setup*/
+void startDutControllerSetup(const char* ip, int port)
+{
+    startMiniHttpServerSetup(ip, port, onHttpRequestSetup, onAfterHttpRequestSetup);
+}
+
+/*Start DUT controller Extended*/
+void startDutControllerExtended(const char* ip, int port)
+{
+    startMiniHttpServerExtended(ip, port, onHttpRequestExtended, onAfterHttpRequestExtended);
+}
+
+/*Stop DUT controllers*/
+void stopDutControllers()
+{
+    stopMiniHttpServerBasic();
+    stopMiniHttpServerSetup();
+    //stopMiniHttpServerExtended();
+}
diff --git a/tests/automation/ctt/src/MiniHttpServer.c b/tests/automation/ctt/src/MiniHttpServer.c
new file mode 100755
index 00000000..d54d7b5a
--- /dev/null
+++ b/tests/automation/ctt/src/MiniHttpServer.c
@@ -0,0 +1,751 @@
+/******************************************************************
+ *
+ * Copyright 2016 Granite River Labs All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pthread.h>
+#include <MiniHttpServer.h>
+#include <uv.h>
+
+/*Static resource start*/
+static uv_loop_t s_loopBasic;
+static uv_async_t s_stopAsyncBasic;
+static uv_thread_t s_serverThreadIDBasic;
+static char* s_addrBasic;
+static int s_portBasic;
+static uv_loop_t s_loopSetup;
+static uv_async_t s_stopAsyncSetup;
+static uv_thread_t s_serverThreadIDSetup;
+static char* s_addrSetup;
+static int s_portSetup;
+static uv_loop_t s_loopExtended;
+static uv_async_t s_stopAsyncExtended;
+static uv_thread_t s_serverThreadIDExtended;
+static char* s_addrExtended;
+static int s_portExtended;
+static httpRequestCB s_onHttpRequestBasic;
+static afterHttpRequestCB s_onAfterHttpRequestBasic;
+static httpRequestCB s_onHttpRequestSetup;
+static afterHttpRequestCB s_onAfterHttpRequestSetup;
+static httpRequestCB s_onHttpRequestExtended;
+static afterHttpRequestCB s_onAfterHttpRequestExtended;
+/*Static resource end*/
+
+typedef struct
+{
+    uv_tcp_t* tcp;
+    uv_buf_t buf;
+} ReqData;
+
+/*On Allocation of memory*/
+static void onAlloc(uv_handle_t* client, size_t suggested_size, uv_buf_t* buf)
+{
+    buf->base = (char*)malloc(suggested_size);
+    buf->len = suggested_size;
+}
+
+/*Free Work request*/
+static void freeWorkReq(uv_work_t* req, int status)
+{
+    free(req);
+}
+
+/*Create the response*/
+static char* createResponse(char* body)
+{
+    //response template used for responding to TAF query
+    char rspTemplate[] = "HTTP/1.1 200 OK\r\n" \
+                       "Content-Type: text/xml; charset=iso-8859-1\r\n" \
+                       "Content-Length: %d\r\n" \
+                       "Connection: close\r\n" \
+                       "\r\n" \
+                       "%s";
+    char* rsp = 0;
+
+    if (body)
+    {
+        rsp = (char*)malloc(sizeof(char) * (strlen(body) + strlen(rspTemplate) + 16));
+        sprintf(rsp, rspTemplate, strlen(body), body);
+    }
+    else
+    {
+        rsp = (char*)malloc(sizeof(char) * (strlen("") + strlen(rspTemplate) + 16));
+        sprintf(rsp, rspTemplate, strlen(""), "");
+    }
+
+    return rsp;
+}
+
+/*Get string from the request buffer*/
+static char* getMethod(uv_buf_t* req)
+{
+    char* end = strstr(req->base, " ");
+    size_t size = end - req->base;
+    char* ret = (char*)malloc(sizeof(char) * (size + 1));
+
+    strncpy(ret, req->base, size);
+    ret[size] = 0;
+
+    return ret;
+}
+
+
+/*Get content length from the request buffer*/
+static int getContentLength(uv_buf_t* req)
+{
+    int ret = -1;
+
+    char* cl = strstr(req->base, "Content-Length:");
+    char* rn = strstr(req->base, "\r\n\r\n");
+
+    if (cl == 0) goto error;
+    if (cl > rn) goto error;
+
+    sscanf(cl, "Content-Length: %d", &ret);
+
+    return ret;
+
+error:
+    return -1;
+}
+
+/*Calculate content length from the request buffer*/
+static int calcContentLength(uv_buf_t* req)
+{
+    char* rn = strstr(req->base, "\r\n\r\n");
+    int header_len = 0;
+
+    if (rn == 0) goto error;
+
+    header_len = rn - req->base + 4;
+
+    return req->len - header_len;
+
+error:
+    return -1;
+}
+
+/*Get the URL from the request buffer*/
+static char* getUrl(uv_buf_t* req)
+{
+    char* begin = strstr(req->base, " ") + 1;
+    char* end = strstr(begin, " ");
+    size_t size = end - begin;
+    char* ret = (char*)malloc(sizeof(char) * (size + 1));
+
+    strncpy(ret, begin, size);
+    ret[size] = 0;
+
+    return ret;
+}
+
+/*Get the body from the request buffer*/
+static char* getBody(uv_buf_t* req)
+{
+    char* begin = 0;
+    char* end = 0;
+    char* ret = 0;
+    size_t size = 0;
+
+    begin = strstr(req->base, "\r\n\r\n");
+    if (!begin) goto error;
+    begin += 4;
+
+    end = req->base + req->len;
+    size = end - begin;
+
+    if (size > 0)
+    {
+        ret = (char*)malloc(sizeof(char) * (size + 1));
+
+        strncpy(ret, begin, size);
+        ret[size] = 0;
+    }
+
+    return ret;
+
+error:
+    free(ret);
+
+    return 0;
+}
+
+/*Delete the handle of request buffer*/
+void deleteHandle(uv_handle_t* handle)
+{
+    free(handle);
+}
+
+/*Finish the request*/
+void finishRequest(uv_write_t* req, int status)
+{
+    ReqData* reqData = (ReqData*)req->data;
+
+    uv_close((uv_handle_t*) reqData->tcp, deleteHandle);
+
+    free(reqData->buf.base);
+    free(reqData);
+    free(req);
+}
+
+/*Process Basic Request*/
+static void processRequestBasic(uv_work_t* req)
+{
+    ReqData* reqData = (ReqData*) req->data;
+    uv_write_t* writeReq = 0;
+    char* rspBody = 0;
+    char* rsp = 0;
+
+    char* reqMethod = getMethod(&reqData->buf);
+    char* reqUrl = getUrl(&reqData->buf);
+    char* reqBody = getBody(&reqData->buf);
+
+    if (s_onHttpRequestBasic)
+    {
+        rspBody = s_onHttpRequestBasic(reqMethod, reqUrl, reqBody);
+    }
+
+    rsp = createResponse(rspBody);
+
+    free(reqData->buf.base);
+
+    reqData->buf.base = rsp;
+    reqData->buf.len = strlen(rsp);
+
+    writeReq = (uv_write_t*)malloc(sizeof(uv_write_t));
+    writeReq->data = reqData;
+
+    uv_write(writeReq, (uv_stream_t*) reqData->tcp, &reqData->buf, 1, finishRequest);
+
+    if (s_onAfterHttpRequestBasic)
+    {
+        s_onAfterHttpRequestBasic(rspBody);
+    }
+
+    free(reqBody);
+    free(reqUrl);
+    free(reqMethod);
+}
+
+/*Process Setup Request*/
+static void processRequestSetup(uv_work_t* req)
+{
+    ReqData* reqData = (ReqData*) req->data;
+    uv_write_t* writeReq = 0;
+    char* rspBody = 0;
+    char* rsp = 0;
+
+    char* reqMethod = getMethod(&reqData->buf);
+    char* reqUrl = getUrl(&reqData->buf);
+    char* reqBody = getBody(&reqData->buf);
+
+    if (s_onHttpRequestSetup)
+    {
+        rspBody = s_onHttpRequestSetup(reqMethod, reqUrl, reqBody);
+    }
+
+    rsp = createResponse(rspBody);
+
+    free(reqData->buf.base);
+
+    reqData->buf.base = rsp;
+    reqData->buf.len = strlen(rsp);
+
+    writeReq = (uv_write_t*)malloc(sizeof(uv_write_t));
+    writeReq->data = reqData;
+
+    uv_write(writeReq, (uv_stream_t*) reqData->tcp, &reqData->buf, 1, finishRequest);
+
+    if (s_onAfterHttpRequestSetup)
+    {
+        s_onAfterHttpRequestSetup(rspBody);
+    }
+
+    free(reqBody);
+    free(reqUrl);
+    free(reqMethod);
+}
+
+/*Process Extended Request*/
+static void processRequestExtended(uv_work_t* req)
+{
+    ReqData* reqData = (ReqData*) req->data;
+    uv_write_t* writeReq = 0;
+    char* rspBody = 0;
+    char* rsp = 0;
+
+    char* reqMethod = getMethod(&reqData->buf);
+    char* reqUrl = getUrl(&reqData->buf);
+    char* reqBody = getBody(&reqData->buf);
+
+    if (s_onHttpRequestExtended)
+    {
+        rspBody = s_onHttpRequestExtended(reqMethod, reqUrl, reqBody);
+    }
+
+    rsp = createResponse(rspBody);
+
+    free(reqData->buf.base);
+
+    reqData->buf.base = rsp;
+    reqData->buf.len = strlen(rsp);
+
+    writeReq = (uv_write_t*)malloc(sizeof(uv_write_t));
+    writeReq->data = reqData;
+
+    uv_write(writeReq, (uv_stream_t*) reqData->tcp, &reqData->buf, 1, finishRequest);
+
+    if (s_onAfterHttpRequestExtended)
+    {
+        s_onAfterHttpRequestExtended(rspBody);
+    }
+
+    free(reqBody);
+    free(reqUrl);
+    free(reqMethod);
+}
+
+/*Check if the request is complete*/
+static int isRequestComplete(uv_buf_t* buf)
+{
+    int gcl = getContentLength(buf);
+    int ccl = calcContentLength(buf);
+    char* rnrn = strstr(buf->base, "\r\n\r\n");
+    int ret = 0;
+
+    if (rnrn)
+    {
+        if (gcl < 0)
+        {
+            ret = 1;
+        }
+        else if (gcl == ccl)
+        {
+            ret = 1;
+        }
+    }
+
+    return ret;
+}
+
+/*Concatenate 2 strings*/
+static char* concatString(char* str1, size_t len1, char* str2, size_t len2)
+{
+    char* ret = (char*)malloc(sizeof(char) * (len1 + len2 + 1));
+
+    strncpy(ret, str1, len1);
+    strncpy(ret + len1, str2, len2);
+    ret[len1 + len2] = 0;
+
+    return ret;
+}
+
+/*Read Basic Request*/
+static void onReadBasic(uv_stream_t* tcp, ssize_t nread, const uv_buf_t* buf)
+{
+    if (nread >= 0)
+    {
+        uv_work_t* req;
+        ReqData* reqData;
+        uv_buf_t* tcpBuf = 0;
+        char* newBase = 0;
+        int newLen = 0;
+
+        if (tcp->data == 0)
+        {
+            tcp->data = malloc(sizeof(uv_buf_t));
+            ((uv_buf_t*)tcp->data)->len = 0;
+            ((uv_buf_t*)tcp->data)->base = 0;
+        }
+
+        tcpBuf = (uv_buf_t*)tcp->data;
+        newLen = tcpBuf->len + nread;
+        newBase = concatString(tcpBuf->base, tcpBuf->len, buf->base, nread);
+
+        free(tcpBuf->base);
+        tcpBuf->base = newBase;
+        tcpBuf->len = newLen;
+
+        if (isRequestComplete(tcpBuf))
+        {
+            req = (uv_work_t*) malloc(sizeof(uv_work_t));
+            reqData = (ReqData*) malloc(sizeof(ReqData));
+
+            reqData->tcp = (uv_tcp_t*)tcp;
+            reqData->buf.base = tcpBuf->base;
+            reqData->buf.len = tcpBuf->len;
+            req->data = (void*)reqData;
+
+            free(tcpBuf);
+            tcp->data = 0;
+
+            uv_queue_work(&s_loopBasic, req, processRequestBasic, freeWorkReq);
+        }
+    }
+    else if (nread != UV__EOF)
+    {
+        if (tcp->data)
+        {
+            free(((uv_buf_t*)tcp->data)->base);
+            free(tcp->data);
+        }
+
+        uv_close((uv_handle_t*) tcp, deleteHandle);
+    }
+
+    free(buf->base);
+}
+
+/*On New Basic Connection*/
+static void onNewConnectionBasic(uv_stream_t *server, int status)
+{
+    uv_tcp_t *client;
+
+    if (status == -1) {
+        return;
+    }
+
+    client = (uv_tcp_t*) malloc(sizeof(uv_tcp_t));
+    client->data = 0;
+    uv_tcp_init(&s_loopBasic, client);
+
+    if (uv_accept(server, (uv_stream_t*) client) == 0)
+    {
+        uv_read_start((uv_stream_t*) client, onAlloc, onReadBasic);
+    }
+    else
+    {
+        uv_close((uv_handle_t*) client, deleteHandle);
+    }
+}
+
+/*Read Setup Request*/
+static void onReadSetup(uv_stream_t* tcp, ssize_t nread, const uv_buf_t* buf)
+{
+    if (nread >= 0)
+    {
+        uv_work_t* req;
+        ReqData* reqData;
+        uv_buf_t* tcpBuf = 0;
+        char* newBase = 0;
+        int newLen = 0;
+
+        if (tcp->data == 0)
+        {
+            tcp->data = malloc(sizeof(uv_buf_t));
+            ((uv_buf_t*)tcp->data)->len = 0;
+            ((uv_buf_t*)tcp->data)->base = 0;
+        }
+
+        tcpBuf = (uv_buf_t*)tcp->data;
+        newLen = tcpBuf->len + nread;
+        newBase = concatString(tcpBuf->base, tcpBuf->len, buf->base, nread);
+
+        free(tcpBuf->base);
+        tcpBuf->base = newBase;
+        tcpBuf->len = newLen;
+
+        if (isRequestComplete(tcpBuf))
+        {
+            req = (uv_work_t*) malloc(sizeof(uv_work_t));
+            reqData = (ReqData*) malloc(sizeof(ReqData));
+
+            reqData->tcp = (uv_tcp_t*)tcp;
+            reqData->buf.base = tcpBuf->base;
+            reqData->buf.len = tcpBuf->len;
+            req->data = (void*)reqData;
+
+            free(tcpBuf);
+            tcp->data = 0;
+
+            uv_queue_work(&s_loopSetup, req, processRequestSetup, freeWorkReq);
+        }
+    }
+    else if (nread != UV__EOF)
+    {
+        if (tcp->data)
+        {
+            free(((uv_buf_t*)tcp->data)->base);
+            free(tcp->data);
+        }
+
+        uv_close((uv_handle_t*) tcp, deleteHandle);
+    }
+
+    free(buf->base);
+}
+
+/*On New Setup Connection*/
+static void onNewConnectionSetup(uv_stream_t *server, int status)
+{
+    uv_tcp_t *client;
+
+    if (status == -1) {
+        return;
+    }
+
+    client = (uv_tcp_t*) malloc(sizeof(uv_tcp_t));
+    client->data = 0;
+    uv_tcp_init(&s_loopSetup, client);
+
+    if (uv_accept(server, (uv_stream_t*) client) == 0)
+    {
+        uv_read_start((uv_stream_t*) client, onAlloc, onReadSetup);
+    }
+    else
+    {
+        uv_close((uv_handle_t*) client, deleteHandle);
+    }
+}
+
+
+/*Read Extended Request*/
+static void onReadExtended(uv_stream_t* tcp, ssize_t nread, const uv_buf_t* buf)
+{
+    if (nread >= 0)
+    {
+        uv_work_t* req;
+        ReqData* reqData;
+        uv_buf_t* tcpBuf = 0;
+        char* newBase = 0;
+        int newLen = 0;
+
+        if (tcp->data == 0)
+        {
+            tcp->data = malloc(sizeof(uv_buf_t));
+            ((uv_buf_t*)tcp->data)->len = 0;
+            ((uv_buf_t*)tcp->data)->base = 0;
+        }
+
+        tcpBuf = (uv_buf_t*)tcp->data;
+        newLen = tcpBuf->len + nread;
+        newBase = concatString(tcpBuf->base, tcpBuf->len, buf->base, nread);
+
+        free(tcpBuf->base);
+        tcpBuf->base = newBase;
+        tcpBuf->len = newLen;
+
+        if (isRequestComplete(tcpBuf))
+        {
+            req = (uv_work_t*) malloc(sizeof(uv_work_t));
+            reqData = (ReqData*) malloc(sizeof(ReqData));
+
+            reqData->tcp = (uv_tcp_t*)tcp;
+            reqData->buf.base = tcpBuf->base;
+            reqData->buf.len = tcpBuf->len;
+            req->data = (void*)reqData;
+
+            free(tcpBuf);
+            tcp->data = 0;
+
+            uv_queue_work(&s_loopExtended, req, processRequestExtended, freeWorkReq);
+        }
+    }
+    else if (nread != UV__EOF)
+    {
+        if (tcp->data)
+        {
+            free(((uv_buf_t*)tcp->data)->base);
+            free(tcp->data);
+        }
+
+        uv_close((uv_handle_t*) tcp, deleteHandle);
+    }
+
+    free(buf->base);
+}
+
+/*On New Extended Connection*/
+static void onNewConnectionExtended(uv_stream_t *server, int status)
+{
+    uv_tcp_t *client;
+
+    if (status == -1) {
+        return;
+    }
+
+    client = (uv_tcp_t*) malloc(sizeof(uv_tcp_t));
+    client->data = 0;
+    uv_tcp_init(&s_loopExtended, client);
+
+    if (uv_accept(server, (uv_stream_t*) client) == 0)
+    {
+        uv_read_start((uv_stream_t*) client, onAlloc, onReadExtended);
+    }
+    else
+    {
+        uv_close((uv_handle_t*) client, deleteHandle);
+    }
+}
+
+/*Stop Basic Http Server*/
+static void stopMiniHttpServerAsyncBasic(uv_async_t* handle)
+{
+    uv_stop(&s_loopBasic);
+}
+
+/*Stop Setup Http Server*/
+static void stopMiniHttpServerAsyncSetup(uv_async_t* handle)
+{
+    uv_stop(&s_loopSetup);
+}
+
+/*Stop Extended Http Server*/
+static void stopMiniHttpServerAsyncExtended(uv_async_t* handle)
+{
+    uv_stop(&s_loopExtended);
+}
+
+/*Start Basic Http Server Thread*/
+static void miniHttpServerThreadBasic(void *arg)
+{
+    uv_tcp_t server;
+    struct sockaddr_in bindAddr;
+
+    uv_loop_init(&s_loopBasic);
+    uv_tcp_init(&s_loopBasic, &server);
+    uv_async_init(&s_loopBasic, &s_stopAsyncBasic, stopMiniHttpServerAsyncBasic);
+
+    uv_ip4_addr(s_addrBasic, s_portBasic, &bindAddr);
+    uv_tcp_bind(&server, (const struct sockaddr*)&bindAddr, 0);
+
+    uv_listen((uv_stream_t*) &server, 128, onNewConnectionBasic);
+    uv_run(&s_loopBasic, UV_RUN_DEFAULT);
+
+    uv_close((uv_handle_t*)&server, 0);
+}
+
+/*Stop Basic Http Server*/
+void stopMiniHttpServerBasic()
+{
+    uv_async_send(&s_stopAsyncBasic);
+    uv_thread_join(&s_serverThreadIDBasic);
+
+    free(s_addrBasic);
+    s_addrBasic = 0;
+    s_portBasic = 0;
+    s_onHttpRequestBasic = 0;
+}
+
+/*Start Basic Http Server*/
+void startMiniHttpServerBasic(const char* addr, int port, httpRequestCB onHttpRequest, afterHttpRequestCB onAfterHttpRequest)
+{
+    int addrLen = strlen(addr);
+    s_addrBasic = (char*) malloc(sizeof(char) * (addrLen + 1));
+    strcpy(s_addrBasic, addr);
+    s_addrBasic[addrLen] = 0;
+    s_portBasic = port;
+    s_onHttpRequestBasic = onHttpRequest;
+    s_onAfterHttpRequestBasic = onAfterHttpRequest;
+
+    uv_thread_create(&s_serverThreadIDBasic, miniHttpServerThreadBasic, 0);
+}
+
+/*Start Setup Http Server Thread*/
+static void miniHttpServerThreadSetup(void *arg)
+{
+    uv_tcp_t server;
+    struct sockaddr_in bindAddr;
+
+    uv_loop_init(&s_loopSetup);
+    uv_tcp_init(&s_loopSetup, &server);
+    uv_async_init(&s_loopSetup, &s_stopAsyncSetup, stopMiniHttpServerAsyncSetup);
+
+    uv_ip4_addr(s_addrSetup, s_portSetup, &bindAddr);
+    uv_tcp_bind(&server, (const struct sockaddr*)&bindAddr, 0);
+
+    uv_listen((uv_stream_t*) &server, 128, onNewConnectionSetup);
+    uv_run(&s_loopSetup, UV_RUN_DEFAULT);
+
+    uv_close((uv_handle_t*)&server, 0);
+}
+
+/*Stop Setup Http Server Thread*/
+void stopMiniHttpServerSetup()
+{
+    uv_async_send(&s_stopAsyncSetup);
+    uv_thread_join(&s_serverThreadIDSetup);
+
+    free(s_addrSetup);
+    s_addrSetup = 0;
+    s_portSetup = 0;
+    s_onHttpRequestSetup = 0;
+}
+
+/*Start Setup Http Server*/
+void startMiniHttpServerSetup(const char* addr, int port, httpRequestCB onHttpRequest, afterHttpRequestCB onAfterHttpRequest)
+{
+    int addrLen = strlen(addr);
+    s_addrSetup = (char*) malloc(sizeof(char) * (addrLen + 1));
+    strcpy(s_addrSetup, addr);
+    s_addrSetup[addrLen] = 0;
+    s_portSetup = port;
+    s_onHttpRequestSetup = onHttpRequest;
+    s_onAfterHttpRequestSetup = onAfterHttpRequest;
+
+    uv_thread_create(&s_serverThreadIDSetup, miniHttpServerThreadSetup, 0);
+}
+
+
+/*Start Extended Http Server Thread*/
+static void miniHttpServerThreadExtended(void *arg)
+{
+    uv_tcp_t server;
+    struct sockaddr_in bindAddr;
+
+    uv_loop_init(&s_loopExtended);
+    uv_tcp_init(&s_loopExtended, &server);
+    uv_async_init(&s_loopExtended, &s_stopAsyncExtended, stopMiniHttpServerAsyncExtended);
+
+    uv_ip4_addr(s_addrExtended, s_portExtended, &bindAddr);
+    uv_tcp_bind(&server, (const struct sockaddr*)&bindAddr, 0);
+
+    uv_listen((uv_stream_t*) &server, 128, onNewConnectionExtended);
+    uv_run(&s_loopExtended, UV_RUN_DEFAULT);
+
+    uv_close((uv_handle_t*)&server, 0);
+}
+
+/*Stop Extended Http Server*/
+void stopMiniHttpServerExtended()
+{
+    uv_async_send(&s_stopAsyncExtended);
+    uv_thread_join(&s_serverThreadIDExtended);
+
+    free(s_addrExtended);
+    s_addrExtended = 0;
+    s_portExtended = 0;
+    s_onHttpRequestExtended = 0;
+}
+
+/*Start Extended Http Server*/
+void startMiniHttpServerExtended(const char* addr, int port, httpRequestCB onHttpRequest, afterHttpRequestCB onAfterHttpRequest)
+{
+    int addrLen = strlen(addr);
+    s_addrExtended = (char*) malloc(sizeof(char) * (addrLen + 1));
+    strcpy(s_addrExtended, addr);
+    s_addrExtended[addrLen] = 0;
+    s_portExtended = port;
+    s_onHttpRequestExtended = onHttpRequest;
+    s_onAfterHttpRequestExtended = onAfterHttpRequest;
+
+    uv_thread_create(&s_serverThreadIDExtended, miniHttpServerThreadExtended, 0);
+}
diff --git a/tests/automation/ctt/src/ResourceMap.c b/tests/automation/ctt/src/ResourceMap.c
new file mode 100755
index 00000000..7ff4b00f
--- /dev/null
+++ b/tests/automation/ctt/src/ResourceMap.c
@@ -0,0 +1,87 @@
+/******************************************************************
+ *
+ * Copyright 2016 Granite River Labs All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <libxml/tree.h>
+#include <ResourceMap.h>
+
+
+
+/*Create a Resource Map*/
+ResourceMap* createResourceMap()
+{
+    ResourceMap* map = (ResourceMap*)malloc(sizeof(ResourceMap));
+    map->head = 0;
+
+    return map;
+}
+
+/*Create and add a Resource to the Resource Map*/
+void addResourceCBS(ResourceMap* self, const char* method, const char* path, resourceCB onResource, afterResourceCB onAfterResource)
+{
+    Resource* newElement = (Resource*)malloc(sizeof(Resource));
+
+    strncpy(newElement->method, method, MAX_METHOD);
+    strncpy(newElement->path, path, MAX_PATH);
+    newElement->path[MAX_PATH] = 0;
+    newElement->resourceCBS.onResource = onResource;
+    newElement->resourceCBS.onAfterResource = onAfterResource;
+    newElement->next = self->head;
+
+    self->head = newElement;
+}
+
+/*Get Resource from the Resource Map*/
+ResourceCBS getResourceCBS(ResourceMap* self, const char* method, const char* path)
+{
+    Resource* res = self->head;
+    ResourceCBS resourceCBS;
+
+    resourceCBS.onResource = 0;
+    resourceCBS.onAfterResource = 0;
+
+    while (res != 0)
+    {
+        if (strcmp(res->method, method) == 0 && strcmp(res->path, path) == 0)
+        {
+            resourceCBS = res->resourceCBS;
+            break;
+        }
+
+        res = res->next;
+    };
+
+    return resourceCBS;
+}
+
+/*Delete Resource from the Resource Map*/
+void deleteResourceMap(ResourceMap* self)
+{
+    Resource* head = self->head;
+    Resource* nextHead = 0;
+
+    while (head != 0)
+    {
+        nextHead = head->next;
+        free(head);
+        head = nextHead;
+    };
+}
diff --git a/tests/automation/ctt/src/TAFAgent.c b/tests/automation/ctt/src/TAFAgent.c
new file mode 100644
index 00000000..7361dbe0
--- /dev/null
+++ b/tests/automation/ctt/src/TAFAgent.c
@@ -0,0 +1,792 @@
+/******************************************************************
+ *
+ * Copyright 2016 Granite River Labs All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+#include <TAFAgent.h>
+
+/*Replace String*/
+char *replaceString(const char *str, const char *from, const char *to){
+
+    /* Adjust each of the below values to suit your needs. */
+    /* Increment positions cache size initially by this number. */
+    size_t cacheSizeInc = 16;
+    /* Thereafter, each time capacity needs to be increased,
+     * multiply the increment by this factor. */
+    const size_t cacheSizeIncFactor = 3;
+    /* But never increment capacity by more than this number. */
+    const size_t cacheSizeIncMax = 1048576;
+    char *pret, *ret = NULL;
+    const char *pstr2, *pstr = str;
+    size_t i, count = 0;
+    ptrdiff_t *posCache = NULL;
+    size_t cacheSize = 0;
+    size_t cpyLen, orgLen, retLen, toLen, fromLen = strlen(from);
+    /* Find all matches and cache their positions. */
+    while((pstr2 = strstr(pstr, from)) != NULL){
+        count++;
+        /* Increase the cache size when necessary. */
+        if(cacheSize < count){
+            cacheSize += cacheSizeInc;
+            posCache = realloc(posCache, sizeof(*posCache) * cacheSize);
+            if(posCache == NULL){
+                goto end_repl_str;
+            }
+            cacheSizeInc *= cacheSizeIncFactor;
+            if(cacheSizeInc > cacheSizeIncMax){
+                cacheSizeInc = cacheSizeIncMax;
+            }
+        }
+        posCache[count - 1] = pstr2 - str;
+        pstr = pstr2 + fromLen;
+    }
+    orgLen = pstr - str + strlen(pstr);
+    /* Allocate memory for the post-replacement string. */
+    if(count > 0){
+        toLen = strlen(to);
+        retLen = orgLen + (toLen - fromLen) * count;
+    }
+    else    retLen = orgLen;
+    ret = (char*) malloc(retLen + 1);
+    if(ret == NULL){
+        goto end_repl_str;
+    }
+    if(count == 0){
+        /* If no matches, then just duplicate the string. */
+        strcpy(ret, str);
+    }
+    else{
+        /* Otherwise, duplicate the string whilst performing
+         * the replacements using the position cache. */
+        pret = ret;
+        memcpy(pret, str, posCache[0]);
+        pret += posCache[0];
+        for(i = 0; i < count; i++){
+            memcpy(pret, to, toLen);
+            pret += toLen;
+            pstr = str + posCache[i] + fromLen;
+            cpyLen = (i == count - 1 ? orgLen : posCache[i + 1]) - posCache[i] - fromLen;
+            memcpy(pret, pstr, cpyLen);
+            pret += cpyLen;
+        }
+        ret[retLen] = '\0';
+    }
+    end_repl_str:
+    /* Free the cache and return the post-replacement string,
+     * which will be NULL in the event of an error. */
+    FREE(posCache);
+    return ret;
+}
+
+/*Function to get the ip address of the machine where TAF is running*/
+void getIP(int ipVersion){
+    struct ifaddrs *ifAddress;
+    char ipv6Address[50];
+    FILE *fp;
+    switch(ipVersion){
+        case IPv6:
+            if(getifaddrs(&ifAddress) == -1){
+                printf("Could not collect adress interfaces\n");
+                exit(1);
+            }
+           do{
+                if(ifAddress->ifa_addr->sa_family == AF_INET6){
+                    char firstHextet[5];
+                    struct sockaddr_in6 *in6 = (struct sockaddr_in6*) ifAddress->ifa_addr;
+                    inet_ntop(AF_INET6, &(in6->sin6_addr), ipv6Address, sizeof(ipv6Address));
+                    memcpy(firstHextet, &ipv6Address, 4);
+                    firstHextet[4] = '\0';
+                    if(!strcmp(firstHextet, globalIPv6_firstHextet))
+                        break;
+                }
+            } while(ifAddress = ifAddress->ifa_next);
+            strcat(gLocalIp, ipv6Address);
+            strcat(gLocalIp, "%");
+            strcat(gLocalIp, ifAddress->ifa_name);
+            printf("Local IP :%s",gLocalIp);
+            break;
+        case IPv4:
+            fp = popen("hostname -I", "r");
+            fscanf(fp, "%s", gLocalIp);
+            pclose(fp);
+            break;
+    }
+    if(gLocalIp[0] == '\0'){
+        printf("Could not get Ip address\n");
+        exit(1);
+    }
+    printf("\nLocal IP address: %s", gLocalIp);
+}
+
+/*Send command to the IUT simulator*/
+void SendCommand(char *cmd){
+    int sockfd = 0, n = 0;
+    struct sockaddr_in serv_addr;
+    int num = 0;
+    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){
+        printf("\nTAFAgent_Error: Could not Create Socket \n");
+        return;
+    }
+    memset(&serv_addr, '0', sizeof(serv_addr));
+    serv_addr.sin_family = AF_INET;
+    serv_addr.sin_port = htons(CertAppServerPort);
+    if(inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr)<=0){
+        printf("\n inet_pton error occured\n");
+        return;
+    }
+    if( connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0){
+       printf("\nTAFAgent_Error: Connect Failed (Inside SendCommand function)\n");
+       return;
+    }
+        printf("\nTAFAgent: Sending Command \"%s\" to CertApp\n", cmd);
+            if((send(sockfd,cmd, strlen(cmd),0))== -1){
+                fprintf(stderr, "Failure Sending Message\n");
+                close(sockfd);
+                return;
+        }
+       else{
+    }
+    close(sockfd);
+}
+
+/*Send Message to CertApp*/
+void SendMessage(char *msg){
+    int sockfd = 0, n = 0;
+    struct sockaddr_in serv_addr;
+    int num = 0;
+    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){
+        printf("\nTAFAgent_Error: Could not Create Socket \n");
+        return ;
+    }
+    memset(&serv_addr, '0', sizeof(serv_addr));
+    serv_addr.sin_family = AF_INET;
+    serv_addr.sin_port = htons(CertAppServerPort);
+    if(inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr)<=0){
+        printf("\n inet_pton error occured\n");
+        return ;
+    }
+    if( connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0){
+       printf("\nTAFAgent_Error: Connect Failed (Inside SendMessage function)\n");
+       return;
+    }
+        printf("\nTAFAgent: Sending Message \"%s\" to CertApp\n", msg);
+            if((send(sockfd, msg, strlen(msg), 0))== -1){
+                fprintf(stderr, "Failure Sending Message\n");
+                close(sockfd);
+                return;
+        }
+       else{
+    }
+    close(sockfd);
+}
+
+/*Send command to the IUT Simulator in bulk*/
+void SendCommands(int commandLength){
+    printf("Inside SendCommand \n");
+    sleep(5 * SLEEP_TIME);
+    for(int i = 0; i < commandLength; i++){
+        SendCommand(gCommandsArray[i]);
+        sleep(SLEEP_TIME);
+    }
+}
+
+/*XML Doc Ptr Clean*/
+void CleanXmlDocPtr(xmlDocPtr doc){
+    if(doc)
+        xmlFreeDoc(doc);
+}
+
+/*XML action handler*/
+xmlDocPtr ActionHandler(xmlDocPtr doc){
+    char *result = (char *)"";
+    const char *messageXml = docToString(doc);
+    if(strstr(messageXml, CTTmsg1) != NULL){
+        printf("%s\n", messageXml);
+    }
+    else if(strstr(messageXml, CTTmsg2) != NULL){
+        char tempString[256];
+        char delimiters[] = "()";
+        char headerString[55] = "coap+tcp://";
+        char cmdString[46] = "40,";
+        strncpy(tempString, messageXml,256);
+        char* reqString = strtok(tempString, delimiters);
+        reqString = strtok(NULL, delimiters);
+        strcat(headerString, reqString);
+        strcat(cmdString,headerString);
+        SendCommand(cmdString);
+    }
+    else if(strstr(messageXml, CTTmsg3) != NULL){
+        asprintf(&result, CTTAction1);
+    }
+    else if(strstr(messageXml, CTTmsg4) != NULL){
+        // Get PIN generated by the CertificationApp
+        strcpy(gPinValue, globalBuffer);
+        asprintf(&result, CTTAction2, gPinValue);
+    }
+    else if(strstr(messageXml, CTTmsg5) != NULL){
+        memset(&globalBuffer, 0, sizeof(globalBuffer));
+        gRestartFlag = 1;
+        sleep(1);
+        while(gInsideMainLoop == 0){
+            sleep(1);
+            }
+        asprintf(&result, CTTAction3);
+    }
+    else if(strstr(messageXml, CTTmsg6) != NULL){
+        /*Reset the CertificationApp */
+        asprintf(&result, CTTAction3);
+    }
+    else if(strstr(messageXml, CTTmsg7) != NULL){
+         /* Reset the CertificationApp
+        gRestartFlag = 1;
+        gReuseIUT = 1;
+        gIPDiscovered = 0;
+        printf("Wait for TAF to Discover IUT after Reset \n");
+        do{sleep(1);} while(!gIPDiscovered);
+        */
+        asprintf(&result, CTTAction3);
+    }
+    else if(strstr(messageXml, CTTmsg8) != NULL){
+        asprintf(&result, CTTAction4);
+    }
+    else if(strstr(messageXml, CTTmsg9) != NULL){
+        asprintf(&result, CTTAction4);
+    }
+    else if(strstr(messageXml, CTTmsg10) != NULL){
+        asprintf(&result, CTTAction4);
+    }
+    else if(strstr(messageXml, CTTmsg11) != NULL ||
+        strstr(messageXml, CTTmsg12) != NULL){
+        SendCommand("12");
+        sleep(SLEEP_TIME);
+    }
+    else if(strstr(messageXml, CTTmsg13) != NULL){
+            SendCommand("12");
+            sleep(2 * SLEEP_TIME);
+            SendCommand("17");
+            SendMessage("/BinarySwitchResURI");
+            sleep(2 * SLEEP_TIME);
+            asprintf(&result, CTTAction3);
+    }
+    else if(strstr(messageXml, CTTmsg14) != NULL){
+        if(strstr(messageXml, "/BinarySwitchResURI") != NULL){
+            SendCommand("12");
+            sleep(2 * SLEEP_TIME);
+            SendCommand("17");
+            SendMessage("/BinarySwitchResURI");
+            sleep(SLEEP_TIME);
+        }
+        if(strstr(messageXml, "/HumidityResURI") != NULL){
+			 if(strstr(messageXml, "coap+tcp") != NULL)
+			 {
+				sleep(3 * SLEEP_TIME);
+				SendCommand("12");
+				sleep(SLEEP_TIME);
+			 }
+            SendCommand("17");
+            SendMessage("/HumidityResURI");
+            sleep(SLEEP_TIME);
+		}
+    }
+    else if(strstr(messageXml, CTTmsg15) != NULL){
+      if (strstr(messageXml, "/BinarySwitchResURI") != NULL) {
+        SendCommand("12");
+        sleep(2 * SLEEP_TIME);
+        SendCommand("46");
+        SendMessage("/BinarySwitchResURI");
+        sleep(SLEEP_TIME);
+      }
+      if (strstr(messageXml, "/HumidityResURI") != NULL) {
+        SendCommand("12");
+        sleep(2 * SLEEP_TIME);
+        SendCommand("47");
+        SendMessage("/HumidityResURI");
+        sleep(SLEEP_TIME);
+      }
+    }
+    else if(strstr(messageXml, CTTmsg16) != NULL){
+            sleep(SLEEP_TIME);
+            SendCommand("12");
+            sleep(2 * SLEEP_TIME);
+            SendCommand("25");
+            SendMessage("/BinarySwitchResURI");
+            sleep(SLEEP_TIME);
+    }
+    else if(strstr(messageXml, CTTmsg17) != NULL){
+        asprintf(&result, CTTAction4);
+    }
+    else if(strstr(messageXml, CTTmsg18) != NULL){
+        asprintf(&result, CTTAction4);
+    }
+    else if(strstr(messageXml, CTTmsg19) != NULL){
+        asprintf(&result, CTTAction4);
+    }
+    else if(strstr(messageXml, CTTmsg20) != NULL){
+        SendCommand("12");
+        sleep(SLEEP_TIME);
+    }
+
+/* else if(strstr(messageXml, ...) != NULL){
+        const char *publicKey =
+            "-----BEGIN CERTIFICATE-----\n"
+            "MIICBDCCAaugAwIBAgIIZ0QY0VJs8zIwCgYIKoZIzj0EAwIwSjELMAkGA1UEBhMC\n"
+            "VVMxDDAKBgNVBAoMA09DRjETMBEGA1UECwwKT0NGIENUVCBDQTEYMBYGA1UEAwwP\n"
+            "T0NGIENUVCBST09UIENBMB4XDTE3MDEwMTAwMDAwMFoXDTI3MDEwMTAwMDAwMFow\n"
+            "SjELMAkGA1UEBhMCVVMxDDAKBgNVBAoMA09DRjETMBEGA1UECwwKT0NGIENUVCBD\n"
+            "QTEYMBYGA1UEAwwPT0NGIENUVCBST09UIENBMFkwEwYHKoZIzj0CAQYIKoZIzj0D\n"
+            "AQcDQgAEuKkiScoLLyjGALXhr2PijOyf0RRqXnKY8VXFM+aHkdYxiJHD5MziSXsT\n"
+            "hDB82Hx7ykz8Fil0cBuE1tX4gX87/qN7MHkwKwYDVR0jBCQwIoAgVapQxp8Fthci\n"
+            "DZjQdj0AdbaKBr9aXrlJxD9unFaRlCswKQYDVR0OBCIEIFWqUMafBbYXIg2Y0HY9\n"
+            "AHW2iga/Wl65ScQ/bpxWkZQrMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQD\n"
+            "AgEGMAoGCCqGSM49BAMCA0cAMEQCIEfUv9VTQrFDg9/kqnTHpLBDRVgoMlAFsDgW\n"
+            "S02KANuyAiAQsZeEhxTCqGhQwRQpIoI+WJ2maHa+pfuuwGXc+GH+Tg==\n"
+            "-----END CERTIFICATE-----";
+        asprintf(&result,
+                 "<actionResult><userDialogResponse><answer>Set_Value</answer><data>%s</data></userDialogResponse></actionResult>",
+                 publicKey);
+    }*/
+  /*else if(strstr(messageXml, CTTmsg20) != NULL){
+        printf("Received a CLOUD related request from CTT\n");
+        if(strstr(messageXml, CTTmsg21) != NULL){
+            sleep(SLEEP_TIME);
+        }
+        else if(strstr(messageXml, CTTmsg22) != NULL){
+            printf("Sending log-in\n");
+            SendCommand("112");
+            sleep(SLEEP_TIME);
+        }
+        else if(strstr(messageXml, CTTmsg23) != NULL){
+            SendCommand("113");
+            sleep(SLEEP_TIME);
+        }
+        else if(strstr(messageXml, CTTmsg24) != NULL){
+            SendCommand("114");
+            sleep(SLEEP_TIME);
+        }
+        else if(strstr(messageXml, CTTmsg25) != NULL){
+            SendCommand("115");
+            sleep(SLEEP_TIME);
+        }
+    }*/
+    else if(strstr(messageXml, CTTmsg21) != NULL){
+        /*Click OK*/
+            sleep(2*SLEEP_TIME);
+            SendCommand("111");
+            sleep(2*SLEEP_TIME);
+            asprintf(&result, CTTAction3);
+    }
+    else if(strstr(messageXml, CTTmsg22) != NULL){
+            sleep(SLEEP_TIME);
+            SendCommand("112");
+            sleep(SLEEP_TIME);
+    }
+    else if(strstr(messageXml, CTTmsg23) != NULL){
+            sleep(SLEEP_TIME);
+            SendCommand("113");
+            sleep(SLEEP_TIME);
+    }
+    else if(strstr(messageXml, CTTmsg24) != NULL){
+            sleep(SLEEP_TIME);
+            SendCommand("114");
+            sleep(SLEEP_TIME);
+    }
+    else if(strstr(messageXml, CTTmsg25) != NULL){
+            sleep(2*SLEEP_TIME);
+            SendCommand("115");
+            sleep(SLEEP_TIME);
+    }
+    else if(strstr(messageXml, CTTmsg27) != NULL){
+		SendCommand("12");
+		sleep(2*SLEEP_TIME);
+            SendCommand("17");
+			sleep(SLEEP_TIME);
+            SendMessage("/TemperatureResURI");
+            sleep(SLEEP_TIME);
+    }
+    else if(strstr(messageXml, CTTmsg28) != NULL){
+		//SendCommand("12");
+		//sleep(2*SLEEP_TIME);
+        SendCommand("17");
+		sleep(SLEEP_TIME);
+        SendMessage("/HumidityResURI");
+        sleep(SLEEP_TIME);
+    }
+    else if(strstr(messageXml, CTTmsg29) != NULL){
+            asprintf(&result, CTTAction3);
+    }
+	else if(strstr(messageXml, CTTmsg30) != NULL){
+	SendCommand("28");
+	sleep(SLEEP_TIME);
+    }
+	else if(strstr(messageXml, CTTmsg31) != NULL){
+	asprintf(&result, CTTAction3);
+    }
+	else if(strstr(messageXml, CTTmsg32) != NULL){
+	asprintf(&result, CTTAction4);
+    }
+    else{
+        printf("TAF==Received not handled POST /actions: %s \n", messageXml);
+    }
+    if(result != ""){
+        printf("%s\n", result);
+    }
+    return stringToDoc(result);
+}
+
+/*Abort Signal Handler*/
+xmlDocPtr AbortSignalHandler(xmlDocPtr doc){
+    printf("TAF==Received GET /abortSignal: \n");
+    return stringToDoc("<abortSignal><abortTestcase>false</abortTestcase><abortTestRun>false</abortTestRun></abortSignal>");
+}
+
+/*Configuration handler*/
+xmlDocPtr ConfigurationHandler(xmlDocPtr doc){
+    printf("Inside Configuration Handler \n");
+    if(gConfigFileContent == NULL){
+        long length;
+        FILE *f = fopen (gConfigPath, "rb");
+        if(f){
+            printf("FILE OPENED \n");
+            fseek (f, 0, SEEK_END);
+            length = ftell (f);
+            fseek (f, 0, SEEK_SET);
+            gConfigFileContent = (char*) malloc (length + 1);
+            if(gConfigFileContent ){
+                fread (gConfigFileContent , 1, length, f);
+                gConfigFileContent[length] = '\0';
+            }
+            fclose (f);
+        }
+        else{
+            printf("Could not open file %s \n", gConfigFileContent);
+            return stringToDoc("");
+        }
+    }
+    uint32_t tempSize = 0;
+    char *result = gConfigFileContent;
+    char *tmp = replaceString(gConfigFileContent, "%IP%", GIP);
+    strcpy(gUuid,"294f1f35-6161-4895-6e7d-c2d0f729c42c");
+    result = replaceString(tmp, "%PORT%", gPort);
+    printf("config:%s",result);
+    return stringToDoc(result);
+}
+
+/*Init TAF Agent*/
+void  InitTAF(char* ipv4Address){
+    printf("TAF Init Start \n");
+    initDutControllers();
+    addRouteBasic("POST", "/actions", ActionHandler, CleanXmlDocPtr);
+    addRouteBasic("GET", "/abortSignal", AbortSignalHandler, CleanXmlDocPtr);
+    if(gConfigPath != NULL){
+        addRouteSetup("GET", "/processes/ctt/configuration", ConfigurationHandler, CleanXmlDocPtr);
+    }
+    startDutControllerBasic(ipv4Address, 32000);
+    // startDutControllerExtended("0.0.0.0", 32001);
+    startDutControllerSetup(ipv4Address, 32002);
+    printf("TAF Init Done \n");
+}
+
+/*Init the IUT Simulator*/
+void initIUT(int qosArg, int ipVerArg, int securityArg, char *ocfVerArg, char initActions[][5], int initActionsSize){
+    printf("IUT options: %d %d %d\n", qosArg, ipVerArg, securityArg);
+    char app[255] = "CertificationApp";
+
+    switch(qosArg){
+        case QOS_NON:
+            strcat(app, " 0");
+            break;
+        case QOS_CON:
+            strcat(app, " 1");
+            break;
+        default:
+            printf("QoS argument \"%d\" is invalid\n", qosArg);
+            exit(1);
+    }
+    switch(ipVerArg){
+        case IPv4:
+            strcat(app, " 4");
+            break;
+        case IPv6:
+            strcat(app, " 6");
+            break;
+        default:
+            printf("IP version argument \"%d\" is invalid\n", ipVerArg);
+            exit(1);
+    }
+    switch (securityArg/10){
+        case FRESH_CLIENT:
+            strcat(app, " 1");
+            break;
+        case REUSE_CLIENT:
+            strcat(app, " 3");
+            break;
+        case FRESH_SERVER:
+            strcat(app, " 2");
+            break;
+        case REUSE_SERVER:
+            strcat(app, " 4");
+            break;
+        default:
+            printf("Security argument \"%d\" is invalid\n", securityArg);
+            exit(1);
+    }
+    switch(securityArg%10){
+        case JUSTWORKS:
+            strcat(app, "1");
+            break;
+        case RANDOMPIN:
+            strcat(app, "2");
+            break;
+        case MFG_CERT:
+            strcat(app, "3");
+            break;
+        default:
+            printf("Security argument \"%d\" is invalid\n", securityArg);
+            exit(1);
+    }
+
+    strcat(app, " ");
+    strcat(app, ocfVerArg);
+    char parameters[255] = "./";
+    strcat(parameters,gCertificationApp);
+    strcat(parameters," 1 2 3 auto");
+    if((gPid = fork()) < 0){
+        printf("Fork failed \n");
+        exit(1);
+    }
+    if(gPid == 0){
+        system("pkill --signal SIGKILL CertificationApp");
+        sleep(1);
+        printf("gPid == 0\n");
+        execlp("/bin/sh","/bin/sh", "-c", parameters, NULL);
+        sleep(5);
+        exit(0);
+    }
+    sleep(3);
+    for(int i = 0; i < initActionsSize; i++){
+        SendCommand(initActions[i]);
+        sleep(1);
+    }
+}
+
+/*Stop the CertificationApp*/
+void stopIUT(){
+    char value[1] = "0";
+    printf("\nTAFAgent: Sending Command \"%s\" to CertApp\n", value);
+    SendCommand(value);
+}
+
+/*Discovery the IUT Simulator port */
+void discoverIUT(int ipVersion, char* IUTInterfaceIndex, char* CTTScopeID){
+    FILE *fp;
+    char path[1035];
+do{
+    sleep(2);
+    char cmdStr[5] = "18,";
+    strcat(cmdStr, IUTInterfaceIndex);
+    SendCommand(cmdStr);
+    sleep(2);
+    char cmdStr2[4] = "%";
+    strcat(cmdStr2, CTTScopeID);
+    strcpy(path, globalBuffer);
+    printf("TAFAgent: IUT Discovery Done\nIUT_IP: %s\n", path);
+    if(strcmp(path,"") !=0){
+        sleep(2);
+        if(ipVersion == 6){  //IPV6
+            const char s[3] = ":";
+            char *token;
+            int first = 0;
+            strcpy(gIp, gLocalIp);
+            strcpy(gIp, strtok(gIp, "%"));
+            strcat(gIp, cmdStr2);
+            strcpy(GIP, gIp);
+            token = strtok(path, s);
+            while( token != NULL ){
+                if(first == 0){
+                    first = 1;
+                }
+                else{
+                    if(strlen(token) == 5){
+                        strncpy(gPort,token, 8);
+                        gIPDiscovered = 1;
+                        break;
+                    }
+                }
+                token = strtok(NULL, s);
+                }
+            }
+            else if(ipVersion == 4){ //IPV4
+            gIPDiscovered = 1;
+            }
+    }
+    else
+    {
+        printf("\nip error\n");
+    }
+  }while(gIPDiscovered == 0);
+}
+
+/*SIGINT handler: set gQuitFlag to 1 for graceful termination*/
+void HandleSigInt(int signum){
+    if((signum == SIGINT) || (signum == SIGTERM) || (signum == SIGTSTP)){
+        gQuitFlag = 1;
+        gRestartFlag = 1;
+    }
+}
+
+void startIUTfromArguments(int argc, char **argv){
+    int qosArg = atoi(argv[2]);
+    int ipVerArg = atoi(argv[3]);
+    int securityArg = atoi(argv[4]);
+    char* ocfVerArg = argv[5];
+    int initialCommandsSize = argc - 10;
+    char initialCommands[initialCommandsSize][5];
+    for(int i = 0; i < initialCommandsSize; i++){
+        strcpy(initialCommands[i], argv[10 + i]);
+    }
+    if(gReuseIUT){
+      initIUT(qosArg, ipVerArg, securityArg + 20, ocfVerArg, initialCommands,
+              initialCommandsSize);
+      gReuseIUT = 0;
+    }
+    else{
+        initIUT(qosArg, ipVerArg, securityArg, ocfVerArg, initialCommands, initialCommandsSize);
+    }
+}
+
+static void* StartServer(){
+    int listenfd = 0, client_fd = 0;
+    struct sockaddr_in serv_addr;
+    struct sockaddr_in dest;
+    int num = 0;
+    socklen_t size = 0;
+    char buffer[1024];
+    listenfd = socket(AF_INET, SOCK_STREAM, 0);
+    memset(&serv_addr, '0', sizeof(serv_addr));
+    serv_addr.sin_family = AF_INET;
+    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
+    serv_addr.sin_port = htons(TAFServerPort);
+    bind(listenfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
+    listen(listenfd, 10);
+    memset(globalBuffer,0,sizeof(globalBuffer));
+
+    printf("TAFAgent_Server: Started @ %d\n", TAFServerPort);
+    while(quit != 1){
+        size = sizeof(struct sockaddr_in);
+        if((client_fd = accept(listenfd, (struct sockaddr *)&dest, &size))==-1 ){
+            perror("accept");
+            break;
+        }
+            while(1){
+                 memset(buffer, '0', sizeof(buffer));
+                if((num = recv(client_fd, buffer, 1024,0))== -1){
+                        perror("recv");
+                        break;
+                }
+                else if(num == 0){
+                        printf("TAFAgent_Sever: Connection Closed\n");
+                        //So I can now wait for another client
+                        break;
+                }
+                buffer[num] = '\0';
+                memset(globalBuffer,0,sizeof(globalBuffer));
+                strncpy(globalBuffer,buffer,num);
+                printf("TAFAgent_Server: Message Received %s form CertApp\n", globalBuffer);
+        }
+    }
+}
+
+/*Main Entry point of the code*/
+int main(int argc, char **argv){
+    int ipVerArg = atoi(argv[3]);
+    pthread_t thread;
+    const int trigger = CLOCKS_PER_SEC;
+    printf("Starting Tool Automation Framework\n");
+
+    /*Validates the Arguments*/
+    if(argc < 12){
+    printf("ERROR: Wrong Command or Amount of Arguments, Shoule Be:\n\nExample:\n[./TAFAgent conf_path QoS IP_Version Security OCF_Version IP_Address InterfaceIndex ScopeID TAF_Mode CertAppInput1 CertAppInput2]\n");
+    printf(
+      "\nDescription:\nTAFAgent:\ttafagent\nconf_path:\tclient_config.txt -For Client Test Cases\n\t\tserver_config.txt -For Server Test  Cases\nQoS:\t    \
+    0 -Using Non Server\n\t\t1 -Using CON Server\nIP_Version:\t4 -IPV_4\n\t\t6 -IPV_6\nSecurity:\t11 -Just Works\n\t\t12 -Random Pin\n\t\t13 -Manufacturing Certificate\nOCF_Version:\
+    1.3.0\n\t\t2.0.0\n\t\t2.0.2\nIP_Address:\tIPv4 -Address of Machine Running TAFAgent\nInterfaceIndex:\tIndex -Of the Machine Running TAFAgent\nScopeID:\tScope_ID -Of the Machine Running CTT\nTAF_Mode:\
+    server -To Start TAF in Server Mode\n\t\tclient -To Start TAF in Client Mode\nCertAppInput1:\t1 -Create a Resource\nCertAppInput2:\t1 -Create a Resource\n");
+    return -1;
+    }
+
+    /*Start TAFAgent Server*/
+    if(pthread_create(&thread, NULL, StartServer, NULL) != 0){
+        printf("Failed to create main thread\n");
+    }
+
+    /*Get the Configuration File*/
+    gConfigPath = argv[1];
+    printf("Start to open file %s\n", gConfigPath);
+    FILE *fp;
+    fp = fopen(gConfigPath, "r");
+    if(fp == NULL){
+        printf("TAFAgent_Error: PICS File Not Found %s\n", gConfigPath);
+        return -1;
+    }
+    printf("TAFAgent: Opening PICS File %s\n", gConfigPath);
+    fclose(fp);
+
+    startIUTfromArguments(argc, argv);
+    getIP(ipVerArg);
+    signal(SIGINT, HandleSigInt);
+    sleep(3);
+    printf("\nDiscovering IUT..............................\n");
+    discoverIUT(atoi(argv[3]), argv[7], argv[8]);
+    InitTAF(argv[6]);
+
+    while(!gQuitFlag){
+      if(!gIPDiscovered){
+        sleep(5);
+        startIUTfromArguments(argc, argv);
+        discoverIUT(atoi(argv[3]), argv[7], argv[8]);
+        }
+        if (strcmp(argv[9], "client") == 0){
+            SendCommand("12");
+            sleep(SLEEP_TIME);
+            printf("\nTAFAgent: Entering Main Loop For Iotivity-Lite Client Tests...\n");
+        }
+        if (strcmp(argv[9], "server") == 0){
+            printf("\nTAFAgent: Entering Main Loop For Iotivity-Lite Server Tests...\n");
+        }
+        clock_t prevClock = clock() - trigger;
+        while(!gRestartFlag){
+            gInsideMainLoop = 1;
+            clock_t curClock = clock();
+            if(curClock - prevClock >= trigger){
+                printf(".\n");
+                prevClock = curClock;
+            }
+        }
+        gInsideMainLoop = 0;
+        printf("Exiting TAF Agent main loop...\n");
+        stopIUT();
+        system("ls -lrt CertificationApp_creds/");
+        system("rm -rf CertificationApp_creds/*");
+
+        gIPDiscovered = 0;
+        gRestartFlag = 0;
+    }
+    stopDutControllers();
+    disposeDutControllers();
+    FREE(gConfigFileContent);
+    return 0;
+}
\ No newline at end of file
-- 
2.16.1.windows.1

