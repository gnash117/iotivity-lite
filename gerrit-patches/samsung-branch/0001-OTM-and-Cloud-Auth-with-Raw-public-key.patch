From d3d375d7efe10b1c961f8c423b3dc3b4c49b95e9 Mon Sep 17 00:00:00 2001
From: Uze Choi <uzchoi@samsung.com>
Date: Wed, 7 Nov 2018 17:02:28 +0900
Subject: [PATCH] OTM and Cloud Auth with Raw public key

Instead of X509 certificate Auth, ED25519 with EdDSA scheme
with Raw public key can be implemented.
OTM is done with raw pulic key mechanism with Vendor definition.
To get authenticated from cloud, thing device will send the JSON
 web token which is created in the device with key info.
RPK=1 which is required to be accompanied by ST_APP_FW=1,
will generate the binary compliant to this infra.

Change-Id: Id3ad7a856c33109fa33b2d21129a491c85a108cb
Signed-off-by: Uze Choi <uzchoi@samsung.com>
---
 deps/{cjson => cJSON}/.keep                        |   0
 port/linux/Makefile                                |  10 +-
 service/cloud-access/src/cloud_access.c            |  49 +++++-
 .../enrollee/include/samsung/sc_easysetup.h        |  19 ++
 service/easy-setup/enrollee/samsung/sc_easysetup.c | 194 ++++++++++++++++++++-
 service/st-app-fw/include/st_cloud_security.h      |  46 +++++
 service/st-app-fw/include/st_data_manager.h        |  42 +++++
 service/st-app-fw/include/st_jwt.h                 |  57 ++++++
 service/st-app-fw/include/st_manager.h             |  37 ----
 service/st-app-fw/include/st_store.h               |   0
 service/st-app-fw/src/port/linux/st_jwt.c          | 132 ++++++++++++++
 service/st-app-fw/src/st_cloud_manager.c           |  28 ++-
 service/st-app-fw/src/st_cloud_security.c          | 140 +++++++++++++++
 service/st-app-fw/src/st_data_manager.c            |  42 +++++
 service/st-app-fw/src/st_easy_setup.c              |  64 ++++++-
 service/st-app-fw/src/st_manager.c                 | 131 ++++++++++----
 service/st-app-fw/unittest/stmanagertest.cpp       |   9 -
 17 files changed, 898 insertions(+), 102 deletions(-)
 rename deps/{cjson => cJSON}/.keep (100%)
 create mode 100644 service/st-app-fw/include/st_cloud_security.h
 create mode 100644 service/st-app-fw/include/st_jwt.h
 mode change 100755 => 100644 service/st-app-fw/include/st_store.h
 create mode 100644 service/st-app-fw/src/port/linux/st_jwt.c
 create mode 100644 service/st-app-fw/src/st_cloud_security.c

diff --git a/deps/cjson/.keep b/deps/cJSON/.keep
similarity index 100%
rename from deps/cjson/.keep
rename to deps/cJSON/.keep
diff --git a/port/linux/Makefile b/port/linux/Makefile
index 4f680581..82e3d807 100644
--- a/port/linux/Makefile
+++ b/port/linux/Makefile
@@ -108,7 +108,6 @@ DTLSFLAGS=-I../../deps/mbedtls/include -D__OC_RANDOM
 
 CBOR=../../deps/tinycbor/src/cborencoder.c ../../deps/tinycbor/src/cborencoder_close_container_checked.c ../../deps/tinycbor/src/cborparser.c# ../../deps/tinycbor/src/cbortojson.c ../../deps/tinycbor/src/cborpretty.c ../../deps/tinycbor/src/cborparser_dup_string.c
 
-
 SRC_COMMON=$(wildcard ../../util/*.c) ${CBOR}
 SRC=$(wildcard ../../messaging/coap/*.c ../../api/*.c ../../port/linux/*.c)
 SRC_CA=$(wildcard ../../service/cloud-access/src/*.c)
@@ -209,9 +208,18 @@ ifeq ($(ST_APP_FW),1)
 	SRC_ST=$(wildcard ../../service/st-app-fw/src/*.c ../../service/st-app-fw/src/port/linux/*.c)
 	CFLAGS_ST=-I../../service/st-app-fw/include
 	CFLAGS_ST+= -DST_APP_FW
+ifeq ($(RPK),1)
+	CFLAGS_ST+=-I../../deps/cJSON/
+	SRC_ST+=../../deps/cJSON/cJSON.c
+endif
 	OBJ_ST=$(addprefix obj/st/,$(notdir $(SRC_ST:.c=.o)))
 endif
 
+ifeq ($(RPK),1)
+	CFLAGS_ST+=-DOC_RPK
+	VPATH += ../../deps/cJSON/:
+endif
+
 ifeq ($(DEBUG),1)
 	CFLAGS += -DOC_DEBUG -g -O0
 ifeq ($(DEBUG_TLS),1)
diff --git a/service/cloud-access/src/cloud_access.c b/service/cloud-access/src/cloud_access.c
index 7d1c63cf..38e6faa4 100644
--- a/service/cloud-access/src/cloud_access.c
+++ b/service/cloud-access/src/cloud_access.c
@@ -23,7 +23,7 @@
 
 static bool
 _oc_sign_up(oc_endpoint_t *endpoint, const char *auth_provider,
-            const char *auth_code, const char *uid, const char *access_token,
+            const char *auth_code, const char *uid, const char *access_token, const char *jwt_payload,
             size_t device_index, oc_response_handler_t handler, void *user_data)
 {
   if (!endpoint || ((!auth_provider || !auth_code) && !access_token) ||
@@ -48,6 +48,12 @@ _oc_sign_up(oc_endpoint_t *endpoint, const char *auth_provider,
         oc_rep_set_text_string(root, uid, uid);
       oc_rep_set_text_string(root, accesstoken, access_token);
     }
+    if (jwt_payload) {
+      oc_rep_set_text_string(root, haaf, "true");
+      oc_rep_set_object(root, aaf);
+      oc_rep_set_text_string(aaf, jwt, jwt_payload);
+      oc_rep_close_object(root, aaf);
+    }
     oc_rep_set_text_string(root, devicetype, "device");
     oc_rep_end_root_object();
   } else {
@@ -63,9 +69,20 @@ oc_sign_up(oc_endpoint_t *endpoint, const char *auth_provider, const char *uid,
            const char *access_token, size_t device_index,
            oc_response_handler_t handler, void *user_data)
 {
-  return _oc_sign_up(endpoint, auth_provider, NULL, uid, access_token,
+  return _oc_sign_up(endpoint, auth_provider, NULL, uid, access_token, NULL,
+                     device_index, handler, user_data);
+}
+
+#ifdef OC_RPK
+bool
+oc_sign_up_with_jwt(oc_endpoint_t *endpoint, const char *auth_provider, const char *uid, const char *jwt,
+           const char *access_token, int device_index,
+           oc_response_handler_t handler, void *user_data)
+{
+  return _oc_sign_up(endpoint, auth_provider, NULL, uid, access_token, jwt,
                      device_index, handler, user_data);
 }
+#endif
 
 #ifndef ST_APP_OPTIMIZATION
 bool
@@ -73,14 +90,14 @@ oc_sign_up_with_auth(oc_endpoint_t *endpoint, const char *auth_provider,
                      const char *auth_code, size_t device_index,
                      oc_response_handler_t handler, void *user_data)
 {
-  return _oc_sign_up(endpoint, auth_provider, auth_code, NULL, NULL,
+  return _oc_sign_up(endpoint, auth_provider, auth_code, NULL, NULL, NULL,
                      device_index, handler, user_data);
 }
 #endif /* ST_APP_OPTIMIZATION */
 
 static bool
 oc_sign_inout(oc_endpoint_t *endpoint, const char *uid,
-              const char *access_token, size_t device_index, bool is_sign_in,
+              const char *access_token, const char * jwt_payload, size_t device_index, bool is_sign_in,
               oc_response_handler_t handler, void *user_data)
 {
   if (!endpoint || (is_sign_in && !uid) || !access_token || !handler) {
@@ -99,6 +116,12 @@ oc_sign_inout(oc_endpoint_t *endpoint, const char *uid,
     oc_rep_set_text_string(root, di, uuid);
     oc_rep_set_text_string(root, accesstoken, access_token);
     oc_rep_set_boolean(root, login, is_sign_in);
+    if (jwt_payload) {
+      oc_rep_set_text_string(root, haaf, "true");
+      oc_rep_set_object(root, aaf);
+      oc_rep_set_text_string(aaf, jwt, jwt_payload);
+      oc_rep_close_object(root, aaf);
+    }
     oc_rep_end_root_object();
   } else {
     OC_ERR("Could not init POST request for sign in/out");
@@ -108,19 +131,29 @@ oc_sign_inout(oc_endpoint_t *endpoint, const char *uid,
   return oc_do_post();
 }
 
+#ifdef OC_RPK
+bool
+oc_sign_in_with_jwt(oc_endpoint_t *endpoint, const char *uid, const char *access_token,
+           const char *jwt, size_t device_index, oc_response_handler_t handler, void *user_data)
+{
+  return oc_sign_inout(endpoint, uid, access_token, jwt, device_index, true, handler,
+                       user_data);
+}
+#endif
+
 bool
 oc_sign_in(oc_endpoint_t *endpoint, const char *uid, const char *access_token,
            size_t device_index, oc_response_handler_t handler, void *user_data)
 {
-  return oc_sign_inout(endpoint, uid, access_token, device_index, true, handler,
+  return oc_sign_inout(endpoint, uid, access_token, NULL, device_index, true, handler,
                        user_data);
 }
 
 bool
-oc_sign_out(oc_endpoint_t *endpoint, const char *access_token,
-            size_t device_index, oc_response_handler_t handler, void *user_data)
+oc_sign_out(oc_endpoint_t *endpoint, const char *access_token, size_t device_index,
+            oc_response_handler_t handler, void *user_data)
 {
-  return oc_sign_inout(endpoint, NULL, access_token, device_index, false,
+  return oc_sign_inout(endpoint, NULL, access_token, NULL, device_index, false,
                        handler, user_data);
 }
 
diff --git a/service/easy-setup/enrollee/include/samsung/sc_easysetup.h b/service/easy-setup/enrollee/include/samsung/sc_easysetup.h
index f123723e..47a4a466 100644
--- a/service/easy-setup/enrollee/include/samsung/sc_easysetup.h
+++ b/service/easy-setup/enrollee/include/samsung/sc_easysetup.h
@@ -297,6 +297,25 @@ typedef struct
   int targets_size;
   bool owned;
   oc_string_t easysetup_di;
+
+#ifdef OC_RPK
+  uint8_t cpub[64];       /* ecc-based peer's public key */
+  int cpub_len;
+  uint8_t token_hash[64]; /* ecc-based hashed access token */
+  int token_hash_len;
+  uint8_t seckey[32];     /* ecc-based device private key */
+  int seckey_len;
+  uint8_t pubkey[32];     /* ecc-based device public key */
+  int pubkey_len;
+  uint8_t sn[32];
+  int sn_len;
+  uint32_t nonce;
+
+  /* Upper 8bit(0xFF00) used for mobile (req), lower 8bit(0x00FF) used for things (own) */
+  uint16_t otmsupportfeature;
+  uint8_t otm_own_hash[32];
+#endif /*OC_RPK*/
+
 } sec_provisioning_info;
 
 /**
diff --git a/service/easy-setup/enrollee/samsung/sc_easysetup.c b/service/easy-setup/enrollee/samsung/sc_easysetup.c
index 9072a3d3..9e41511d 100644
--- a/service/easy-setup/enrollee/samsung/sc_easysetup.c
+++ b/service/easy-setup/enrollee/samsung/sc_easysetup.c
@@ -24,6 +24,9 @@
 #include "oc_rep.h"
 #include "security/oc_acl.h"
 #include "util/oc_mem.h"
+#ifdef OC_RPK
+#include "mbedtls/base64.h"
+#endif
 
 #define SC_RSRVD_ES_URI_PROVISIONING_INFO "/sec/provisioninginfo"
 #define SC_RSRVD_ES_RES_TYPE_PROVISIONING_INFO "x.com.samsung.provisioninginfo"
@@ -74,6 +77,24 @@
 #define SC_RSRVD_ES_PROVISIONING_INFO_TARGETRT "targetRt"
 #define SC_RSRVD_ES_PROVISIONING_INFO_PUBLISHED "published"
 
+#ifdef OC_RPK
+/* for ED25519 supporting */
+#define SC_RSRVD_ES_PROVISIONING_INFO_SN "provisioning.sn"
+#define SC_RSRVD_ES_PROVISIONING_INFO_NONCE "provisioning.nonce"
+#define SC_RSRVD_ES_PROVISIONINGINFO_CPUB "x.com.samsung.provisioning.cpub"
+#define SC_RSRVD_ES_PROVISIONINGINFO_TOKEN_HASH "x.com.samsung.provisioning.tokenhash"
+
+/* for otmfeature handling */
+#define SC_RSRVD_ES_PROVISIONINGINFO_HASH "x.com.samsung.provisioning.hash"
+#define SC_RSRVD_ES_PROVISIONINGINFO_OTMSUPF "x.com.samsung.provisioning.otmsupportfeature"
+
+/* Assume that mobile sends only 0xFF ~ 0x00 values for OTMSUPF */
+#define THING_OTMSUPF_MSK         (0x000000FF)
+#define REQ_OTMSUPF_SHIFT         (8)
+#define OTMSUP_FEATURE_QR         (0x10)
+#define OTMSUP_FEATURE_BUTTEN     (0x20)
+#endif /*OC_RPK*/
+
 #define SC_RSRVD_ES_ACCESSPOINT_LIST_AP_ITEMS "accesspoint.items"
 #define SC_RSRVD_ES_ACCESSPOINT_LIST_CHANNEL "channel"
 #define SC_RSRVD_ES_ACCESSPOINT_LIST_ENCRYPTION_TYPE "encryptionType"
@@ -459,11 +480,132 @@ sc_free_userdata(void *user_data, char *resource_type)
 }
 
 // --- "/sec/provisioninginfo" resource related code -----
-static void
+static oc_status_t
 update_provisioning_info_resource(oc_request_t *request)
 {
-  (void)request;
-  // TODO - Add update when more write properties are added
+#if defined(OC_RPK) && defined(OC_SECURITY)
+  oc_sec_doxm_t *curr_doxm = oc_sec_get_doxm(0);
+  if (curr_doxm->oxmsel != OC_DOXM_RPK)
+    return OC_STATUS_BAD_REQUEST;
+
+  sec_provisioning_info *info = g_sec_prov->info;
+  oc_rep_t *p;
+  char buf[256] = {0, };
+  char *str_val;
+  int len, ret, size;
+  int i, str_val_len;
+  uint32_t req_otmsupf;
+  uint16_t curr_otmsupf;
+  unsigned char otm_hash_val;
+
+  p = request->request_payload;
+
+  while (p) {
+    len = oc_string_len(p->name);
+    memset(buf, 0, sizeof(buf));
+    OC_DBG("name: %s (%d), type: %d", oc_string(p->name), len, p->type);
+
+    switch (p->type) {
+      case OC_REP_INT:
+        if (len && memcmp(oc_string(p->name), SC_RSRVD_ES_PROVISIONINGINFO_OTMSUPF,
+                          strlen(SC_RSRVD_ES_PROVISIONINGINFO_OTMSUPF)) == 0) {
+          OC_DBG("req_otmsupportf: 0x%x, curr: 0x%x",
+                  p->value.integer, info->otmsupportfeature);
+          req_otmsupf = (p->value.integer & THING_OTMSUPF_MSK);
+          if (req_otmsupf & (info->otmsupportfeature & THING_OTMSUPF_MSK)) {
+            OC_DBG("%s: otmsupportf matched!!");
+            info->otmsupportfeature &= THING_OTMSUPF_MSK;
+            info->otmsupportfeature |= (req_otmsupf << REQ_OTMSUPF_SHIFT);
+          } else {
+            OC_DBG("%s: otmsupportf un-matched!!");
+            return OC_STATUS_BAD_REQUEST;
+          }
+        }
+        break;
+
+      case OC_REP_STRING:
+        /* for RPK handling */
+        if (len && memcmp(oc_string(p->name), SC_RSRVD_ES_PROVISIONINGINFO_CPUB,
+                          strlen(SC_RSRVD_ES_PROVISIONINGINFO_CPUB)) == 0) {
+          OC_DBG("cpub: %s", oc_string(p->value.string));
+          if ((ret = mbedtls_base64_urlsafe_decode((unsigned char *)buf, sizeof(buf), &size,
+                                    (const unsigned char *)oc_string(p->value.string),
+                                    oc_string_len(p->value.string))) != 0) {
+            OC_ERR("failed to decode key: -0x%x", -ret);
+            break;
+          }
+          OC_DBG("decode [urlsafe] %d -> %d", oc_string_len(p->value.string), size);
+          memcpy(info->cpub, buf, size);
+          info->cpub_len = size;
+          hex_dump_data(info->cpub, size);
+        } else if (len && memcmp(oc_string(p->name), SC_RSRVD_ES_PROVISIONINGINFO_TOKEN_HASH,
+                   strlen(SC_RSRVD_ES_PROVISIONINGINFO_TOKEN_HASH)) == 0) {
+          str_val = oc_string(p->value.string);
+          str_val_len = strlen(str_val);
+
+          OC_DBG("token_hash: %s (len:%d)", str_val, str_val_len);
+
+          size = 0;
+          /* Assume that 'token_hash' is plain text of sha256 values */
+          for (i = 0; i < str_val_len; i+=2) {
+            memcpy(buf, (str_val + i), 2);
+            buf[2] = '\0';
+            info->token_hash[size] = (unsigned char)strtoul(buf, NULL, 16);
+            size++;
+          }
+
+          OC_DBG("token_hash: decode [plain text] %d -> %d", str_val_len, size);
+          info->token_hash_len = size;
+          hex_dump_data(info->token_hash, size);
+
+        /* for otmfeature handling */
+        } else if (len && memcmp(oc_string(p->name), SC_RSRVD_ES_PROVISIONINGINFO_HASH,
+                                 strlen(SC_RSRVD_ES_PROVISIONINGINFO_HASH)) == 0) {
+          str_val = oc_string(p->value.string);
+          str_val_len = strlen(str_val);
+
+          OC_DBG("otm_hash: %s (len:%d)", str_val, str_val_len);
+          curr_otmsupf = (info->otmsupportfeature >> REQ_OTMSUPF_SHIFT);
+
+          if ((curr_otmsupf & OTMSUP_FEATURE_QR) && (str_val_len != 0)) {
+            /* QR handling condition : otmsupf == 0x10, "hash" has string */
+            OC_DBG("QR hash triggered");
+
+            /* Assume that 'otm_hash' is plain text of sha256 values */
+            size = 0;
+            for (i = 0; i < str_val_len; i+=2) {
+              memcpy(buf, (str_val + i), 2);
+              buf[2] = '\0';
+              otm_hash_val = (unsigned char)strtoul(buf, NULL, 16);
+              if (info->otm_own_hash[size] != otm_hash_val) {
+                OC_DBG("WARNING QR hash mis-matched!!, idx:%d, own:0x%x, get:0x%x",
+                  i, info->otm_own_hash[size], otm_hash_val);
+                return OC_STATUS_BAD_REQUEST;
+              }
+              size++;
+            }
+
+          } else if ((curr_otmsupf & OTMSUP_FEATURE_BUTTEN) && (str_val_len == 0)) {
+            /* Butten handling condition : otmsupf == 0x20, "hash" has NULL */
+            OC_DBG("User Butten hash triggered");
+            /* TO DO : Need to implement user confirm with 2 min timeout */
+
+          } else {
+            /* Unsupported hash values */
+            OC_DBG("Unsupported otmsupportf req & hash");
+            hex_dump_data(str_val, str_val_len);
+            return OC_STATUS_BAD_REQUEST;
+          }
+        }
+        break;
+    }
+
+    p = p->next;
+  }
+#else
+  (void) request;
+#endif /*OC_RPK && OC_SECURITY*/
+  return OC_STATUS_CHANGED;
 }
 
 static void
@@ -509,6 +651,43 @@ construct_response_of_sec_provisioning(void)
   es_rep_set_text_string_with_keystr(root, key_name,
                                      oc_string(info->easysetup_di));
 
+#if defined(OC_RPK) && defined(OC_SECURITY)
+  oc_sec_doxm_t *curr_doxm = oc_sec_get_doxm(0);
+  if (curr_doxm->oxmsel != OC_DOXM_RPK)
+    goto end_process;
+
+  char val_str[65] = {0, };
+  int wz = 0;
+  for (int i = 0; i < 32; i++) {
+    wz += sprintf(val_str + wz, "%02X", info->sn[i]);
+    if (wz >= 64)
+      break;
+  }
+  val_str[wz] = '\0';
+  OC_DBG("Current SN str: %s", val_str);
+
+  construct_vnd_attr_name(key_name, SC_MAX_ES_ATTR_NAME_LEN,
+                          SC_RSRVD_ES_PROVISIONING_INFO_SN);
+  es_rep_set_text_string_with_keystr(root, key_name, val_str);
+
+  wz = sizeof(info->nonce) * 2 + 1;
+  snprintf(val_str, wz, "%08X", info->nonce);
+  OC_DBG("Current nonce str: %s", val_str);
+
+  construct_vnd_attr_name(key_name, SC_MAX_ES_ATTR_NAME_LEN,
+                          SC_RSRVD_ES_PROVISIONING_INFO_NONCE);
+  es_rep_set_text_string_with_keystr(root, key_name, val_str);
+
+  oc_rep_set_byte_string(root, x.com.samsung.provisioning.cpub,
+                         info->cpub, info->cpub_len);
+  oc_rep_set_byte_string(root, x.com.samsung.provisioning.tokenhash,
+                         info->token_hash, info->token_hash_len);
+
+  oc_rep_set_int(root, x.com.samsung.provisioning.otmsupportfeature,
+      ((info->otmsupportfeature) & 0xFF));
+
+end_process:
+#endif /*OC_RPK & OC_SECURITY*/
   oc_rep_end_root_object();
 }
 
@@ -533,6 +712,7 @@ static void
 post_sec_provisioning(oc_request_t *request, oc_interface_mask_t interface,
                       void *user_data)
 {
+  oc_status_t rep_code;
   (void)user_data;
   OC_DBG("GET request received");
 
@@ -542,9 +722,11 @@ post_sec_provisioning(oc_request_t *request, oc_interface_mask_t interface,
     return;
   }
 
-  update_provisioning_info_resource(request);
-  construct_response_of_sec_provisioning();
-  oc_send_response(request, OC_STATUS_CHANGED);
+  rep_code = update_provisioning_info_resource(request);
+  if (rep_code == OC_STATUS_CHANGED) {
+    construct_response_of_sec_provisioning();
+  }
+  oc_send_response(request, rep_code);
 }
 
 es_result_e
diff --git a/service/st-app-fw/include/st_cloud_security.h b/service/st-app-fw/include/st_cloud_security.h
new file mode 100644
index 00000000..964f74ae
--- /dev/null
+++ b/service/st-app-fw/include/st_cloud_security.h
@@ -0,0 +1,46 @@
+/****************************************************************************
+*
+* Copyright 2018 Samsung Electronics All Rights Reserved.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+* either express or implied. See the License for the specific
+* language governing permissions and limitations under the License.
+*
+****************************************************************************/
+
+#ifdef OC_RPK
+
+#ifndef CLOUD_SECURITY_H
+#define CLOUD_SECURITY_H
+
+#define JWT_BUFFER_SIZE 512
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+  @brief A function for getting JWT with RPK profile data
+  @param outbuf Generated JWT formatted data
+  @param pub_key The public key string
+  @param priv_key The public key string
+  @param sn The serial number of device
+  @return int result of this function call
+  @retval 0 success result for this function call
+  @retval -1 fail result for this function call
+*/
+int st_sign_jwt_getter(char **outbuf, const char *pub_key, const char *priv_key, const char *sn);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /*!CLOUD_SECURITY_H*/
+#endif /*OC_RPK*/
diff --git a/service/st-app-fw/include/st_data_manager.h b/service/st-app-fw/include/st_data_manager.h
index d28748ca..ce3f251f 100644
--- a/service/st-app-fw/include/st_data_manager.h
+++ b/service/st-app-fw/include/st_data_manager.h
@@ -148,6 +148,48 @@ st_resource_info_t *st_data_mgr_get_resource_info(void);
 st_resource_type_t *st_data_mgr_get_rsc_type_info(const char *rt);
 st_configuration_t *st_data_mgr_get_config_info(void);
 
+
+#ifdef OC_RPK
+
+#define ST_SECURE_KEY_LEN  (32)
+
+/**
+  @brief A data structure of RPK profile data.
+*/
+typedef struct st_rpk_profile {
+  char sign_seckey[ST_SECURE_KEY_LEN]; /* ecc based DSA private key */
+  char sign_pubkey[ST_SECURE_KEY_LEN]; /* ecc based DSA public key */
+  char seckey[ST_SECURE_KEY_LEN];      /* ecc based key-exchange private key */
+  char pubkey[ST_SECURE_KEY_LEN];      /* ecc based key-exchange public key */
+  char sn[64];                         /* serial number of device */
+  int  sn_len;
+  unsigned char otmsupf;               /* Things's own supported features */
+} st_rpk_profile_t;
+
+/**
+  @brief A function for getting RPK profile data.
+  @return st_rpk_profile_t The pointer of RPK profile data which is declared in the framework
+*/
+st_rpk_profile_t *st_data_get_rpk_profile(void);
+
+/**
+  @brief A function for setting RPK profile data
+    RPK profile data is expected to be retrived from the private section from the device.
+    This function will copy the data into the framework area.
+    No need to maintain this data from the application after this function call
+  @return error_code 0 is succss, -1 is error case in alloc
+  @param profile RPK profile data
+*/
+int st_data_load_rpk_profile(st_rpk_profile_t *profile);
+
+/**
+  @brief A free function for RPK profile data
+*/
+void st_free_rpk_profile(void);
+
+#endif /*OC_RPK*/
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/service/st-app-fw/include/st_jwt.h b/service/st-app-fw/include/st_jwt.h
new file mode 100644
index 00000000..55f3a12b
--- /dev/null
+++ b/service/st-app-fw/include/st_jwt.h
@@ -0,0 +1,57 @@
+/****************************************************************************
+ *
+ * Copyright 2018 Samsung Electronics All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ ****************************************************************************/
+
+#ifdef OC_RPK
+
+#ifndef ST_JWT_H
+#define ST_JWT_H
+#include <stdbool.h>
+
+#define JSON_HEADER_SIZE 256
+#define JSON_PAYLOAD_SIZE 256
+#define JSON_SIGNATURE_SIZE 384
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+  @brief A function to getting the header and payload section of JWT for signup
+    This is designed to be implemented specifically in each OS port.
+*/
+bool st_jwt_json_signup_get(char *header, char *payload, const char *sn);
+
+/**
+  @brief A function to getting the header and payload section of JWT for signin
+    This is designed to be implemented specifically in each OS port.
+*/
+bool st_jwt_json_signin_get(char *header, char *payload, const char *sn);
+
+/**
+  @brief A function to getting the signature of JWT
+    This is designed to be implemented specifically in each OS port.
+*/
+bool st_jwt_signature_get(char *signature, const char *pub_key,
+                          const char *priv_key, const char *message, int message_len);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*ST_JWT_H*/
+#endif /*OC_RPK*/
diff --git a/service/st-app-fw/include/st_manager.h b/service/st-app-fw/include/st_manager.h
index 5454197a..065ef032 100644
--- a/service/st-app-fw/include/st_manager.h
+++ b/service/st-app-fw/include/st_manager.h
@@ -47,26 +47,6 @@ typedef bool (*st_otm_confirm_cb_t)(void);
 */
 typedef void (*st_status_cb_t)(st_status_t status);
 
-/**
-  @brief A function pointer for handling the RPK client public key & token.
-  @param cpub_key uint8_t pointer to be copied client public key.
-  @param cpub_key_len int pointer to be copied client public key length.
-  @param token uint8_t pointer to be copied token.
-  @param token_len int pointer to be copied token length.
-*/
-typedef void (*st_rpk_handle_cpubkey_and_token_cb_t)(uint8_t *cpub_key,
-                                                     int *cpub_key_len,
-                                                     uint8_t *token,
-                                                     int *token_len);
-
-/**
-  @brief A function pointer for handling the RPK private key.
-  @param priv_key uint8_t pointer to be copied private key.
-  @param priv_key_len int pointer to be copied private key length.
-*/
-typedef void (*st_rpk_handle_priv_key_cb_t)(uint8_t *priv_key,
-                                            int *priv_key_len);
-
 /**
   @brief A function to initialize ST application framework.
   @return st_error_t An enumeration of possible outcomes.
@@ -187,23 +167,6 @@ bool st_register_status_handler(st_status_cb_t cb);
 */
 void st_unregister_status_handler(void);
 
-/**
-  @brief A function for registering RPK handler
-  @param pubkey_cb Callback function to handle the RPK client public key &
-  token.
-  @param privkey_cb Callback function to handle the RPK private key.
-  @return bool Description of result.
-  @retval true if successful.
-  @retval false Input parameter is NULL or it is already registered.
-*/
-bool st_register_rpk_handler(st_rpk_handle_cpubkey_and_token_cb_t pubkey_cb,
-                             st_rpk_handle_priv_key_cb_t privkey_cb);
-
-/**
-  @brief A function for unregister RPK handler
-*/
-void st_unregister_rpk_handler(void);
-
 /**
   @brief A function set device profile.
   @param device_def Unsigned char array showing CBOR info.
diff --git a/service/st-app-fw/include/st_store.h b/service/st-app-fw/include/st_store.h
old mode 100755
new mode 100644
diff --git a/service/st-app-fw/src/port/linux/st_jwt.c b/service/st-app-fw/src/port/linux/st_jwt.c
new file mode 100644
index 00000000..e910d840
--- /dev/null
+++ b/service/st-app-fw/src/port/linux/st_jwt.c
@@ -0,0 +1,132 @@
+/****************************************************************************
+*
+* Copyright 2018 Samsung Electronics All Rights Reserved.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+* either express or implied. See the License for the specific
+* language governing permissions and limitations under the License.
+*
+****************************************************************************/
+
+#ifdef OC_RPK
+
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <stdbool.h>
+#include <oc_log.h>
+#include <oc_uuid.h>
+#include <util/oc_mem.h>
+#include <cJSON.h>
+#include "st_jwt.h"
+#include "st_port.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#define TIMETOSTRING_SIZE 11 // example of time_t is "1514764800"
+static bool
+jwt_json_get_createdts(char *dts)
+{
+  time_t now = time(NULL);
+  sprintf(dts, "%d", now);
+  return (now != -1) ? true:false;
+}
+
+static bool
+jwt_json_signup_cjson(char *out_header, char *out_payload, const char *sn)
+{
+  cJSON *jwt_header = cJSON_CreateObject();
+  cJSON *jwt_payload = cJSON_CreateObject();
+
+  oc_uuid_t random_uuid;
+  char random_uuid_str[OC_UUID_LEN];
+  char dts[TIMETOSTRING_SIZE];
+
+  cJSON_AddStringToObject(jwt_header,"alg","EdDSA");
+  cJSON_AddStringToObject(jwt_header,"kty","OKP");
+  cJSON_AddStringToObject(jwt_header,"crv","Ed25519");
+  cJSON_AddStringToObject(jwt_header,"typ","JWT");
+  cJSON_AddStringToObject(jwt_header,"ver","1.0.0");
+  cJSON_AddStringToObject(jwt_header,"kid", sn);
+
+  if(!jwt_json_get_createdts(dts)) {
+    //If we fail to create createdts, set time 2018-1-1 00:00
+    st_print_log("createdts is NULL, we can not make jwt\n");
+    cJSON_AddStringToObject(jwt_payload,"iat", "1514764800");
+  } else {
+    cJSON_AddStringToObject(jwt_payload,"iat", dts);
+  }
+
+  //make random uuid string
+  oc_gen_uuid(&random_uuid);
+  oc_uuid_to_str(&random_uuid, random_uuid_str, OC_UUID_LEN);
+  cJSON_AddStringToObject(jwt_payload,"jti",random_uuid_str);
+
+  char *header_str = cJSON_Print(jwt_header);
+  strncpy(out_header, header_str, JSON_HEADER_SIZE);
+  char *payload_str = cJSON_Print(jwt_payload);
+  strncpy(out_payload, payload_str, JSON_PAYLOAD_SIZE);
+
+  cJSON_Delete(jwt_header);
+  cJSON_Delete(jwt_payload);
+
+  return true;
+}
+
+static bool
+jwt_json_signin_cjson(char *header, char *payload, const char *sn)
+{
+  //now, sign-up, sign-in is same.
+  return jwt_json_signup_cjson(header, payload, sn);
+}
+
+static bool
+jwt_sign_ed25519(char *signature, const char *pub_key, const char *priv_key,
+                             const char *message, int message_len)
+{
+//Equivalent logic for edsign_sign is required here.
+//edsign_sign(signature, pub_key, priv_key, message, message_len);
+  (void) signature;
+  (void) pub_key;
+  (void) priv_key;
+  (void) message;
+  (void) message_len;
+
+  return false;
+}
+
+bool
+st_jwt_json_signup_get(char *header, char *payload, const char *sn)
+{
+  return jwt_json_signup_cjson(header, payload, sn);
+}
+
+bool
+st_jwt_json_signin_get(char *header, char *payload, const char *sn)
+{
+  return jwt_json_signin_cjson(header, payload, sn);
+}
+
+bool
+st_jwt_signature_get(char *signature, const char *pub_key, const char *priv_key,
+                          const char *message, int message_len)
+{
+  return jwt_sign_ed25519(signature, pub_key, priv_key, message, message_len);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*OC_RPK*/
diff --git a/service/st-app-fw/src/st_cloud_manager.c b/service/st-app-fw/src/st_cloud_manager.c
index 993061b6..bc1ed633 100644
--- a/service/st-app-fw/src/st_cloud_manager.c
+++ b/service/st-app-fw/src/st_cloud_manager.c
@@ -17,6 +17,9 @@
  ****************************************************************************/
 
 #include "st_cloud_manager.h"
+#ifdef OC_RPK
+#include "st_data_manager.h"
+#endif
 #include "cloud_access.h"
 #include "easysetup.h"
 #include "oc_api.h"
@@ -392,12 +395,23 @@ sign_up(void *data)
       st_cloud_store_t cloudinfo = st_store_get_info()->cloudinfo;
       if (0 == oc_string_to_endpoint(&cloudinfo.ci_server, &context->cloud_ep,
                                      NULL)) {
+#ifdef OC_JWT
+        char *jwt;
+        st_rpk_profile_t *profile = st_data_get_rpk_profile();
+        st_sign_jwt_getter(&jwt, profile->sign_pubkey, profile->sign_seckey, profile->sn);
+        oc_sign_up_with_jwt(&context->cloud_ep, oc_string(cloudinfo.auth_provider),
+                 oc_string(cloudinfo.uid), (const char *)jwt, oc_string(cloudinfo.access_token),
+                 context->device_index, sign_up_handler, context);
+        oc_mem_free(jwt);
+#else
         oc_sign_up(&context->cloud_ep, oc_string(cloudinfo.auth_provider),
                    oc_string(cloudinfo.uid), oc_string(cloudinfo.access_token),
                    context->device_index, sign_up_handler, context);
       }
       oc_set_delayed_callback(context, sign_up,
                               session_timeout[context->retry_count]);
+
+#endif /*OC_JWT*/
     }
   }
 
@@ -452,12 +466,22 @@ sign_in(void *data)
       st_cloud_store_t cloudinfo = st_store_get_info()->cloudinfo;
       if (0 == oc_string_to_endpoint(&cloudinfo.ci_server, &context->cloud_ep,
                                      NULL)) {
+#ifdef OC_JWT
+        char *jwt;
+        st_rpk_profile_t *profile = st_manager_get_profile();
+        st_sign_jwt_getter(&jwt, profile->sign_pubkey, profile->sign_seckey, profile->sn);
+        oc_sign_in_with_jwt(&context->cloud_ep, oc_string(cloudinfo.uid),
+                 oc_string(cloudinfo.access_token), jwt, context->device_index,
+                 sign_in_handler, context);
+        oc_mem_free(jwt);
+#else
         oc_sign_in(&context->cloud_ep, oc_string(cloudinfo.uid),
-                   oc_string(cloudinfo.access_token), 0, sign_in_handler,
-                   context);
+                   oc_string(cloudinfo.access_token), context->device_index,
+                   sign_in_handler, context);
       }
       oc_set_delayed_callback(context, sign_in,
                               session_timeout[context->retry_count]);
+#endif /*OC_JWT*/
     }
   }
 
diff --git a/service/st-app-fw/src/st_cloud_security.c b/service/st-app-fw/src/st_cloud_security.c
new file mode 100644
index 00000000..55419b88
--- /dev/null
+++ b/service/st-app-fw/src/st_cloud_security.c
@@ -0,0 +1,140 @@
+/****************************************************************************
+*
+* Copyright 2018 Samsung Electronics All Rights Reserved.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+* either express or implied. See the License for the specific
+* language governing permissions and limitations under the License.
+*
+****************************************************************************/
+
+/*
+--jwt structure--
+Header
+{
+"alg":"EdDSA",
+"kty":"OKP",
+"crv":"Ed25519", // https://tools.ietf.org/html/draft-ietf-jose-cfrg-curves-06
+"typ": "JWT",
+"ver": "1.0.0",
+"kid": "sn" // KeyId, serial number
+}
+Payload
+{
+"iat": "$unixepoch", // Issued At
+"jti": "$random_string_uuid_format" // JWT ID, nonce
+}
+*/
+
+#ifdef OC_RPK
+
+#include <string.h>
+#include "util/oc_mem.h"
+#include "mbedtls/base64.h"
+#include "st_jwt.h"
+#include "st_cloud_security.h"
+#include "st_port.h"
+
+int
+st_sign_jwt_getter(char **outbuf, const char *pub_key, const char *priv_key, const char *sn)
+{
+  if ((outbuf == NULL)||(pub_key == NULL)||(priv_key == NULL)||(sn == NULL))
+    goto fail;
+
+  char jwt_header_data[JSON_HEADER_SIZE];
+  char jwt_payload_data[JSON_PAYLOAD_SIZE];
+  char signature[64] = {0, };
+
+  char *tmpbuf = NULL;
+  int olen = 0;
+  int ret = 0;
+
+  tmpbuf = *outbuf = NULL;
+
+  *outbuf = (char *)oc_mem_malloc(JWT_BUFFER_SIZE);
+  tmpbuf = (char *)oc_mem_malloc(JSON_PAYLOAD_SIZE);
+
+  // error checking
+  if (!*outbuf || !tmpbuf) {
+    goto fail;
+  }
+
+  st_jwt_json_signup_get(jwt_header_data, jwt_payload_data, sn);
+  st_print_log("json object information.\n<header> \n%s\n<payload>\n%s\n",
+               jwt_header_data, jwt_payload_data);
+
+  /* encoding base64 */
+  ret = mbedtls_base64_encode((unsigned char *)*outbuf, (size_t)JWT_BUFFER_SIZE, (size_t *)&olen,
+                         (const unsigned char *)jwt_header_data, (size_t)strlen(jwt_header_data));
+  if(ret != 0) {
+    goto fail;
+  }
+
+  ret = mbedtls_base64_encode((unsigned char *)tmpbuf, (size_t)JSON_PAYLOAD_SIZE, (size_t *)&olen,
+                         (const unsigned char *)jwt_payload_data, (size_t)strlen(jwt_payload_data));
+  if(ret != 0) {
+    goto fail;
+  }
+
+  /*make jwt style xxx.yyy */
+  strcat(*outbuf, ".");
+  strcat(*outbuf, tmpbuf);
+
+  //tmpbuf should be larger for signature
+  oc_mem_free(tmpbuf);
+  tmpbuf = NULL;
+
+  if (!st_jwt_signature_get(signature, pub_key, priv_key, *outbuf, strlen(*outbuf))) {
+    goto fail;
+  }
+
+  //hex_dump_data(signature, sizeof(signature));
+
+  tmpbuf = (char *)oc_mem_malloc(JSON_SIGNATURE_SIZE);
+  // error checking
+  if (!tmpbuf) {
+    goto fail;
+  }
+
+  memset(tmpbuf, 0, JSON_SIGNATURE_SIZE);
+  ret = mbedtls_base64_encode((unsigned char *)tmpbuf, (size_t)JSON_SIGNATURE_SIZE, (size_t *)&olen,
+                              (const unsigned char *)signature, (size_t)64);
+  st_print_log("signature is\n %s, ret = %d\n", tmpbuf, ret);
+
+  if(ret != 0) {
+    goto fail;
+  }
+
+  /*complete jwt with signature xxx.yyy.zzz */
+  strcat(*outbuf, ".");
+  strcat(*outbuf, tmpbuf);
+
+  st_print_log("final jwt data\n%s\n", *outbuf);
+
+  if (tmpbuf != NULL) {
+    oc_mem_free(tmpbuf);
+    tmpbuf = NULL;
+  }
+  return 0;
+
+fail:
+  if (*outbuf != NULL) {
+    oc_mem_free(*outbuf);
+    *outbuf = NULL;
+  }
+  if (tmpbuf != NULL) {
+    oc_mem_free(tmpbuf);
+    tmpbuf = NULL;
+  }
+  return -1;
+}
+
+#endif
\ No newline at end of file
diff --git a/service/st-app-fw/src/st_data_manager.c b/service/st-app-fw/src/st_data_manager.c
index 24efd030..9dacd01c 100644
--- a/service/st-app-fw/src/st_data_manager.c
+++ b/service/st-app-fw/src/st_data_manager.c
@@ -765,3 +765,45 @@ st_free_device_profile(void)
 #endif
   g_device_def_len = 0;
 }
+
+#ifdef OC_RPK
+
+static st_rpk_profile_t *g_st_rpk_profile;
+OC_MEMB(st_rpk_profile_s, st_rpk_profile_t, 1);
+
+int
+st_data_load_rpk_profile(st_rpk_profile_t *rpk_profile)
+{
+  int ret = 0;
+  if (!rpk_profile) {
+    st_print_log("[ST_DM] err: invalid args\n");
+    return -1;
+  }
+  if (!g_st_rpk_profile) {
+    g_st_rpk_profile = oc_memb_alloc(&st_rpk_profile_s);
+    if (!g_st_rpk_profile) {
+	  st_print_log("[ST_DM] alloc failed\n");
+	  return -1;
+    }
+  }
+  memcpy(g_st_rpk_profile, rpk_profile, sizeof(st_rpk_profile_t));
+  return ret;
+}
+
+void
+st_free_rpk_profile(void) {
+#ifdef OC_DYNAMIC_ALLOCATION
+  if (g_st_rpk_profile) {
+    oc_mem_free(g_st_rpk_profile);
+    g_st_rpk_profile = NULL;
+  }
+#endif
+}
+
+st_rpk_profile_t
+*st_data_get_rpk_profile(void)
+{
+  return g_st_rpk_profile;
+}
+
+#endif /*OC_RPK*/
diff --git a/service/st-app-fw/src/st_easy_setup.c b/service/st-app-fw/src/st_easy_setup.c
index 46ecd6e5..9518a94f 100644
--- a/service/st-app-fw/src/st_easy_setup.c
+++ b/service/st-app-fw/src/st_easy_setup.c
@@ -25,9 +25,19 @@
 #include "st_port.h"
 #include "st_store.h"
 
-#include <stdlib.h>
-
 #define EASYSETUP_TAG "E1"
+
+#if defined(OC_RPK) && defined(OC_SECURITY)
+#include "security/oc_otm_state.h"
+#include "security/oc_doxm.h"
+#include "st_data_manager.h"
+#include "mbedtls/sha256.h"
+#include "mbedtls/base64.h"
+
+#define EASYSETUP_TAG_2 "E2"
+#define E2_SSID_POST (8)
+#endif /*OC_RPK && OC_SECURITY*/
+
 #define EASYSETUP_TIMEOUT (60)
 typedef enum {
   ST_EASY_SETUP_DEV_PROV = 1 << 0,
@@ -172,15 +182,53 @@ int
 st_gen_ssid(char *ssid, const char *device_name, const char *mnid,
             const char *setup_id)
 {
-  unsigned char mac[6] = { 0 };
+#if defined(OC_RPK) && defined(OC_SECURITY)
+#define BASE64_URI_SIZE 50
+  oc_sec_doxm_t *curr_doxm = oc_sec_get_doxm(0);
+  if (curr_doxm && curr_doxm->oxmsel && (curr_doxm->oxmsel == OC_DOXM_RPK)) {
+    st_rpk_profile_t *profile = st_data_get_rpk_profile();
+    unsigned char base64_url[BASE64_URI_SIZE] = {0,};
+    unsigned char hash[32] = {0};
+    char ssid_sn[E2_SSID_POST + 1] = {0,};
+    size_t base64_url_wz;
+
+    if (!profile || !profile->sn || !profile->sn_len) {
+      return -1;
+    }
+    int ret = mbedtls_sha256_ret((unsigned char*)profile->sn, profile->sn_len, hash, 0);
+    if (ret != 0) {
+      st_print_log("%s: Faild to convert sha256(str: %s, len:%d)",
+        __func__, profile->sn, profile->sn_len);
+      return -1;
+    }
 
-  if (!oc_get_mac_addr(mac)) {
-    st_print_log("[ST_ES] oc_get_mac_addr failed!\n");
-    return -1;
-  }
+    ret = mbedtls_base64_urlsafe_encode(base64_url, BASE64_URI_SIZE,
+            &base64_url_wz, hash, sizeof(hash));
+    if (ret != 0) {
+      st_print_log("%s: Faild to convert by base64_url_safe\n",
+        __func__);
+      return -1;
+    }
 
-  snprintf(ssid, MAX_SSID_LEN, "%s_%s%s%s%d%02X%02X", device_name,
+    memcpy(ssid_sn, base64_url, E2_SSID_POST);
+    ssid_sn[E2_SSID_POST] = '\0';
+	//Oven_E21MNID001abcdefgh
+    snprintf(ssid, MAX_SSID_LEN, "%s_%s%d%s%s%s",
+        device_name, EASYSETUP_TAG_2, 1, mnid, setup_id, ssid_sn);
+  } else
+#endif /*OC_RPK && OC_SECURITY*/
+  {
+    unsigned char mac[6] = { 0 };
+
+    if (!oc_get_mac_addr(mac)) {
+      st_print_log("[ST_ES] oc_get_mac_addr failed!\n");
+      return -1;
+    }
+	//Oven_E1MNID0010AABB
+    snprintf(ssid, MAX_SSID_LEN, "%s_%s%s%s%d%02X%02X", device_name,
            EASYSETUP_TAG, mnid, setup_id, 0, mac[4], mac[5]);
+    ssid[strlen(ssid)] = '\0';
+  }
 
   st_print_log("[ST_ES] ssid : %s\n", ssid);
   return 0;
diff --git a/service/st-app-fw/src/st_manager.c b/service/st-app-fw/src/st_manager.c
index d05857b8..29cfafd2 100644
--- a/service/st-app-fw/src/st_manager.c
+++ b/service/st-app-fw/src/st_manager.c
@@ -26,6 +26,9 @@
 #ifdef OC_SECURITY
 #include "security/oc_doxm.h"
 #include "security/oc_pstat.h"
+#ifdef OC_RPK
+#include "mbedtls/base64.h"
+#endif
 #endif
 #include "st_cloud_manager.h"
 #include "st_data_manager.h"
@@ -415,6 +418,38 @@ exit:
 }
 #endif /* !STATE_MODEL */
 
+#ifdef OC_RPK
+static void
+get_rpk_cpubkey_and_token(uint8_t *cpubkey, int *cpubkey_len,
+  uint8_t *token, int *token_len)
+{
+  if (!g_prov_resource.cpub_len)
+    st_print_log("[ST_MGR] Wrong cpub_len(zero) for %s!!!\n",
+      __func__);
+
+  memcpy(cpubkey, &g_prov_resource.cpub, g_prov_resource.cpub_len);
+  *cpubkey_len = g_prov_resource.cpub_len;
+
+  if (!g_prov_resource.token_hash_len)
+    st_print_log("[ST_MGR] Wrong token_hash_len(zero) for %s!!!\n",
+      __func__);
+
+  memcpy(token, &g_prov_resource.token_hash, g_prov_resource.token_hash_len);
+  *token_len = g_prov_resource.token_hash_len;
+}
+
+static void
+get_rpk_own_key(uint8_t *priv_key, int *priv_key_len)
+{
+  if (!g_prov_resource.seckey_len)
+    st_print_log("[ST_MGR] Wrong seckey_len(zero) for %s!!!\n",
+      __func__);
+
+  memcpy(priv_key, &g_prov_resource.seckey, g_prov_resource.seckey_len);
+  *priv_key_len = g_prov_resource.seckey_len;
+}
+#endif /*OC_RPK*/
+
 static void
 set_sc_prov_info(void)
 {
@@ -423,6 +458,71 @@ set_sc_prov_info(void)
   char uuid[OC_UUID_LEN];
   int i = 0;
 
+#ifdef OC_RPK
+  st_configuration_t *conf = st_data_mgr_get_config_info();
+  oc_doxm_method_t otm_method = conf->easy_setup.ownership_transfer_method;
+
+  if (otm_method == OC_RPK) {
+
+    st_rpk_profile_t *rpk_profile = st_data_get_rpk_profile();
+
+    uint8_t otm_hash_seed[16]; /* we assume that sn(12bytes) + nonce(4bytes) */
+    int ret = 0;
+
+    ret = mbedtls_sha256_ret((unsigned char*)rpk_profile->sn, rpk_profile->sn_len,
+          g_prov_resource.sn, 0);
+    if (ret != 0) {
+      st_print_log("%s: Faild to convert sha256(str:%s, len:%d)",
+      __func__, rpk_profile->sn, rpk_profile->sn_len);
+      goto rpk_finish;
+    }
+
+    /* SHA256 returns 32bytes hex values */
+    g_prov_resource.sn_len = 32;
+
+    memcpy(g_prov_resource.seckey, rpk_profile->seckey, sizeof(rpk_profile->seckey));
+    g_prov_resource.seckey_len = sizeof(rpk_profile->seckey);
+    memcpy(g_prov_resource.pubkey, rpk_profile->pubkey, sizeof(rpk_profile->pubkey));
+    g_prov_resource.pubkey_len = sizeof(rpk_profile->pubkey);
+
+    if (rpk_profile->sn_len == 0) {
+      st_print_log("%s: orig_sn length zero!!", __func__);
+      st_print_log("%s: sha256_sn(len:%d) dump", __func__, g_prov_resource.sn_len);
+      //hex_dump_data(g_prov_resource.sn, g_prov_resource.sn_len);
+
+      st_print_log("%s: seckey(len:%d) dump", __func__, sizeof(rpk_profile->seckey));
+      //hex_dump_data(g_prov_resource.seckey, sizeof(rpk_profile->seckey));
+
+      st_print_log("%s: pubkey(len:%d) dump", __func__, sizeof(rpk_profile->pubkey));
+      //hex_dump_data(g_prov_resource.pubkey, sizeof(rpk_profile->pubkey));
+    }
+
+    g_prov_resource.nonce = oc_random_value();
+
+    /* Update thing's supported otm features status
+     * It depends on Mobile side process - Samsung's ST_APP's features
+     * We assume that rpk_profile->sn is 12bytes string.
+     */
+    memcpy(otm_hash_seed, rpk_profile->sn, 12);
+    otm_hash_seed[15] = (g_prov_resource.nonce & 0xFF);
+    otm_hash_seed[14] = ((g_prov_resource.nonce >> 8) & 0xFF);
+    otm_hash_seed[13] = ((g_prov_resource.nonce >> 16) & 0xFF);
+    otm_hash_seed[12] = ((g_prov_resource.nonce >> 24) & 0xFF);
+
+    ret = mbedtls_sha256_ret(otm_hash_seed, 16,
+          g_prov_resource.otm_own_hash, 0);
+    if (ret != 0)
+      st_print_log("[ST_MGR] %s: Faild to convert sha256 for otm_hash(%d)\n",
+        __func__, ret);
+
+    g_prov_resource.otmsupportfeature = rpk_profile->otmsupf;
+
+    oc_sec_set_cpubkey_and_token_load((oc_sec_get_cpubkey_and_token)get_rpk_cpubkey_and_token);
+    oc_sec_set_own_key_load((oc_sec_get_own_key)get_rpk_own_key);
+  }
+rpk_finish:
+#endif /*OC_RPK*/
+
   g_prov_resource.targets = (sec_provisioning_info_targets *)calloc(
     target_size, sizeof(sec_provisioning_info_targets));
   if (!g_prov_resource.targets) {
@@ -853,37 +953,6 @@ st_unregister_status_handler(void)
   g_st_status_cb = NULL;
 }
 
-bool
-st_register_rpk_handler(st_rpk_handle_cpubkey_and_token_cb_t pubkey_cb,
-                        st_rpk_handle_priv_key_cb_t privkey_cb)
-{
-  if (!pubkey_cb || !privkey_cb) {
-    st_print_log(
-      "[ST_MGR] Failed to register RPK handler - invalid parameter\n");
-    return false;
-  }
-
-#ifdef OC_SECURITY
-  oc_sec_set_cpubkey_and_token_load((oc_sec_get_cpubkey_and_token)pubkey_cb);
-  oc_sec_set_own_key_load((oc_sec_get_own_key)privkey_cb);
-  return true;
-#else  /* OC_SECURITY */
-  st_print_log("[ST_MGR] Un-secured build can't handle RPK\n");
-  return false;
-#endif /* !OC_SECURITY */
-}
-
-void
-st_unregister_rpk_handler(void)
-{
-#ifdef OC_SECURITY
-  oc_sec_unset_cpubkey_and_token_load();
-  oc_sec_unset_own_key_load();
-#else  /* OC_SECURITY */
-  st_print_log("[ST_MGR] Un-secured build can't handle RPK\n");
-#endif /* !OC_SECURITY */
-}
-
 #ifndef STATE_MODEL
 static void
 st_manager_evt_stop_handler(void)
diff --git a/service/st-app-fw/unittest/stmanagertest.cpp b/service/st-app-fw/unittest/stmanagertest.cpp
index eed77551..2ef0cc8f 100644
--- a/service/st-app-fw/unittest/stmanagertest.cpp
+++ b/service/st-app-fw/unittest/stmanagertest.cpp
@@ -285,12 +285,3 @@ TEST_F(TestSTManager, st_register_status_handler)
     st_unregister_status_handler();
 }
 
-#ifdef OC_SECURITY
-TEST_F(TestSTManager, st_register_rpk_handler)
-{
-    bool ret = st_register_rpk_handler(rpk_cpubkey_and_token_handler,
-                                       rpk_priv_key_handler);
-    EXPECT_TRUE(ret);
-    st_unregister_rpk_handler();
-}
-#endif
\ No newline at end of file
-- 
2.16.1.windows.1

